<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【比特币专题03】隔离见证、闪电网络</title>
    <link href="/2021/11/13/2021-11-13%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9803-%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81%E3%80%81%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/11/13/2021-11-13%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9803-%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81%E3%80%81%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近通读了一遍《精通比特币》，对比特币中运行机制和实现原理有了初步的认识和了解。其中隔离见证和闪电网络是此前学习中遇到到两个困惑点，现在也大致有所了解，故而本篇文章就来谈谈我的个人理解，基本上是对书里关键知识点的提炼和总结，下方也给出了电子书连接。如有任何错误，欢迎批评指出~</p><p class='note note-info'><a href=https://github.com/tianmingyun/MasterBitcoin2CN>精通比特币电子书链接</a>  </p><h1 id="隔离见证"><a href="#隔离见证" class="headerlink" title="隔离见证"></a>隔离见证</h1><p>隔离见证提出的背景：随着比特币火热发展，网络上的交易量越来越大，而由于区块大小受限，一个区块能打包的交易数量是有一定限制的，而出块速度限定在10分钟一次，这就导致无法满足交易吞吐量的增长。那么隔离见证提出，挑战了交易结构，使得一个区块可以容纳更多的交易，从而提高了交易吞吐量，当时隔离见证还有别的好处，可以去看书中内容<a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch07.md#781-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81">隔离见证的好处</a>。当然提高比特币性能（比如提高交易吞吐量）的方法还有很多，这里不再展开。</p><p class='note note-primary'>隔离见证相关BIP方案:<br>  <a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">BIP-141 隔离见证的定义</a>  <br>    <a href="https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki">BIP-144 隔离见证网络序列化</a></p><h2 id="关键知识"><a href="#关键知识" class="headerlink" title="关键知识"></a>关键知识</h2><ul><li>在比特币环境中，数字签名是见证的<em>一种类型</em>，但更广义来说，见证是指能够满足对UTXO施加的条件并解锁该UTXO以供消费的任何解决方案。术语“见证”是“解锁脚本”或“scriptSig”的更一般的术语。</li><li>在引入隔离见证之前，交易中的每一个输入后面紧跟着的就是解锁它的见证数据。见证数据作为每个输入的一部分嵌入到交易中。术语<em>隔离见证</em>（简称<em>segwit</em>）只是指把特定输出的签名或解锁脚本隔离开。“单独的scriptSig”或“单独的签名”就是它最简单的形式。</li><li>乍一看，隔离见证似乎只是对交易构造方式的改变，属于交易级特性，但事实并非如此。其实，隔离见证是对单独的UTXO花费方式的更改，因此可以说是每个输出层面的特性。</li><li>当交易使用UTXO时，必须提供一个见证。在传统的UTXO中，锁定脚本要求见证数据<em>内嵌</em>在花费UTXO的交易的输入部分。但是，隔离见证UTXO指定了一个锁定脚本，该脚本可以用输入之外的见证数据（隔离）满足。</li><li><strong>隔离见证是一个软分叉</strong></li></ul><h2 id="TXID-和-WTXID"><a href="#TXID-和-WTXID" class="headerlink" title="TXID 和 WTXID"></a>TXID 和 WTXID</h2><ul><li>隔离见证的最大好处之一就是<strong>消除了第三方交易延展性</strong>。</li><li>在隔离见证之前，交易可以通过第三方巧妙地修改其签名，在不改变任何基本属性（输入，输出，金额）的情况下更改其交易ID（哈希）。这为拒绝服务DOS攻击，以及对有缺陷的钱包软件的攻击创造了机会，这些软件假定未经证实的交易哈希是不可变的。</li><li>通过引入隔离见证，交易有两个标识符txid和wtxid。传统的txid是序列化交易的双SHA256哈希，没有见证数据。交易的wtxid是具有见证数据的交易的新序列化格式的双SHA256哈希。</li><li>传统txid的计算方式与非隔离见证交易完全相同。但是，由于隔离见证交易在每个输入中都有空的scriptSig，不存在可由第三方修改的交易部分。因此，在隔离交易中，即使交易未经确认，txid也是不能被第三方修改的。</li></ul><blockquote><p><strong>提示</strong> 隔离见证交易有两个ID：txid和wtxid。txid是没有见证数据的交易的哈希，wtxid是包含见证数据的哈希。所有输入都是隔离见证输入的交易，不受第三方交易延展性影响。</p></blockquote><hr><ul><li>TXID的生成和传统方式一致：是对version, txins, txouts, nLocktime序列化后的数据，进行两次SHA256哈希</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[nVersion][txins][txouts][nLockTime]<br></code></pre></td></tr></table></figure><ul><li>WTXID的生成：对version, marker, flag, txins, txouts, witness, nLocktime序列化后的数据，进行两次SHA256哈希</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[nVersion][marker][flag][txins][txouts][witness][nLockTime]<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131049973.png" alt="TXID与WTXID的生成"></p><h2 id="隔离见证的数据到底放在哪里"><a href="#隔离见证的数据到底放在哪里" class="headerlink" title="隔离见证的数据到底放在哪里"></a>隔离见证的数据到底放在哪里</h2><p>在了解隔离见证的大致原理后，我其实还是存在一个疑惑：既然说见证相当于是原来的签名数据（解锁脚本），与原来的交易数据隔离开，那么这些见证数据到底放在哪里了？</p><ul><li><p>通过<a href="https://www.jianshu.com/p/eef8e260b9f7">比特币探究之隔离见证</a> 这篇文章，了解到原来的签名数据放到了见证数据中，见证数据在CTxIn 是一个新的字段，但是只有在交易被序列化网络传输时才参与，呼应上文计算TXID时，witness是不需要序列化的；</p></li><li><p>通过<a href="https://boinnex.com/what-is-segwit/">外文- Segwit如何工作的</a> 这篇文章，进一步了解到在生成区块时，输入的见证数据同样构成一棵Merkle Tree，并把root放到了区块中的币基交易的output的锁定脚本中，具体原文描述如下图。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131137534" alt="ScriptPubKey of Witness in coinbase "></p><h1 id="闪电网络"><a href="#闪电网络" class="headerlink" title="闪电网络"></a>闪电网络</h1><p>闪电网络其实也是一种提高比特币交易性能的方法，简单来说，就是将大量交易放到比特币区块链之外进行。在具体介绍闪电网络是如何工作运行前，还需要先介绍状态通道，支付通道，HTLC哈希时间锁合约等概念。</p><h2 id="状态通道和支付通道"><a href="#状态通道和支付通道" class="headerlink" title="状态通道和支付通道"></a>状态通道和支付通道</h2><p>基本概念：</p><ul><li><em>支付通道Payment channels</em>是在比特币区块链之外，双方交换比特币交易的无信任机制。</li><li>实际上，<em>通道channel</em> 一词是一个比喻。状态通道是区块链外，由双方之间的交换状态代表的虚拟构想。实际上没有“通道”，底层数据传输机制也并不是通道。我们使用通道这个术语来表示链外双方之间的关系和共享状态。</li><li>支付通道是更广泛的<em>状态通道state channel</em>概念的一部分，状态通道代表了链外状态的变化，通过最终在区块链上结算得到保障。支付通道是一种状态通道，其中被改变的状态是虚拟货币余额。</li></ul><hr><p>《精通比特币》中对支付通道的描述感觉过于复杂，这里用Bitcoin Developer Guide里的微支付通道来举例说明，在之前博客[【比特币专题02】Developer Guide导读](<a href="https://2017zhangyuxuan.github.io/2021/10/11/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9802-Developer">https://2017zhangyuxuan.github.io/2021/10/11/2021-10-11比特币专题02-Developer</a> Guide/) 也有介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131147856.(null)" alt="微支付通道"></p><ul><li>其工作原理大体上可以这样描述：A给B打工，B首先使用A和B的签名，使用P2SH的方式，发送一定金额到脚本地址，并将该交易立即传播到比特币网络上；然后B创造第二个交易，并用到刚刚A的签名，其输入是第一个交易的脚本地址，输出是B的地址（相当于全额返回给B），然后给这个交易加上Locktime，比如说一天后才能广播这个交易。然后A给B工作一部分内容后，A要求B先支付这份工作量的薪水，那么B就创建一份新的交易，从原来全额给B变成分出一部分金额给A，这个新的交易拷贝给A，这样A就可以广播这个新的交易从而获得薪水。（实际上A只需要在locktime过期前，广播最后版本的交易即可）<ul><li>B创建的第一笔交易和第二笔交易，可以理解为《精通比特币》中的<em>注资交易funding transaction</em>或<em>锚点交易anchor transaction</em>：通过在区块链上锁定共享状态的交易，在交易两方之间建立了一个状态通道。在支付通道的示例中，锁定的状态即为通道的初始余额（以货币计）</li><li>随后双方交换已签名的交易，这被称为<em>承诺交易commitment transactions</em>。承诺交易会改变初始状态。这些交易是有效的交易，因为它们<em>可以</em>被任何一方提交进行结算，但是在通道关闭之前，每一方都会将其在链下保留。</li><li>最后，通道可以协商关闭，即向区块链提交最后的<em>结算交易settlement transaction</em>，或者由任何一方单方面提交最后承诺交易到链上。</li></ul></li><li>为什么采用支付通道这样的方式呢，因为A诉求是及时支付薪水，但是因为量小，B不能每次都立即创造一个交易即刻支付，这样的交易费的成本太高了。所以利用这样的方式，既确保了A的薪水是及时得到确认的，又可以使得只需一个交易就一次性支付薪水</li><li>实际上，更改交易金额的输出，这个权利是在B的，因为B有A的签名但A没有B的签名，A拿的是经过B签名后的交易副本（这个交易被B签名过了，所以是有效的）。所以A能实时确保自己对应工作量的薪水能及时支付，就算中途B跑路了，也只是损失一小部分工作量的薪水，之前的薪水都可以得到支付。而对B来说，如果A没有工作，那B也能在locktime 过期后拿回自己的钱（不过这样就需要等待一个locktime的时间）</li></ul><h2 id="HTLC哈希时间锁合约"><a href="#HTLC哈希时间锁合约" class="headerlink" title="HTLC哈希时间锁合约"></a>HTLC哈希时间锁合约</h2><p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch12.md#1255-%E5%93%88%E5%B8%8C%E6%97%B6%E9%97%B4%E9%94%81%E5%90%88%E7%BA%A6htlc">HTLC 哈希时间锁合约</a> 原文中介绍得比较详细了，这里简单总结一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过密钥R生成哈希值H</span><br>H = Hash(R)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 实现HTLC的脚本可能如下所示：</span><br>IF<br>Payment if you have the secret R<br>    HASH160 &lt;H&gt; EQUALVERIFY<br>ELSE<br>    # Refund after timeout.<br>    &lt;locktime&gt; CHECKLOCKTIMEVERIFY DROP<br>    &lt;Payer Public Key&gt; CHECKSIG<br>ENDIF<br></code></pre></td></tr></table></figure><ul><li>任何知道密钥R，其哈希值等于H的人，都可以通过行使IF语句的第一个子句来兑换该输出。</li><li>如果密钥R没有被透露，HTLC中写明了，在一定数量的区块之后，付款人可以使用IF语句中的第二个子句申请退款。</li></ul><h2 id="闪电网络运行"><a href="#闪电网络运行" class="headerlink" title="闪电网络运行"></a>闪电网络运行</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131152708.(null)"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131152805.(null)"></div></div></div><p align="middle"><font size="2" color="grey">左图：支付通道初始状态；右图：闪电网络运行流程</font></p><p>接下来说明一下，闪电网络是如何工作：</p><ul><li>在这个例子中，我们有五个参与者：Alice, Bob, Carol, Diana, and Eric。这五名参与者已经彼此之间开设了支付通道。Alice和Bob有支付通道。Bob连接Carol，Carol连接到Diana，Diana连接Eric。为了简单起见，我们假设每个通道每个参与者都注资2个比特币资金，每个通道的总容量为4个比特币，也就是如左图所示的初始状态</li><li>Alice想要支付给Eric1个比特币。但是，Alice并没有直接连接Eric的支付通道。创建支付通道需要注资交易，而这笔交易必须首先提交给比特币区块链。Alice不想建立一个新的支付通道还要支出更多的手续费。那么就可以通过闪电网络来进行支付。</li></ul><ol><li>Alice通过路由发现了一条从Alice到Eric的一条支付路由，由多个支付通道组成。此时Alice和Eric可以进行通信，Eric生成一个密钥R，并进行hash，将哈希值H发送给Alice。</li><li>Alice构造一个HTLC，支付1.003BTC到哈希H（多出来的0.003BTC是给路由上3个节点的费用），并可以在10区块内得到退款。Alice将此HTLC提供给Bob，从和Bob之间的通道余额中扣除1.003比特币，并将其提交给HTLC。该HTLC具有以下含义：<em>“如果Bob知道密钥，Alice将其通道余额的1.003支付给Bob，或者如果超过10个区块后，则退还入Alice的余额”</em>。</li><li>Bob构造一个新的HTLC，支付1.002BTC到哈希H，如果Carol知道了密钥R，可以去取走HTLC中的1.002BTC，然后Bob也可以取走Alice提供的1.003BTC，相当于赚取了0.001BTC；如果Carol不能提供密钥，Bob也可以在9个区块时间内取回1.002BTC</li><li>Carol向Diana提供1.001BTC的HTLC，同上面一样</li><li>Dinana向Eric提供1.0BTC的HTLC</li><li>Eric知道密钥，向Diana出示了密钥R，因此取走了HTLC中的1.0BTC</li><li>Diana从Eric知道了密钥R，再向Carol出示密钥R，获得了1.001BTC，此时在Eric和Diana中支付通道中，Diana余额只有1.0BTC了，但在Carol和Diana的支付通道中，Diana余额为3.001BTC，对比原来的2+2，赚取了0.001BTC</li><li>Carol向Diana支付了1.001BTC，再从Bob处赚取了1.002BTC，赚取了0.001BTC</li><li>Bob向Carol支付了1.002BTC，从Alice处赚取了1.003BTC，赚取了0.001BTC</li><li>最终Alice支付了1.003BTC，实际上1BTC转账给了Eric，0.003支付给了路由上的其他节点</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CryptoPP C++库学习使用</title>
    <link href="/2021/11/01/2021-11-01%20CryptoPP%E5%BA%93%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/11/01/2021-11-01%20CryptoPP%E5%BA%93%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>参考书籍：《深入浅出CryptoPP密码学库》<br>crypto++  密码学库 ：<a href="https://github.com/weidai11/cryptopp">https://github.com/weidai11/cryptopp</a><br>电子书下载 ：<a href="https://gitee.com/locomotive_crypto">https://gitee.com/locomotive_crypto</a>    </p></blockquote><p>最近在学习比特币相关技术，在比特币系统中使用大量哈希加密、签名验证等操作，为了用代码来模拟实现比特币的运行过程，学习一个支持密码原语操作的第三方库是非常有必要的。</p><p>最为知名的密码学相关开源库应该是OpenSSL了，但是由于官网是一堆英文，学习起来太吃力，后来机缘巧合下发现了CryptoPP这个库，而且还有专门的中文书籍来讲解使用，因此就决定学习CryptoPP库，本篇论文也是基于《深入浅出CryptoPP密码学库》阅读，整理出关键章节内容，供大家参考学习。</p><p class='note note-info'>1. CryptoPP库的安装使用这里不再详细说明，请大家自行搜索网上教程  <br>2. 后来看到OpenSSL也有一个中文手册学习网站，也推荐给大家https://www.openssl.net.cn/</p><h1 id="string-和-SecByteBlock类型互换"><a href="#string-和-SecByteBlock类型互换" class="headerlink" title="string 和 SecByteBlock类型互换"></a>string 和 SecByteBlock类型互换</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// SecByteBlock 转 string</span><br><br>SecByteBlock iv; ... <span class="hljs-comment">// C++-style cast </span><br><br>std::string token = std::<span class="hljs-built_in">string</span>(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt;(iv.<span class="hljs-built_in">data</span>()), iv.<span class="hljs-built_in">size</span>());<br><br><br><br><span class="hljs-comment">// string 转 SecByteBlock</span><br><br>std::string str; ... <span class="hljs-comment">// C++-style cast </span><br><br><span class="hljs-function">SecByteBlock <span class="hljs-title">sbb</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> byte*&gt;(str.data()), str.size())</span></span>;<br></code></pre></td></tr></table></figure><h1 id="第四章-初识CryptoPP库"><a href="#第四章-初识CryptoPP库" class="headerlink" title="第四章 初识CryptoPP库"></a>第四章 初识CryptoPP库</h1><h2 id="Hex编解码字符串"><a href="#Hex编解码字符串" class="headerlink" title="Hex编解码字符串"></a>Hex编解码字符串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;filters.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;hex.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 第一种编码方式</span><br><br>    HexEncoder hex;<br><br>    string str = <span class="hljs-string">&quot;I like&quot;</span>;<br><br>    string hexstr;<br><br>    hex.<span class="hljs-built_in">Detach</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(hexstr));<br><br>    hex.<span class="hljs-built_in">Put</span>(<span class="hljs-keyword">reinterpret_cast</span>&lt;byte*&gt;(&amp;str[<span class="hljs-number">0</span>]),str.<span class="hljs-built_in">size</span>());  <span class="hljs-comment">// 注意是会追加写入的</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;str:&quot;</span> &lt;&lt; str &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;hexstr:&quot;</span> &lt;&lt; hexstr &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// 第二种编解码写法  Source -&gt; Filter -&gt; Sink  这是一种Pipeline的方式</span><br><br>    string encode,decode;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">enc</span><span class="hljs-params">(str, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> HexEncoder(<span class="hljs-keyword">new</span> StringSink(encode)))</span></span>;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">dec</span><span class="hljs-params">(hexstr, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> HexDecoder(<span class="hljs-keyword">new</span> StringSink(decode)))</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;encode:&quot;</span>&lt;&lt;encode &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;decode:&quot;</span>&lt;&lt;decode &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第五章-随机数生成器"><a href="#第五章-随机数生成器" class="headerlink" title="第五章 随机数生成器"></a>第五章 随机数生成器</h1><p>主要可以关注GenerateBlock方法，生成指定字节长度的随机数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;osrng.h&gt;</span> <span class="hljs-comment">// 可以使用 AutoSeededRandomPool ，该随机器不用设置种子</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;rng.h&gt;</span> <span class="hljs-comment">//包含LC_RNG算法的头文件</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span> <span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP; <span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Array_Size 64</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//定义一个LC_RNG随机数发生器对象，并设置其种子</span><br><br>    <span class="hljs-function">LC_RNG  <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生一个比特的随机数：&quot;</span> &lt;&lt; rng.<span class="hljs-built_in">GenerateBit</span>() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生一个字节的随机数：&quot;</span> &lt;&lt; rng.<span class="hljs-built_in">GenerateByte</span>() &lt;&lt; endl;<br><br>    byte output[Array_Size + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//定义一个缓冲区      </span><br><br><br><br>    <span class="hljs-comment">//产生Array_Size字节长度的随机数</span><br><br>    rng.<span class="hljs-built_in">GenerateBlock</span>(output, Array_Size);  <span class="hljs-comment">// 这里也可直接传入SecByteBlock</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生Array_Size长度的随机数（十六进制）：&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Array_Size; ++i)<br><br>    &#123;<span class="hljs-comment">//将获得的随机数转换成十六进制并输出</span><br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X&quot;</span>, output[i]);<br><br>    &#125;<br><br>    cout &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生一个100到1000之间的随机数：&quot;</span> &lt;&lt; rng.<span class="hljs-built_in">GenerateWord32</span>(<span class="hljs-number">100</span>, <span class="hljs-number">1000</span>) &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">//丢弃掉随机数发生器接下来产生的100个字节数据</span><br><br>    rng.<span class="hljs-built_in">DiscardBytes</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">int</span> arry[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><br>    rng.<span class="hljs-built_in">Shuffle</span>(arry, arry + <span class="hljs-number">10</span>); <span class="hljs-comment">//打乱数组arry中元素的顺序</span><br><br>    <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第六章-Hash函数"><a href="#第六章-Hash函数" class="headerlink" title="第六章 Hash函数"></a>第六章 Hash函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sha.h&gt;</span> <span class="hljs-comment">//使用SHA384</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;filters.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;hex.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span> <span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP; <span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">try</span><br><br>    &#123;<br><br>        SHA256 sha; <span class="hljs-comment">//定义一个SHA256的类对象</span><br><br>        byte msg[] = <span class="hljs-string">&quot;I like cryptography very much&quot;</span>;<br><br><br><br>        <span class="hljs-comment">// 使用pipeline范式</span><br><br>        <span class="hljs-function">SecByteBlock <span class="hljs-title">tmp</span><span class="hljs-params">(msg, <span class="hljs-keyword">sizeof</span>(msg)<span class="hljs-number">-1</span>)</span></span>;<br><br>        string r;<br><br>        <span class="hljs-function">StringSource <span class="hljs-title">s1</span> <span class="hljs-params">(tmp, tmp.size(),<span class="hljs-literal">true</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HashFilter(sha,    <span class="hljs-comment">// 使用其他hash函数，更换一下类型即可</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HexEncoder(</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> StringSink(r))))</span></span>;<br><br>        cout &lt;&lt; r &lt;&lt; endl;<br><br>        r.<span class="hljs-built_in">clear</span>();  <span class="hljs-comment">// 清空一下，不然后面会追加</span><br><br><br><br>        <span class="hljs-comment">// 连续两次Hash256，再用Hex编码输出</span><br><br>        SHA256 sha2;<br><br>        <span class="hljs-function">StringSource <span class="hljs-title">s2</span> <span class="hljs-params">(<span class="hljs-string">&quot;I like cryptography very much&quot;</span>,<span class="hljs-literal">true</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HashFilter(sha,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HashFilter(sha2,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HexEncoder(</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> StringSink(r)))) )</span></span>;<br><br>        cout &lt;&lt; r &lt;&lt; endl;<br><br><br><br>        <span class="hljs-function">SecByteBlock <span class="hljs-title">digest</span><span class="hljs-params">(sha.DigestSize())</span></span>; <span class="hljs-comment">//申请内存空间以存放消息摘要</span><br><br>        <span class="hljs-comment">//CalculateDigest()相当于Update()+Final()</span><br><br>        <span class="hljs-comment">// Update用来向sha输入，Final计算hash值，同时重置hash函数内部状态</span><br><br>        sha.<span class="hljs-built_in">CalculateDigest</span>(digest, msg, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(msg) - <span class="hljs-number">1</span>);<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;digest2=&quot;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; sha.<span class="hljs-built_in">DigestSize</span>(); ++i)<br><br>        &#123;<span class="hljs-comment">//以十六进制输出Hash值</span><br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X&quot;</span>, digest[i]);<br><br>        &#125;<br><br>        cout &lt;&lt; endl;<br><br><br><br>        <span class="hljs-comment">//计算msg消息的Hash值</span><br><br>        <span class="hljs-keyword">bool</span> res;<br><br>        res = sha.<span class="hljs-built_in">VerifyDigest</span>(digest, <span class="hljs-comment">//可能抛出异常</span><br><br>                               msg, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(msg) - <span class="hljs-number">1</span>); <span class="hljs-comment">//去掉字符串最后的&#x27;\0&#x27;</span><br><br>        cout &lt;&lt; <span class="hljs-string">&quot;res = &quot;</span> &lt;&lt; boolalpha &lt;&lt;res &lt;&lt; endl;  <span class="hljs-comment">// 这里的boolalpha 是为了输出bool值true或者false</span><br><br><br><br>    &#125;<br><br>    <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword">const</span> Exception&amp; e)<br><br>    &#123;<span class="hljs-comment">//出现异常</span><br><br>        cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl; <span class="hljs-comment">//异常原因</span><br><br>    &#125;<br><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十一章-公钥密码学数学基础"><a href="#第十一章-公钥密码学数学基础" class="headerlink" title="第十一章 公钥密码学数学基础"></a>第十一章 公钥密码学数学基础</h1><h2 id="大整数-与-大素数生成"><a href="#大整数-与-大素数生成" class="headerlink" title="大整数 与 大素数生成"></a>大整数 与 大素数生成</h2><ul><li>可以再研究一下大整数的一些用法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;integer.h&gt;</span><span class="hljs-comment">//使用Integer</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span><span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;osrng.h&gt;</span><span class="hljs-comment">//使用AutoSeededRandomPool</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;nbtheory.h&gt;</span><span class="hljs-comment">//使用PrimeAndGenerator、VerifyPrime</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP;<span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    AutoSeededRandomPool rng; <span class="hljs-comment">// 定义随机数发生器对象</span><br><br>    <span class="hljs-comment">// 定义PrimeAndGenerator对象，利用随机数发生器rng产生素数p和q</span><br><br>    <span class="hljs-comment">// 要求产生的p是1024比特的素数，q是512比特的素数</span><br><br>    <span class="hljs-function">PrimeAndGenerator <span class="hljs-title">pag</span><span class="hljs-params">(<span class="hljs-number">1</span>, rng, <span class="hljs-number">1024</span>, <span class="hljs-number">512</span>)</span></span>;<br><br>    Integer p = pag.<span class="hljs-built_in">Prime</span>(); <span class="hljs-comment">// 获取素数p的值</span><br><br>    Integer q = pag.<span class="hljs-built_in">SubPrime</span>(); <span class="hljs-comment">// 获取素数q的值</span><br><br>    Integer r = (p - <span class="hljs-number">1</span>) / q / <span class="hljs-number">2</span>; <span class="hljs-comment">// 计算r的值，因为p=2*r*q+1，delta=1</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p(&quot;</span> &lt;&lt; p.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot;)：&quot;</span> &lt;&lt; p &lt;&lt; endl; <span class="hljs-comment">// 打印p的值及比特数</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;q(&quot;</span> &lt;&lt; q.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot;)：&quot;</span> &lt;&lt; q &lt;&lt; endl; <span class="hljs-comment">// 打印q的值及比特数</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;r(&quot;</span> &lt;&lt; r.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot;)：&quot;</span> &lt;&lt; r &lt;&lt; endl; <span class="hljs-comment">// 打印r的值及比特数</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">VerifyPrime</span>(rng, r, <span class="hljs-number">10</span>)) <span class="hljs-comment">// 验证r是否为素数</span><br><br>    &#123;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;r是素数&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 如果r为素数，则输出该信息</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">else</span><br><br>    &#123;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;r不是素数&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 如果r不为素数，则输出该信息</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十三章-数字签名"><a href="#第十三章-数字签名" class="headerlink" title="第十三章 数字签名"></a>第十三章 数字签名</h1><p>电子书给出的参考是ECNR数字签名算法</p><p><a href="https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA椭圆曲线 - Crypto++</a></p><p><a href="https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm">https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm</a> -》关于压缩公钥的实现可以参考 Compressed Point 这一部分</p><h2 id="私钥和公钥生成、保存"><a href="#私钥和公钥生成、保存" class="headerlink" title="私钥和公钥生成、保存"></a>私钥和公钥生成、保存</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;integer.h&gt;</span><span class="hljs-comment">//使用Integer</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span><span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;osrng.h&gt;</span><span class="hljs-comment">//使用AutoSeededRandomPool</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;eccrypto.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;oids.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;files.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;filters.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;filesystem&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;hex.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;base32.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP;<span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ECDSA_Generate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 指定 private exponent  32字节随机数，生成对应的私钥</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    string exp = &quot;E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB&quot;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    HexDecoder decoder;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    decoder.Put((byte*)&amp;exp[0], exp.size());</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    decoder.MessageEnd();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Integer x;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    x.Decode(decoder, decoder.MaxRetrievable());</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    privateKey.Initialize(ASN1::secp256r1(), x);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br><br><br>    AutoSeededRandomPool prng;<br><br>    ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;<br><br><br><br>    privateKey.<span class="hljs-built_in">Initialize</span>( prng, ASN1::<span class="hljs-built_in">secp256k1</span>() );<br><br><br><br>    <span class="hljs-comment">/* 使用ByteQueue 方便将公私钥存储在内存中，如果要持久化到磁盘，可以使用FileSink</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ByteQueue queue;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    privateKey.Save(queue);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    privateKey.Load(queue);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br><br><br><br>    <span class="hljs-comment">// 验证密钥强度</span><br><br>    <span class="hljs-keyword">bool</span> result = privateKey.<span class="hljs-built_in">Validate</span>( prng, <span class="hljs-number">3</span> );<br><br>    cout &lt;&lt; boolalpha &lt;&lt; result &lt;&lt; endl;<br><br><br><br>    Integer p = privateKey.<span class="hljs-built_in">GetPrivateExponent</span>();<br><br>    cout&lt;&lt; <span class="hljs-string">&quot;len:&quot;</span> &lt;&lt; p.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot; Private Key:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    string priHexKey;<br><br>    <span class="hljs-function">HexEncoder <span class="hljs-title">encoder</span><span class="hljs-params">(<span class="hljs-keyword">new</span> StringSink(priHexKey))</span></span>;<br><br>    p.<span class="hljs-built_in">Encode</span>(encoder, <span class="hljs-number">32</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;priHexKey:&quot;</span>&lt;&lt;priHexKey.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; priHexKey &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// Save private key in PKCS #8 format</span><br><br>    <span class="hljs-function">FileSink <span class="hljs-title">fs1</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/private.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*binary*/</span> )</span></span>;<br><br>    privateKey.<span class="hljs-built_in">Save</span>( fs1 );<br><br><br><br>    <span class="hljs-comment">// Generate publicKey</span><br><br>    ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey publicKey;<br><br>    privateKey.<span class="hljs-built_in">MakePublicKey</span>(publicKey);<br><br>    <span class="hljs-keyword">const</span> ECP::Point&amp; q = publicKey.<span class="hljs-built_in">GetPublicElement</span>();<br><br>    <span class="hljs-keyword">const</span> Integer&amp; qx = q.x;<br><br>    <span class="hljs-keyword">const</span> Integer&amp; qy = q.y;<br><br>    string qxHex, qyHex;<br><br>    <span class="hljs-function">HexEncoder <span class="hljs-title">encoderx</span><span class="hljs-params">(<span class="hljs-keyword">new</span> StringSink(qxHex))</span></span>;<br><br>    <span class="hljs-function">HexEncoder <span class="hljs-title">encodery</span><span class="hljs-params">(<span class="hljs-keyword">new</span> StringSink(qyHex))</span></span>;<br><br>    qx.<span class="hljs-built_in">Encode</span>(encoderx, <span class="hljs-number">32</span>);<br><br>    qy.<span class="hljs-built_in">Encode</span>(encodery, <span class="hljs-number">32</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;len:&quot;</span> &lt;&lt; qx.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot; Public Point x:&quot;</span> &lt;&lt; qx &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;qxHex:&quot;</span> &lt;&lt; qxHex &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;len:&quot;</span> &lt;&lt; qy.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot; Public Point y:&quot;</span> &lt;&lt; qy &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;qyHex:&quot;</span> &lt;&lt; qyHex &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// Save public key in X.509 format</span><br><br>    <span class="hljs-function">FileSink <span class="hljs-title">fs2</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/public.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*binary*/</span> )</span></span>;<br><br>    publicKey.<span class="hljs-built_in">Save</span>( fs2 );<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="私钥和公钥的加载、签名和认证"><a href="#私钥和公钥的加载、签名和认证" class="headerlink" title="私钥和公钥的加载、签名和认证"></a>私钥和公钥的加载、签名和认证</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 头文件和上述一样</span><br><br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ECDSA_LOAD</span><span class="hljs-params">()</span></span>&#123;<br><br>    AutoSeededRandomPool prng;<br><br>    <span class="hljs-function">FileSource <span class="hljs-title">fs1</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/private.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span> )</span></span>;<br><br>    <span class="hljs-function">FileSource <span class="hljs-title">fs2</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/public.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span> )</span></span>;<br><br>    ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;<br><br>    ECDSA&lt;ECP, SHA256&gt;::PublicKey publicKey;<br><br>    <span class="hljs-comment">// 加载私钥， 私钥格式：PKCS #8</span><br><br>    privateKey.<span class="hljs-built_in">Load</span>( fs1 );<br><br>    publicKey.<span class="hljs-built_in">Load</span>(fs2);<br><br><br><br>    <span class="hljs-comment">// 用私钥进行签名</span><br><br>    ECDSA&lt;ECP, SHA256&gt;::<span class="hljs-function">Signer <span class="hljs-title">signer</span><span class="hljs-params">(privateKey)</span></span>;<br><br>    string message = <span class="hljs-string">&quot;Yoda said, Do or do not. There is no try.&quot;</span>;<br><br>    string signature;<br><br><br><br><br><br>    <span class="hljs-function">StringSource <span class="hljs-title">s</span><span class="hljs-params">( message, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">new</span> SignerFilter( prng,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                                      signer,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-keyword">new</span> StringSink( signature )</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                    ) <span class="hljs-comment">// SignerFilter</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>; <span class="hljs-comment">// StringSource</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;signature len:&quot;</span> &lt;&lt; signature.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; output:&quot;</span> &lt;&lt; signature &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// 将签名（包含R，S）转换成 DER 格式</span><br><br>    std::string derSign;<br><br>    <span class="hljs-comment">// Make room for the ASN.1/DER encoding</span><br><br>    derSign.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>+<span class="hljs-number">3</span>+<span class="hljs-number">3</span>+<span class="hljs-number">2</span>+signature.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-keyword">size_t</span> converted_size = <span class="hljs-built_in">DSAConvertSignatureFormat</span>(<br><br>            (byte*) (&amp;derSign[<span class="hljs-number">0</span>]), derSign.<span class="hljs-built_in">size</span>(), DSA_DER,<br><br>            (<span class="hljs-keyword">const</span> byte*) (signature.<span class="hljs-built_in">data</span>()), signature.<span class="hljs-built_in">size</span>(), DSA_P1363);<br><br>    derSign.<span class="hljs-built_in">resize</span>(converted_size);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;DER len:&quot;</span> &lt;&lt; derSign.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; DER:&quot;</span> &lt;&lt; derSign &lt;&lt; endl;<br><br>    string hexDER;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">toDER</span><span class="hljs-params">(derSign, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> HexEncoder(<span class="hljs-keyword">new</span> StringSink(hexDER)))</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;DER hex:&quot;</span> &lt;&lt; hexDER &lt;&lt; endl;<br><br><br><br>    <br><br>    <span class="hljs-comment">// 进行验证</span><br><br>    <span class="hljs-keyword">bool</span> result;<br><br>    ECDSA&lt;ECP, SHA256&gt;::<span class="hljs-function">Verifier <span class="hljs-title">verifier</span><span class="hljs-params">(publicKey)</span></span>;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">ss</span><span class="hljs-params">( signature+message, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-keyword">new</span> SignatureVerificationFilter(</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                             verifier,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">new</span> ArraySink( (byte*)&amp;result, <span class="hljs-keyword">sizeof</span>(result) )</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                     ) <span class="hljs-comment">// SignatureVerificationFilter</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>;<br><br><br><br>    <span class="hljs-comment">// 传统的C 方式 - 函数调用形式</span><br><br><span class="hljs-comment">//    result = verifier.VerifyMessage( (const byte*)message.data(), message.size(), (const byte*)signature.data(), signature.size() );</span><br><br>    <span class="hljs-keyword">if</span>(result)<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Verified signature on message&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">else</span><br><br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to verify signature on message&quot;</span> &lt;&lt; std::endl;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第三方库</tag>
      
      <tag>CryptoPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu-arm apt源配置</title>
    <link href="/2021/10/20/2021-10-20%20Ubuntu-arm%20apt%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/10/20/2021-10-20%20Ubuntu-arm%20apt%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><p>PC：M1 MacBook Air</p><p>虚拟机软件：Parallel Desktop 16.5</p><p>虚拟机操作系统：<a href="https://ubuntu.com/download/server/arm">Ubuntu Server 20.04 TLS</a></p><h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>首先就是随便搜索了一篇网上教程，来配置apt源，比如这篇</p><p><a href="https://blog.csdn.net/p1279030826/article/details/111640455">https://blog.csdn.net/p1279030826/article/details/111640455</a></p><p class='note note-info'>要注意自己的ubuntu版本和apt源设置的版本一致</p><p>但是然后呢，满怀期待执行<code>sudo apt-get update</code> 却报错了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110201532536.png" alt="apt-get update报错 "></p><p>当时很郁闷啊，因为之前在windows虚拟机上配置的时候都好使的，怎么到你这就拉胯了呢？</p><p>后来在网上找各种资料、解决办法，有的说是网络的问题，有的说是DNS解析的问题，但经过各种尝试都没有效果，后来无奈放弃，就此作罢。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>但是天无绝人之路，当我第二次再次尝试配置的时候，终于让我找到了正确答案：<a href="https://zongxp.blog.csdn.net/article/details/90604966?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link">解决方案</a></p><p>重点就是后缀要加上-ports，这样对应的镜像源才是arm源，才能适配M1的mac系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">deb http://mirrors.aliyun.com/ubuntu-ports/ focal main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-proposed main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>​         </p><p>换源之后执行成功，nice！</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110201533176.png" alt="apt-get update成功"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总的来说踩了个坑，而究其原因，还是自己对这个apt配置参数没有理解到位，仅仅只是照猫画虎，复制教程，而没有领会其中的真意。同时对这个系统架构arm 和 x86的差异没有深刻认识，不同架构之间软件肯定是需要进行适配的，没有很清楚的认识到这一点。所以呢，学海无涯，我还差得远呢~</p><div align='center'><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110251023808.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" width="50%" height="50%" align="middle" ></div>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题01】白皮书导读</title>
    <link href="/2021/10/16/2021-10-16%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9801-%E7%99%BD%E7%9A%AE%E4%B9%A6/"/>
    <url>/2021/10/16/2021-10-16%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9801-%E7%99%BD%E7%9A%AE%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h1><p>论文地址：<a href="https://bitcoin.org/bitcoin.pdf">https://bitcoin.org/bitcoin.pdf</a></p><p>由于在“基于信任”模式下的交易，存在交易成本增加、限制了交易额的大小即阻断小额交易、商家欺诈行为等问题，本论文提出解决方案即比特币，这是一个P2P分布式的电子现金交易网络，依靠hash和加盖时间戳，以及工作量证明机制等手段，解决了双重支付问题，并在极大程度上保证了交易的有效性、正确性、抗伪性。论文中也详细介绍了实现所用到的技术、机制、原理等。</p><h1 id="主要收获"><a href="#主要收获" class="headerlink" title="主要收获"></a>主要收获</h1><p>个人感觉最大的收获就是对比特币的运行机制有了大体的认识，了解了整体流程，虽然可能一些技术的实现细节还是不够明朗。下面就是我对其中各个部分的认识和理解。</p><ul><li>在引言介绍部分，引出了比特币的产生背景，基于第三方机构的交易存在的种种问题，并提出比特币这一解决方案。然后接下来的各个章节介绍比特币涉及的主要关键技术。</li><li>Transactions部分描述了交易是如何被记录的，其中运用了Hash和公私钥，但仅仅记录是无法验证交易的有效性，即存在双重支出问题。</li><li>Timestamp Server部分描述了具体每个节点（服务器）的工作，即对形成的区块进行Hash，并加盖上时间戳，根据时序进行排列形成链。</li><li>Proof-of-Work部分描述了进一步说明Timestamp server的实现，即使用工作证明机制，通过找到满足条件的nonce来获得记账权，因为寻找这个nonce依靠CPU算力，CPU算力越高找到的概率越大，即one-CPU-one-vote规则，解决了多数决策中的代表问题。同时这样的方式，也保证了如果攻击者想要篡改某个区块，就先得把这个区块之后的区块都进行修改，而每个区块都是需要靠大量CPU算力来找到nonce，获得记账权进行修改，这样的成本是很大的。</li><li>Network部分则是描述了比特币网络的工作流程。其中提到的一个很重要的原则就是，所有人是默认最长链是最正确的。而正是有这一前提，才有了只要网络里超过51%的算力属于诚实节点，就能保证区块链里交易信息的正确性，因为诚实节点的算力超过一半，算得比攻击节点快，那么最长链肯定属于诚实节点一方。</li><li>Incentive部分说明的是激励机制，给予抢到记账权的节点一定的比特币，正是有这样的激励机制，各个节点才会愿意投入算力去争夺记账权，也才能是之前的工作量证明机制正常运行。还有一种就是以交易手续费的方式进行奖励。</li><li>Reclaiming Disk Space部分说明区块链可以通过Merkel Tree技术方法来压缩数据，减小空间存储。</li><li>Simplified Payment Verification部分则是说明了如何来检验交易的有效性，因为基于之前最长链总是正确的原则， 因此只要向网络上的节点进行询问，找到最长链就可以验证所有的有效交易记录。</li><li>Combining and Splitting Value部分描述的是形成交易的细节，是可以有多个输入的，而输出最多是两个。</li><li>Privacy部分则是说明比特币网络中的隐私相关问题。</li><li>Calculations部分用具体的数学计算来说明了，当一个攻击者在落后最长链Z个块的情况下，想要追上最长链的概率。结果表明，当落后的块数越多，追上的概率就越小，也就保证了区块链的安全性和稳定性。</li><li>Conclusion部分则是最后进行了总结。</li></ul><h1 id="存在疑问"><a href="#存在疑问" class="headerlink" title="存在疑问"></a>存在疑问</h1><ul><li><strong>问题1：怎么理解数字货币中的double-spending problem？</strong></li></ul><p>用数字货币交易时，是用先前的交易和下一个拥有者的公钥做Hash，然后用拥有者的私钥进行签名形成这一次交易，比如这次交易A支付给B 1个电子货币，然后A的余额只有1个电子货币，如果没有第三方机构进行监管，确认这个电子货币已经交易出去了，那么A可以继续拿这1个电子货币继续交易，而接受者也无法确认这1个电子货币是否真正的属于他。也就是说，没有第三方监管机构，也没有引入区块链P2P这个网络的话，相当于就没有办法确认交易的有效性，这里产生的交易仅仅起到一个记录的作用。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110162135282" alt="交易链示意图"></p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110162150429.png" alt="双重支出问题"></p><ul><li>进一步，那么比特币是怎么解决这个问题的呢？</li></ul><p>比特币建立起了一个用工作量证明机制的P2P网络，网络上的节点都可以进行记账（也就是记录交易信息），记账的方式是基于区块链技术，区块上记录着一段时间内的交易信息，然后按时序用链串联起来，就有了所有的交易信息；同时最长的区块链是被网络上的节点所共同认可是正确的，即相当于第三方监管的确认作用，证明某次交易有效。</p><p>用上面的例子继续说明A的余额只有一个，然后他又同时和B、C进行交易，这两条交易信息传播到网络上，各个节点进行记录。有节点先收到A给B一个比特币的消息，他们检查余额之后会自动忽略另外一条交易消息（这个检查应该是基于他们当前的链？）；同样，会有先收到A给C一个比特币消息的节点，在检查余额之后也会自动忽略另外一条消息。接下来算力最高的（CPU最多的）节点获得记账权，把他记录的区块加到主链上，然后网络上其他节点都会以主链上的交易信息为准。如果放入主链的交易信息是A转给B一个比特币，那么B将会获得比特币，交易的有效性得到确认；同理，如果放入主链的交易信息是A转给C一个比特币，那么C将会获得比特币。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110162150837.png" alt="区块链解决双重支出问题"></p><ul><li><p><strong>问题2</strong>：不过这样又引出一个问题，这个主链是怎么确定下来，或者说找到的呢？是假设大部分节点都是有着相同的最长主链，然后直接在本地的区块链上加上最新的，然后把新产生的区块信息广播出去？然后再根据最长主链正确性的假设前提，其他节点根据该最长主链更新本地的区块链</p></li><li><p><strong>问题3</strong>：在上面的例子里，还有一个问题，怎么去检验一个交易里付款者的余额？或者说怎么找到该付款者之前的所有交易记录？用公私钥的话好像不太行，因为每次都可能变换。还是说这个账户是可以直接找到的，那隐私性是怎么保护？</p></li><li><p><strong>问题4：</strong>文中的网络部分提到了容错性，即有的网络节点可能会丢失之前的区块信息，那么这些节点该怎么找到当前的最长主链？</p><ul><li>我理解每次传播的区块都是最新的区块，节点会因此意识到自己丢失了区块信息（这个怎么意识到也是个问题，用最新区块里的的prev hash来验证？），那么怎么来获取丢失的区块信息呢？是从最新区块广播节点那拉取区块吗？</li></ul></li><li><p><strong>问题5</strong>：Merkel Tree剪枝压缩的具体实现</p></li><li><p><strong>问题6</strong>：论文通篇介绍了比特币的实现原理，那么比特币有什么问题，缺点呢？</p></li><li><p><strong>问题7</strong>：在存储部分提到，因为Merkel Tree的技术，存储并不是问题，那么有没有可能用优势来弥补劣势，像是空间换时间？</p></li></ul><h1 id="所思所感"><a href="#所思所感" class="headerlink" title="所思所感"></a>所思所感</h1><ul><li>比特币本身没有价值，但是却有着无比昂贵的价格，甚至有大量的电力、算力耗费在这上面，进行所谓的“挖矿”，从中获得真实的金钱财富，这对我来说有些不可思议，难以理解。我自身也说不太清楚，可能这是个哲学问题？一个从计算机里产生的电子货币，对现实世界没有实质性的价值或者说实用性，为什么却能被人们追捧，赋予了天价？把那些花费在找随机数、挖矿的电力和算力用在更需要的地方，会不会能创造有实际价值的事物？</li><li>通过阅读本篇论文，了解比特币大致的工作流程，实现原理，也认识到比特币最大的特点就是去中心化，没有了第三方机构，改变以往“基于信任”的交易模式，或许正是这种去中心化的、隐蔽的并且可靠的交易方式满足了一定人群的需求（可能并不正当），逃离政府监管，以我们的国情来说，这是不可接受的，对大部分人或许也不好理解。但是区块链这种技术，这种去中心化的网络不一定要落地在电子货币里，应该会有更广阔的应用场景，也需要我自己再学习了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题02】Developer Guide导读</title>
    <link href="/2021/10/11/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9802-Developer%20Guide/"/>
    <url>/2021/10/11/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9802-Developer%20Guide/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文阅读地址：<a href="https://developer.bitcoin.org/devguide/transactions.html">Bitcoin Developer Guide</a> </p><p>预计通读耗时：12小时（个人数据，仅供参考）</p><p>中文翻译：</p><p><a href="https://www.8btc.com/books/834/bitcoin-developer-guide/_book/5/5.html">比特币开发者指南-巴比特图书</a>  </p><p><a href="https://www.bookstack.cn/read/bitcoin_developer_guide/README.md">简介 - 《比特币开发者指南 | Bitcoin Developer Guide》 - 书栈网 · BookStack</a></p></blockquote><h1 id="章节概述"><a href="#章节概述" class="headerlink" title="章节概述"></a>章节概述</h1><p>此次阅读的内容是比特币Developer Guide，详细介绍了比特币中各种设计和技术细节。</p><ul><li>Block Chain：介绍比特币的结构基础区块链，包括工作量证明，块高与分叉，交易数据，共识规则改变引起分叉等内容。</li><li>Transaction：详细介绍了比特币中交易的相关内容，重点说明了交易的组成，交易中的UTXO的类型（使用何种支付方式P2PKH或者P2SH）。</li><li>Contracts：这里的合约跟以太坊的智能合约不太一样，感觉更像是来说明交易双方（针对人而不是交易）该如何进行交易，应该遵守哪些规则。主要介绍了托管和仲裁、微支付通道、Coinjoin（混币）</li><li>Wallet：钱包用来管理和花费UTXO，因为UTXO实际对应的是一个hash地址，因此钱包实际就是在管理公私钥，这部分内容也就更多在介绍公私钥的管理问题。</li><li>Payment Processing：这部分重点介绍如何使用比特币进行支付的相关问题。</li><li>Operating Modes：介绍比特币中全节点和SPV客户端。</li><li>P2P Network：这部分就是详细介绍了比特币运行在P2P网络中相关细节，包括对等节点的发现与链接，全节点的初始化，区块传播等。</li><li>Mining：介绍了单独挖矿和矿池挖矿两种挖矿（添加新的区块）方式。</li></ul><h1 id="重点内容"><a href="#重点内容" class="headerlink" title="重点内容"></a>重点内容</h1><blockquote><p>大部分是阅读各个模块时记录下的重点内容。</p></blockquote><h2 id="Block-Chain-区块链"><a href="#Block-Chain-区块链" class="headerlink" title="Block Chain 区块链"></a>Block Chain 区块链</h2><ul><li>Block chain里UTXO的作用，只能使用一次，这也解决了双花问题</li><li>Proof of work里也是充分利用了加密hash算法里随机的天然特性，hash number不可预知<ul><li>每2016块调整难度值，根据生成这2016块block的时间来调整，理想时间是1,209,600秒(two weeks).</li></ul></li><li>Transaction data：block里的第一个交易是一个coinbase交易（由生成的区块奖励和输入输出费用差组成），通常只有在100块之后，才能被花费使用，这么做的目的是因为分叉比较常见，防止因为分叉的原因导致原先的区块失效<ul><li>有个问题是，如何保证必须要在100块之后才能进行花费，是在创建block的时候，判断输入的UTXO所在的区块的深度超过100吗？</li></ul></li><li>共识规则改变：共识规则改变，会有两种不同的情形，分别导致硬分叉和软分叉，不是很能理解其中的含义，查阅相关资料有了进一步认识。（现在比特币的更新，基本就是软分叉）</li></ul><blockquote><p><strong>常见的理解是“硬分叉和老版本软件不兼容、软分叉和老版本兼容”</strong>，这个定义是<strong>不准确</strong>的，但是很多地方已经在用了。。<br><strong>硬分叉的定义是扩宽共识规则</strong>，允许做之前禁止的事情，以前无效的交易/区块在硬分叉后会变成有效的；<strong>软分叉是收紧共识规则</strong>，禁止之前允许做的事情，以前有效的交易在软分叉后就无效了。<br><strong>软/硬分叉是共识规则的改变，和链分叉/链重组完全是两码事；这两对概念的关系类似于“红烧/清蒸”与“烧糊/夹生”。</strong>不当部署的软/硬分叉都有可能导致链分叉/链重组。<br>所以，可以想见：<br>硬分叉之后，几乎一定会产生让老节点拒绝接受的区块，所以，硬分叉会破坏前向兼容性；<br>软分叉之后，产生的新区块肯定是老节点也愿意接受的，前向兼容性得以保留。</p></blockquote><ul><li>Detecting forks 发现分叉：通过监控区块链工作量证明而发现硬分叉的代码；监控最近区块的版本号</li></ul><h2 id="Transaction交易"><a href="#Transaction交易" class="headerlink" title="Transaction交易"></a>Transaction交易</h2><ul><li><strong>P2PKH</strong> 即 pay to public key hash，向公钥哈希地址支付<ul><li>交易的输入使用一个TXID和output index number（对于output来说处在交易的哪个位置）来标识，然后还有一个签名脚本，验证该input对应的output包含的公钥脚本，用来证明这笔输入的钱的确是本人持有</li><li>交易的输出包含一个隐含的index number，以聪为单位的余额量，一个公钥脚本</li><li>Bob要使用Alice的支付给他的UTXO，Alice创建转账的Tx交易时需要用到Bob的公钥，因此Bob的公私钥是提前生成好的，使用ECDSA椭圆签名曲线生成；然后Bob将公钥hash，使用Base58编码地址版本编号、公钥哈希、错误校验码，然后传给Alice，Alice可以进行解码得到公钥hash，并添加到交易中，作为output中的pubkey script，来标识输出到哪个地址；</li><li>而当Bob需要使用这份UTXO，发布交易时，需要构造input，引用Alice创造的交易TX（即TXID和对应的output index number），还需要包含一个签名脚本(signature script），这个签名脚本用来验证这笔输入的确是Bob所有。这个签名脚本里包含了Bob的公钥和签名，而签名的数据包含了Alice创造的交易TXID和index number，输出给其他用户的pubkey script，输出的余额。而输出output，正如上述所说，包含一个隐含的index number，以聪为单位的余额量，一个公钥脚本。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350637.(null)"></p><ul><li><p><strong>P2SH</strong>：提出P2SH的目的主要是因为在之前的交易中，都是由发送者负责指定赎出币的条件。这样的话，如果赎出币的过程比较复杂，譬如要使用MULTISIG，那么对付钱的用户，也就是买家，就不够友好。使用P2SH的方式，可以由币的接收方设计好执行的脚本，然后不论脚本多么复杂，发送方只需要将币发送到一个20字节的哈希地址就行。</p><ul><li>有关资料参考：<a href="https://zhuanlan.zhihu.com/p/46072343">P2SH机制</a></li></ul></li><li><p>标准的公钥脚本类型：P2PKH、P2SH、Multisig、Pubkey、Null Data</p></li><li><p>交易中Locktime和Sequence numbers的说明</p><ul><li>Locktime, 也被称为nLockTime, 它定义了个最早时间，只有过了这个最早时间，这个transaction可以被发送到比特币网络。通常被设置为0，表示transaction一创建好就马上发送到比特币网络</li><li>Sequence numbers用来使签名者更新交易，如果sequence numbers设置成0xffffffff时，表明更新完成，就可以立即生效加入到比特币区块中，这个生效是不管Locktime是否过期。</li><li>另一种理解：<ul><li>LockTime ：绝对时间，用的是整个区块链的长度，或者时间戳来表达的。</li></ul></li></ul></li><li><p>Sequence Number : 相对时间，当前交易所引用的UTXO所在的块（也就是输入所在的块），后面追加了多少个块。</p></li><li><p>参考：<a href="https://zhuanlan.zhihu.com/p/43171481">深入浅出微支付通道</a></p></li></ul><h2 id="contract合约"><a href="#contract合约" class="headerlink" title="contract合约"></a>contract合约</h2><ul><li>结合之前的P2SH方式中，对multisig有了更进一步的理解。A向B买东西，A使用P2SH，把钱支付到一个脚本地址并使用2-of-3签名（此时比特币只属于这个脚本地址），当B发货了，A收到确认没问题了，那么使用A和B的签名就可以把脚本地址的UTXO转给B的地址。如何A反悔了，不肯提供签名，那么B可以找仲裁机构C，使用B和C的签名也能将脚本地址的UTXO转给B；同理B如果没有发货，A也能找C把钱转回给A。也就是说，相比P2PKH直接转账方式，P2SH相当于多了一步验证等待，验证成功了再转账到用户地址。</li><li>Micropayment Channel 微支付通道</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350785.(null)"></p><ul><li><p>其工作原理大体上可以这样描述：A给B打工，B首先使用A和B的签名，使用P2SH的方式，发送一定金额到脚本地址，并将该交易立即传播到比特币网络上；然后B创造第二个交易，并用到刚刚A的签名，其输入是第一个交易的脚本地址，输出是B的地址（相当于全额返回给B），然后给这个交易加上Locktime，比如说一天后才能广播这个交易。然后A给B工作一部分内容后，A要求B先支付这份工作量的薪水，那么B就创建一份新的交易，从原来全额给B变成分出一部分金额给A，这个新的交易拷贝给A，这样A就可以广播这个新的交易从而获得薪水。（实际上A只需要在locktime过期前，广播最后版本的交易即可）</p></li><li><p>为什么采用这样的方式呢，因为A诉求是及时支付薪水，但是因为量小，B不能每次都立即创造一个交易即刻支付，这样的交易费的成本太高了。所以利用这样的方式，既确保了A的薪水是及时得到确认的，又可以使得只需一个交易就一次性支付薪水</p></li><li><p>实际上，更改交易金额的输出，这个权利是在B的，因为B有A的签名但A没有B的签名，A拿的是经过B签名后的交易副本（这个交易被B签名过了，所以是有效的）。所以A能实时确保自己对应工作量的薪水能及时支付，就算中途B跑路了，也只是损失一小部分工作量的薪水，之前的薪水都可以得到支付。而对B来说，如果A没有工作，那B也能在locktime 过期后拿回自己的钱（不过这样就需要等待一个locktime的时间）</p></li><li><p>Coinjoin混币交易，增加隐匿性，保护隐私，当和其他输入输出混杂在一起时，别人就难以追踪输出记录了</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350075.(null)"></p><h2 id="Wallet钱包"><a href="#Wallet钱包" class="headerlink" title="Wallet钱包"></a>Wallet钱包</h2><ul><li>钱包程序主要可分为三个子程序，一个程序来发布公钥用于接收比特币，而另一个程序对交易做签名来花费比特币，还有一个网络程序用来跟P2P网络交互。更具体地说，一个完整的钱包程序应包括这些功能：生成私钥，生成对应的公钥，按照需要对公钥进行发布，监听以这些公钥作为输出的交易，创建交易并对其进行签名，广播已签名的交易。</li><li>Wallet file 是对私钥进行管理；描述了私钥和公钥的格式</li><li>参考：<a href="https://blog.csdn.net/omnispace/article/details/79816141">数字货币钱包 - 助记词 及 HD 钱包密钥原理_omnispace的博客-CSDN博客</a></li></ul><h2 id="Payment-Processing-支付处理"><a href="#Payment-Processing-支付处理" class="headerlink" title="Payment Processing 支付处理"></a>Payment Processing 支付处理</h2><ul><li>介绍四种支付比特币的方式和相关的具体细节，包括明文，bitcoin:URI，QR码，新的支付协议X.509</li><li>其中提到一种“Merge Avoidance合并规避”的方法来保护用户隐私，该方法大体的意思就是让减少各个账户连接在一起的次数（或者说减少输入的个数）。因为当你使用UTXO作为输入进行花费时，UTXO原先的owner就可以追溯这次交易的信息，输入的UTXO越多那么能追溯到这笔交易的人就越多，隐私就会受到影响。用官方的例子来说，你有100，200，500，900的UTXO，然后你现在需要支付300BTC，那么你该选用500的UTXO来进行支付（而不是选择100，200作为输入，体现了合并，规避风险）。</li></ul><h2 id="Operating-Modes运行模式"><a href="#Operating-Modes运行模式" class="headerlink" title="Operating Modes运行模式"></a>Operating Modes运行模式</h2><ul><li>比特币主要有两种运行模式：一个是全节点客户端（包含所有区块和交易信息），一个是SPV客户端（只保存区块头信息）。SPV客户端可以通过请求全节点拿到相应的区块信息，进行验证。然而SPV客户端有两个缺点，一个是可能会被全节点欺骗，解决办法是连接多个全节点，保证不要和诚实节点断开链接了；另一个是容易受到拒绝服务攻击，解决办法是布隆过滤器</li><li>参考：<a href="https://shuwoom.com/?p=857">布隆过滤器(Bloom Filter)、SPV和比特币 - shuwoom的博客</a></li></ul><h2 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h2><ul><li>因为共识规则不包括网络，所以有可选的网络和协议。这里用Bitcoin Core作为全节点代表，BitcoinJ作为SPV客户端代表。</li></ul><h3 id="Peer-Discovery"><a href="#Peer-Discovery" class="headerlink" title="Peer Discovery"></a>Peer Discovery</h3><ul><li>首先通过询问DNS seeds来获取对等网络其他有效运行的节点IP，和对等节点建立连接后，可以获取得到更多的网络节点IP。此外，在程序中会有一些固定的静态IP可以尝试连接，或者使用命令行工具尝试与指定IP连接。</li></ul><h3 id="Connecting-to-Peers"><a href="#Connecting-to-Peers" class="headerlink" title="Connecting to Peers"></a>Connecting to Peers</h3><ul><li>节点通过发送version消息连接到一个对等节点。消息version 包含了节点的版本信息、块信息和距离远程节点的时间。一旦这个消息被对等节点收到，它必须回复一个verack。如果它愿意建立对等关系，它将发送自己的version消息。</li><li>一旦建立对等关系，节点可以向远程节点发送getaddr和addr消息来获得其它的对等节点信息。为了维持与对等节点的连接，节点默认情况下每30分钟内会给对等节点至少发送一次信息。如果超过90分钟没有收到回复，节点会认为连接已经断开</li></ul><h3 id="Initial-Block-Download"><a href="#Initial-Block-Download" class="headerlink" title="Initial Block Download"></a>Initial Block Download</h3><ul><li>一个全节点在正式工作或者提供服务前，需要进行初始化，把除了硬编码生成的第一个区块外的所有区块下载下来，这个过程就是IBD。</li><li>Block-First 是其中一种下载方式，向一个对等网络节点进行询问，直接下载区块，其缺点也很明显<ul><li>下载速度的限制：只从一个同步节点下载，受限该节点的带宽</li><li>重新下载：同步节点可能会发送不是最长链上的区块，就会导致快结束时才发现需要重新下载</li><li>磁盘空间占用：和“重新下载”相关，下载时可能会将无用的区块保存到磁盘，占用空间</li><li>大量内存使用：因为同步节点发送过来的区块可能是无序的，所以需要先保存到内存中，直到接收到父块才能进行验证</li></ul></li><li>Header-First 的下载方式，解决了Block-First中四个缺陷，它的工作方式是：先向同步节点下载block headers，当部分地验证headers有效性后，IBD节点就可以并行地做两天事——一个是继续向同步节点发送请求下载headers，另一个是向其他对等节点发送请求下载block</li></ul><h2 id="Mining-挖矿"><a href="#Mining-挖矿" class="headerlink" title="Mining 挖矿"></a>Mining 挖矿</h2><ul><li>现在有两种挖矿方式：单独挖矿和矿池挖矿<ul><li>单独挖矿：bitcoind来获取P2P网络上的交易，挖矿软件通过RPC方法来获取列表，并构造一个Block模板，然后将对应的block header发送给ASIC进行运算。挖矿软件会将一个nonce值填入币基交易的的字段中，获得新的Merkle root的hash值，然后将新的Block header发送个ASIC。如果ASIC计算生成的block header hash小于预定的阈值，则表明添加的nonce值符合条件，将block header返回给挖矿软件，挖矿软件根据返回的block header更新block，最后将完整的block 返回给bitcoind，bitcoind再向网络传播区块</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350617.(null)"></p><ul><li>矿池挖矿：工作流跟单独挖矿类似。不同的是，矿池设定的阈值要比网络上设定的阈值小很多（降低了难度），因此各个矿工通过挖矿软件返回给矿池的block hearder中，有很多是满足矿池的阈值但不满足网络的阈值，这些返回的block header相当于是份额，证明了矿工的工作量；同时总会有几率产生同时满足两个阈值的block header，矿池将满足网络阈值条件的block发送给bitcoind，从而获得奖励。然后矿池根据矿工贡献的份额，平均分发奖励。举个具体例子就是，矿工们总共返回了100个满足矿池条件的block header（相当于有100份额），只有1个满足网络阈值，那么每份额的奖励就是总奖励的1/100，矿工根据自己的份额获得相应奖励。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350905.(null)"></p><ul><li>还介绍了三种挖矿软件获取Block的RPC<ul><li>getwork RPC：当前Bitcoin Core已经废弃，这个方法直接为矿工构造好block header，因此矿工可能需要调用成百上千次RPC</li><li>getblocktemplate RPC：获取以下内容；然后挖矿软件就能自己改变nonce值，自己生成block header<ul><li>构造币基交易的信息</li><li>bitcoind发送给矿池的交易列表和具体交易信息，这使得挖矿软件可以查看交易，并有选择性地添加或删除交易</li><li>构造block header的其他信息</li><li>矿池提供的难度值或者网络设定的难度值</li></ul></li><li>Stratum：跟getblocktemplate很类似，但是不同的是，挖矿软件获取到的是重新构造Merkle树的必要信息，而不是具体的交易列表和交易内容。因此，挖矿软件不能添加或者删除交易，不过此时挖矿软件和矿池建立双向的TCP连接；在getblocktemplate 里，挖矿软件用的是HTTP longpoll长轮询，来获取最近的更新。</li></ul></li></ul><h1 id="存在疑问"><a href="#存在疑问" class="headerlink" title="存在疑问"></a>存在疑问</h1><p>阅读完所有内容后，还是有很多问题和细节没有弄明白。</p><ol><li>原文：Since it is impractical to have separate transactions with identical txids, this does not impose a burden on honest software, but must be checked if the invalid status of a block is to be cached; otherwise, a valid block with the duplicates eliminated could have the same merkle root and block hash, but be rejected by the cached invalid outcome, resulting in security bugs such as <a href="https://en.bitcoin.it/wiki/CVEs#CVE-2012-2459">CVE-2012-2459</a>.</li></ol><blockquote><p>对于上述内容不是很能理解，不同的transactions怎么会有相同的TXID，可能是由于hash冲突导致的？虽然概率很小。然后“对于缓存一个无效区块的状态”，这该如何理解？什么时候用到了缓存，缓存什么内容（区块的状态？），以及如何判断区块是有效还是无效？如果因为有TXID冲突判定区块无效的话，可以去重TXID，达到有效？</p></blockquote><ol><li>标准交易中，Null Data的的pubkey scripts类型用来干什么的？</li><li>P2PK 被 P2PKH所取代了，支付到公钥哈希的地址，可以使得公钥直到UTXO被使用时才会发布，延迟公钥发布的原因是什么呢？是为了避免攻击者利用公钥进行某些攻击吗？</li><li>多种Signature hash types的用途是什么呢？为什么要有选择性的进行签名？</li><li>交易被打包到区块，交易的费用是根据交易的签名字节长度计算出来，那么这笔费是由买家（支付者）来付吗？在对应的一个交易中，是会增加一个output来指向矿工吗？</li><li>对于HD钱包，即分层确定性钱包中的工作原理还是不太理解，特别是extened keys到harderned keys的转变，为什么要这么做？这么做如何解决问题的？</li><li>SPV客户端具体是怎么使用布隆过滤器的？</li><li>矿工发布区块时，具体是怎么给矿工发放奖励的？是在创建区块的时候，直接生成一个币基交易（把钱转账给该矿工），然后矿工打包所有交易后，开始找满足条件的nonce，找到后广播区块，这样如果区块得到其他节点认可上链了，那么矿工就切实得到了收益。（这样的话，每个节点在生成区块）</li></ol><h1 id="所思所感"><a href="#所思所感" class="headerlink" title="所思所感"></a>所思所感</h1><p>阅读完这篇Guide概览，让我认识了解比特币中许多技术和实现细节，但是通读完一遍后，发现自己好像懂了，又好像没懂，或者说从整体上对比特币的整体架构有了一定的认识，具体有哪些部分组成，涉及哪些关键技术，但是对个各个模块进一步的细节还是似懂非懂，并且还是难以串联起来，各个部分有明显的联系（比如交易与钱包与支付处理），但是感觉自己还是很难将这三者的关系表示清楚，或者说，当把整个比特币看做一个整体时，各个部分是怎么样有机独立又相互配合的。</p><p>还有一个简单的思考，就是对于合约部分中多重签名的使用，例如托管和仲裁，A和B之间的交易还是要依赖于仲裁第三方C，这是否与比特币去中心化的思想相矛盾了呢？后来进一步思考和查阅资料，从另一个视角去看，去中心化，不是不要中心，而是由节点来自由选择中心、自由决定中心。简单地说，中心化的意思，是中心决定节点。节点必须依赖中心，节点离开了中心就无法生存（类似于没了支付宝就不能用淘宝？）。而在去中心化系统中，任何人都是一个节点，任何人也都可以成为一个中心。任何中心都不是永久的，而是阶段性的，任何中心对节点都不具有强制性。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【99%环境搭建系列】云计算管理平台Devstack安装</title>
    <link href="/2021/10/08/2021-10-08%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97%20-devstack%E5%AE%89%E8%A3%85/"/>
    <url>/2021/10/08/2021-10-08%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97%20-devstack%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p class='note note-success'>99%概率完成环境搭建，让天下没有搭建不了的环境！ </p><p>openstack作为开源的云计算管理平台，可以让我们体验云计算技术的各种组件和功能，然而官网繁琐的配置教程令人望而却步。好在devstack提供了一站式安装服务，<del>只需简单执行几个命令即可完成安装</del>（根本不是这样好吗！）。不过经过我的百般测试，只要安装教程里的方式执行命令，成功概率99%！</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082112035.png"></p><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>这里说一下我个人的安装环境</p><ul><li>PC操作系统：win10</li><li>VMware Workstation版本：16.x Pro</li><li>Ubuntu版本：18.04 </li></ul><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><ol start="0"><li><strong>简要说明</strong></li></ol><p class='note note-primary'>ubuntu操作系统在虚拟机的安装这里不再演示，假设你已经完成了ubuntu18.04的安装，然后继续；<br>在~/ 目录下，依次执行命令即可，没有特殊说明，不用执行别的多余命令</p><ol><li><strong>设置静态IP（可选）</strong></li></ol><blockquote><p>说明：这一步是可选的，之所以设置成静态IP，是为了方便后面的配置，以及排除IP变动的原因导致的种种意外；不过不进行配置的话，应该也是ok的，只要保证整个安装以及使用过程IP不会改变</p><p>参考网站：<a href="https://www.cnblogs.com/yaohong/p/11593989.html">ubuntu配置静态ip</a>       <a href="https://blog.csdn.net/zh2508/article/details/85250360">VMware配置静态ip</a></p></blockquote><p>首先给机器设置静态ip，修改<code>/etc/netplan</code>目录下对应的文件，按如下文件进行配置。</p><p class='note note-info'>  三个注意点：<br>  1. 注意配置里的"ens32" 根据自己的机器进行改动，可能是"ens33"，可以通过命令 ip addr 来进行查看 <br>  2. 这里复制的话，注意复制后的结果是否一致，可能需要自己手动输入一下，这样的话要严格注意格式，冒号后面需要一个空格，换行缩进是4个空格<br>  3. 设置的ip和网关要在同一个网段上，记住这里填入的ip，需要用在下面的配置中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br><span class="hljs-attr">network:</span><br><span class="hljs-string">​</span>    <span class="hljs-attr">ethernets:</span><br><span class="hljs-string">​</span>        <span class="hljs-attr">ens32:</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]<br><span class="hljs-string">​</span>            <span class="hljs-attr">optional:</span> <span class="hljs-literal">true</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.2</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">nameservers:</span><br><span class="hljs-string">​</span>                    <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.1</span>,<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.2</span>] <span class="hljs-comment"># 这里DNS的修改，是因为我配置了上面VMware配置静态ip</span><br></code></pre></td></tr></table></figure><p>然后执行<code>sudo netplan apply</code>，让配置生效，再通过<code>ip addr</code>查看是否生效，已经<code>ping</code>命令查看网络是否连通</p><ol start="2"><li><strong>切换apt源</strong></li></ol><p>切换apt源的目的是为了加快下载安装的速度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install vim #先安装下vim<br>sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak<br>sudo vim /etc/apt/sources.list # 如果vim还没有安装，改用 vi 复制下就行<br></code></pre></td></tr></table></figure><p>这里配置用的是阿里云的镜像，如果之后因为网络的问题可以尝试换下别的源，不过我测试使用的都是阿里云</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 注意ubuntu版本号对应不同的代号，这里用的是18.04，对应bionic</span><br>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>更换pip源</strong></li></ol><p>也是为了加快下载安装依赖的速度</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir .pip<br>vim .pip/pip.conf<br></code></pre></td></tr></table></figure><p>配置如下所示，用的是豆瓣的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[global]<br>index-url = http://pypi.douban.com/simple/<br>trusted-host = pypi.douban.com<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>更新并安装包</strong></li></ol><p>依次执行下列命令，主要是更新安装相关依赖，下载pip管理依赖工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get upgrade<br>sudo apt-get install git<br>sudo apt-get install python-pip<br>sudo pip install --upgrade pip<br>sudo pip install -U os-testr  # sudo pip install wcwidth 可选，如果这一步出了wcwidth相关的error的话<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>设置时区同步</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install ntpdate // 安装时间同步工具<br>sudo ntpdate cn.pool.ntp.org // 与网络服务器同步时间<br>date // 查看时间是否已经同步<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>下载devstack</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/openstack/devstack.git -b stable/queens</span> <br><span class="hljs-meta">#</span><span class="bash"> 推荐使用opendev.org官网的wallby这个分支，github上对应的queens这个分支尝试过有问题解决不了</span><br>git clone https://opendev.org/openstack/devstack.git -b stable/wallaby <br></code></pre></td></tr></table></figure><ol start="7"><li><strong>创建stack用户</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo devstack/tools/create-stack-user.sh<br></code></pre></td></tr></table></figure><ol start="8"><li><strong>移动并设置文件夹权限</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mv devstack /opt/stack<br>sudo chown -R stack:stack /opt/stack<br>sudo chown stack:stack /opt/stack<br></code></pre></td></tr></table></figure><ol start="9"><li><strong>切换到stack用户</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo su - stack<br></code></pre></td></tr></table></figure><ol start="10"><li><strong>创建local.conf配置文件</strong></li></ol><p>执行下列命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd devstack<br>vim local.conf<br></code></pre></td></tr></table></figure><p>配置文件内容如下，<strong>注意修改HOST_IP</strong>，改成自己当前的IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[[local|localrc]]<br><span class="hljs-meta">#</span><span class="bash"> Define images to be automatically downloaded during the DevStack built process.</span><br>DOWNLOAD_DEFAULT_IMAGES=False<br>IMAGE_URLS=&quot;http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> use TryStack git mirror</span><br>GIT_BASE=http://git.trystack.cn<br>NOVNC_REPO=http://git.trystack.cn/kanaka/noVNC.git<br>SPICE_REPO=http://git.trystack.cn/git/spice/sice-html5.git<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> Credentials</span><br>[[local|localrc]]<br>ADMIN_PASSWORD=admin<br>DATABASE_PASSWORD=$ADMIN_PASSWORD<br>RABBIT_PASSWORD=$ADMIN_PASSWORD<br>SERVICE_PASSWORD=$ADMIN_PASSWORD<br><span class="hljs-meta">#</span><span class="bash"> Host IP - get your Server/VM IP address from ip addr <span class="hljs-built_in">command</span></span><br>HOST_IP=192.168.10.112 # ifconfig获取本机ip<br>enable_service placement-api<br>enable_service placement-client<br></code></pre></td></tr></table></figure><ol start="11"><li><strong>提前下载依赖包</strong> </li></ol><p>因为是从github上连接下载依赖包，可能由于网络不好的问题，直接安装的话可能中途会因为下载失败导致安装失败，所以这里提前下载；如果下载失败了，就多执行几次，肯定是可以的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd files/<br>wget -c https://github.com/coreos/etcd/releases/download/v3.1.10/etcd-v3.1.10-linux-amd64.tar.gz<br>wget -c https://github.com/coreos/etcd/releases/download/v3.1.7/etcd-v3.1.7-linux-amd64.tar.gz<br>wget -c https://github.com/etcd-io/etcd/releases/download/v3.3.12/etcd-v3.3.12-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><ol start="12"><li><strong>安装simplejson</strong></li></ol><p>经过测试，之后安装的过程中可能会报错simplejson安装失败，所以这里提前进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> sudo apt-get purge python3-simplejson 清楚之前的软件包和配置</span><br>sudo apt-get install python3-simplejson<br><span class="hljs-meta">#</span><span class="bash"> sudo apt-get install python-simplejson <span class="hljs-comment"># 上面的命令不行可以试下这个</span></span><br></code></pre></td></tr></table></figure><ol start="13"><li><strong>修改pip安装配置</strong></li></ol><p class='note note-info'>  在测试中，pip相关安装可能会报错，这里提前修改下</p><p>修改对应的目录文件 <code>devstack/inc/python file 198 line</code></p><p> 源代码 <code>$cmd_pip $upgrade</code> </p><p> 修改成 <code>$cmd_pip $upgrade --ignore-installed</code></p><ol start="14"><li><strong>修改权限</strong></li></ol><p>经过测试，之后安装的过程可能会出现如下权限错误的错误，所以这里再次修改权限</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082049771.png" alt="pip下载报错"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chown -R stack:stack /opt/stack<br>sudo chown stack:stack /opt/stack<br>sudo chown -R stack:stack /opt/stack/devstack<br><span class="hljs-meta">#</span><span class="bash"> sudo chmod -R 777 /opt/stack  <span class="hljs-comment"># 先用前三个命令应该足够了，不行再试试这个</span></span><br></code></pre></td></tr></table></figure><ol start="15"><li><strong>开始安装</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>FORCE=yes ./stack.sh<br></code></pre></td></tr></table></figure><p>可能因为网络的原因，中途会连接不上github，导致安装失败，这样就需要重新尝试，先清理下环境再安装，多尝试几次应该都会成功的，不过确保网络质量也比较重要。</p><p>如果是因为下载github上某个依赖包导致的失败，可以事先安装好对应的依赖，使用pip命令下载即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">./unstack.sh<br>./clean.sh<br>FORCE=yes ./stack.sh<br></code></pre></td></tr></table></figure><ol start="16"><li><strong>见证奇迹的时刻</strong></li></ol><p>当你看到如下信息的时候，恭喜你，完成安装~</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110081954141.(null)" alt="成功截图"></p><ol start="17"><li><strong>openstack界面展示</strong></li></ol><p>具体如何使用openstack，这里就不再详细演示，openstack功能大家就自行地快乐玩耍吧~</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110081954271.(null)" alt="openstack界面展示"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到此为止，devstack的安装教程就到此结束了，如果安装上面的步骤成功了，恭喜你我的朋友！</p><div align='center'><img src='https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082121023.jpeg' width='30%' height='30%' > </div><p>当然如果出现了别的问题无法解决的话，可以评论留下你的问题，或者与我联系。</p><hr><p>如果真的山穷水尽了的话，microstack 官网教程值得你的拥有~</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082124003.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/hunjiancuo5340/article/details/85005995">https://blog.csdn.net/hunjiancuo5340/article/details/85005995</a></p><p><a href="https://blog.csdn.net/u013184378/article/details/84973629">https://blog.csdn.net/u013184378/article/details/84973629</a></p><p><a href="http://www.cnblogs.com/lianshuiwuyi/p/10955041.html">http://www.cnblogs.com/lianshuiwuyi/p/10955041.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>环境搭建系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devstack</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动漫名台词收录</title>
    <link href="/2021/09/30/2021-09-30%20%E5%8A%A8%E6%BC%AB%E5%90%8D%E5%8F%B0%E8%AF%8D%E6%94%B6%E5%BD%95/"/>
    <url>/2021/09/30/2021-09-30%20%E5%8A%A8%E6%BC%AB%E5%90%8D%E5%8F%B0%E8%AF%8D%E6%94%B6%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏王"><a href="#游戏王" class="headerlink" title="游戏王"></a>游戏王</h1><h2 id="凯撒亮"><a href="#凯撒亮" class="headerlink" title="凯撒亮"></a>凯撒亮</h2><p>因为之前也入坑过游戏王决斗链接国际服，也就组过月光、不知火、电子龙三套牌组，电子龙是我退坑前最后组的卡组，因此也有着特殊的感情。不久前听闻电子龙被彻底削废了，直接入土为安，心情也是五味杂陈，还能继续挣扎吗？</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202109301523396.jpg" alt="img"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202109301531454.jpg" alt="img"></div></div></div><p><a href="https://www.bilibili.com/video/BV12b4y1C7wC">【日语每日一句】凯撒亮经典台词教学</a></p><p>Ko re ga, i ki no ku ru ta me no, o re no a ga ki da !</p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202109301537861.png" width="50%" height="50%" align="middle" ><p>你又是如何呢，你又是为了什么而奋战至今？只要为了达到理想的终点，就算是卑微的挣扎又如何，这就是我所选择的道路！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>动漫</tag>
      
      <tag>游戏王</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Fluid主题博客搭建（小白向）</title>
    <link href="/2021/09/28/2021-09-28%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/09/28/2021-09-28%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.fluid-dev.com/posts/fluid-write/">搭配 Fluid 如何优雅的写一篇文章</a></p><p><a href="https://www.cnblogs.com/mfrank/p/12829882.html">Hexo博客部署Github Pages</a></p><p><a href="https://blog.csdn.net/i_do_not_know_you/article/details/105594269">绑定域名的遇到坑</a></p><p><a href="https://evenweiss.github.io/2021-08-02-blog-building/#%E4%B8%80%E3%80%81Github-Pages-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%85%8D%E7%BD%AE">博客搭建教程</a></p><p>绑定阿里云的top域名，解析成功的问题是：访问速度变得巨慢，并且页面效果很差，图片几乎展示不出来；和vercel部署出来的效果一致（是不是存在什么共性？）；</p><p>当删除阿里云域名解析相关记录后，访问2017zhangyuxuan.github.io 依然会跳转到注册的域名上kingofdark.top，然后报错HTTP 502</p><p><a href="https://github.com/qixa/hexo-theme-fluid-mod#%E8%AF%A6%E7%BB%86%E4%BF%AE%E6%94%B9%E4%BF%A1%E6%81%AF">进阶修改版</a></p><p><a href="https://www.julydate.com/post/60859300/#%E6%80%BB%E7%BB%93">CDN加速</a></p><p>心态崩了，弄了几天也没绑定上自己的域名，然后CDN加速也需要配置自己的域名，后来想想还是算了，毕竟博客还是内容最重要，像是页面的美观或者是网站加载速度都是其次了，下次一定。（也只能这样安慰自己了，流下了无能的泪水）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/25/hello-world/"/>
    <url>/2021/09/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="取消评论时显示浏览器内核与操作系统信息"><a href="#取消评论时显示浏览器内核与操作系统信息" class="headerlink" title="取消评论时显示浏览器内核与操作系统信息"></a>取消评论时显示浏览器内核与操作系统信息</h3><p>hexo-theme-fluid/source/css/main.styl 路径下添加 (不过好像只有本地预览有效，部署到Github pages上依然不生效；在Vercel部署的，同样也已经生效了)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.vmeta</span> &#123;<br>  <span class="hljs-attribute">display</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure><p>更好的做法是在服务端配置DISABLE_USERAGENT 环境变量为true；重新部署后得到新的server url，一定要记得把这个server url填写到_config.fluid.yml文件中，更新！！ 着了踩了个大坑！！<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="细心很重要">[2]</span></a></sup></p><h3 id="Typora图床配置"><a href="#Typora图床配置" class="headerlink" title="Typora图床配置"></a>Typora图床配置</h3><p><a href="https://zhuanlan.zhihu.com/p/365829157"><strong>Typora+PicGo+Github = Markdown编辑器+图床</strong></a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="牛啊">[1]</span></a></sup></p><p>parallel desktop上 ubuntu20.04 配置国内镜像源无法生效，百度用的改DNS的方法都不行，还是汇报Failed Fetch的错误，找不到对应的IP（这个坑以后再看看吧，或者有那个好心人帮忙看看）</p><p>难道说是还没有arm的镜像吗。。。</p><section class="footnotes"><h2>备注/参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>牛啊<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>细心很重要<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
