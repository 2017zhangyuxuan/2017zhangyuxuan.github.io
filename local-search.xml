<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【比特币专题】Developer Guide导读</title>
    <link href="/2021/10/11/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%98-Developer%20Guide/"/>
    <url>/2021/10/11/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%98-Developer%20Guide/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文阅读地址：<a href="https://developer.bitcoin.org/devguide/transactions.html">Bitcoin Developer Guide</a> </p><p>预计通读耗时：12小时（个人数据，仅供参考）</p><p>中文翻译：</p><p><a href="https://www.8btc.com/books/834/bitcoin-developer-guide/_book/5/5.html">比特币开发者指南-巴比特图书</a>  </p><p><a href="https://www.bookstack.cn/read/bitcoin_developer_guide/README.md">简介 - 《比特币开发者指南 | Bitcoin Developer Guide》 - 书栈网 · BookStack</a></p></blockquote><h1 id="章节概述"><a href="#章节概述" class="headerlink" title="章节概述"></a>章节概述</h1><p>此次阅读的内容是比特币Developer Guide，详细介绍了比特币中各种设计和技术细节。</p><ul><li>Block Chain：介绍比特币的结构基础区块链，包括工作量证明，块高与分叉，交易数据，共识规则改变引起分叉等内容。</li><li>Transaction：详细介绍了比特币中交易的相关内容，重点说明了交易的组成，交易中的UTXO的类型（使用何种支付方式P2PKH或者P2SH）。</li><li>Contracts：这里的合约跟以太坊的智能合约不太一样，感觉更像是来说明交易双方（针对人而不是交易）该如何进行交易，应该遵守哪些规则。主要介绍了托管和仲裁、微支付通道、Coinjoin（混币）</li><li>Wallet：钱包用来管理和花费UTXO，因为UTXO实际对应的是一个hash地址，因此钱包实际就是在管理公私钥，这部分内容也就更多在介绍公私钥的管理问题。</li><li>Payment Processing：这部分重点介绍如何使用比特币进行支付的相关问题。</li><li>Operating Modes：介绍比特币中全节点和SPV客户端。</li><li>P2P Network：这部分就是详细介绍了比特币运行在P2P网络中相关细节，包括对等节点的发现与链接，全节点的初始化，区块传播等。</li><li>Mining：介绍了单独挖矿和矿池挖矿两种挖矿（添加新的区块）方式。</li></ul><h1 id="重点内容"><a href="#重点内容" class="headerlink" title="重点内容"></a>重点内容</h1><blockquote><p>大部分是阅读各个模块时记录下的重点内容。</p></blockquote><h2 id="Block-Chain-区块链"><a href="#Block-Chain-区块链" class="headerlink" title="Block Chain 区块链"></a>Block Chain 区块链</h2><ul><li>Block chain里UTXO的作用，只能使用一次，这也解决了双花问题</li><li>Proof of work里也是充分利用了加密hash算法里随机的天然特性，hash number不可预知<ul><li>每2016块调整难度值，根据生成这2016块block的时间来调整，理想时间是1,209,600秒(two weeks).</li></ul></li><li>Transaction data：block里的第一个交易是一个coinbase交易（由生成的区块奖励和输入输出费用差组成），通常只有在100块之后，才能被花费使用，这么做的目的是因为分叉比较常见，防止因为分叉的原因导致原先的区块失效<ul><li>有个问题是，如何保证必须要在100块之后才能进行花费，是在创建block的时候，判断输入的UTXO所在的区块的深度超过100吗？</li></ul></li><li>共识规则改变：共识规则改变，会有两种不同的情形，分别导致硬分叉和软分叉，不是很能理解其中的含义，查阅相关资料有了进一步认识。（现在比特币的更新，基本就是软分叉）</li></ul><blockquote><p><strong>常见的理解是“硬分叉和老版本软件不兼容、软分叉和老版本兼容”</strong>，这个定义是<strong>不准确</strong>的，但是很多地方已经在用了。。<br><strong>硬分叉的定义是扩宽共识规则</strong>，允许做之前禁止的事情，以前无效的交易/区块在硬分叉后会变成有效的；<strong>软分叉是收紧共识规则</strong>，禁止之前允许做的事情，以前有效的交易在软分叉后就无效了。<br><strong>软/硬分叉是共识规则的改变，和链分叉/链重组完全是两码事；这两对概念的关系类似于“红烧/清蒸”与“烧糊/夹生”。</strong>不当部署的软/硬分叉都有可能导致链分叉/链重组。<br>所以，可以想见：<br>硬分叉之后，几乎一定会产生让老节点拒绝接受的区块，所以，硬分叉会破坏前向兼容性；<br>软分叉之后，产生的新区块肯定是老节点也愿意接受的，前向兼容性得以保留。</p></blockquote><ul><li>Detecting forks 发现分叉：通过监控区块链工作量证明而发现硬分叉的代码；监控最近区块的版本号</li></ul><h2 id="Transaction交易"><a href="#Transaction交易" class="headerlink" title="Transaction交易"></a>Transaction交易</h2><ul><li><strong>P2PKH</strong> 即 pay to public key hash，向公钥哈希地址支付<ul><li>交易的输入使用一个TXID和output index number（对于output来说处在交易的哪个位置）来标识，然后还有一个签名脚本，验证该input对应的output包含的公钥脚本，用来证明这笔输入的钱的确是本人持有</li><li>交易的输出包含一个隐含的index number，以聪为单位的余额量，一个公钥脚本</li><li>Bob要使用Alice的支付给他的UTXO，Alice创建转账的Tx交易时需要用到Bob的公钥，因此Bob的公私钥是提前生成好的，使用ECDSA椭圆签名曲线生成；然后Bob将公钥hash，使用Base58编码地址版本编号、公钥哈希、错误校验码，然后传给Alice，Alice可以进行解码得到公钥hash，并添加到交易中，作为output中的pubkey script，来标识输出到哪个地址；</li><li>而当Bob需要使用这份UTXO，发布交易时，需要构造input，引用Alice创造的交易TX（即TXID和对应的output index number），还需要包含一个签名脚本(signature script），这个签名脚本用来验证这笔输入的确是Bob所有。这个签名脚本里包含了Bob的公钥和签名，而签名的数据包含了Alice创造的交易TXID和index number，输出给其他用户的pubkey script，输出的余额。而输出output，正如上述所说，包含一个隐含的index number，以聪为单位的余额量，一个公钥脚本。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350637.(null)"></p><ul><li><p><strong>P2SH</strong>：提出P2SH的目的主要是因为在之前的交易中，都是由发送者负责指定赎出币的条件。这样的话，如果赎出币的过程比较复杂，譬如要使用MULTISIG，那么对付钱的用户，也就是买家，就不够友好。使用P2SH的方式，可以由币的接收方设计好执行的脚本，然后不论脚本多么复杂，发送方只需要将币发送到一个20字节的哈希地址就行。</p><ul><li>有关资料参考：<a href="https://zhuanlan.zhihu.com/p/46072343">P2SH机制</a></li></ul></li><li><p>标准的公钥脚本类型：P2PKH、P2SH、Multisig、Pubkey、Null Data</p></li><li><p>交易中Locktime和Sequence numbers的说明</p><ul><li>Locktime, 也被称为nLockTime, 它定义了个最早时间，只有过了这个最早时间，这个transaction可以被发送到比特币网络。通常被设置为0，表示transaction一创建好就马上发送到比特币网络</li><li>Sequence numbers用来使签名者更新交易，如果sequence numbers设置成0xffffffff时，表明更新完成，就可以立即生效加入到比特币区块中，这个生效是不管Locktime是否过期。</li><li>另一种理解：<ul><li>LockTime ：绝对时间，用的是整个区块链的长度，或者时间戳来表达的。</li></ul></li></ul></li><li><p>Sequence Number : 相对时间，当前交易所引用的UTXO所在的块（也就是输入所在的块），后面追加了多少个块。</p></li><li><p>参考：<a href="https://zhuanlan.zhihu.com/p/43171481">深入浅出微支付通道</a></p></li></ul><h2 id="contract合约"><a href="#contract合约" class="headerlink" title="contract合约"></a>contract合约</h2><ul><li>结合之前的P2SH方式中，对multisig有了更进一步的理解。A向B买东西，A使用P2SH，把钱支付到一个脚本地址并使用2-of-3签名（此时比特币只属于这个脚本地址），当B发货了，A收到确认没问题了，那么使用A和B的签名就可以把脚本地址的UTXO转给B的地址。如何A反悔了，不肯提供签名，那么B可以找仲裁机构C，使用B和C的签名也能将脚本地址的UTXO转给B；同理B如果没有发货，A也能找C把钱转回给A。也就是说，相比P2PKH直接转账方式，P2SH相当于多了一步验证等待，验证成功了再转账到用户地址。</li><li>Micropayment Channel 微支付通道</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350785.(null)"></p><ul><li><p>其工作原理大体上可以这样描述：A给B打工，B首先使用A和B的签名，使用P2SH的方式，发送一定金额到脚本地址，并将该交易立即传播到比特币网络上；然后B创造第二个交易，并用到刚刚A的签名，其输入是第一个交易的脚本地址，输出是B的地址（相当于全额返回给B），然后给这个交易加上Locktime，比如说一天后才能广播这个交易。然后A给B工作一部分内容后，A要求B先支付这份工作量的薪水，那么B就创建一份新的交易，从原来全额给B变成分出一部分金额给A，这个新的交易拷贝给A，这样A就可以广播这个新的交易从而获得薪水。（实际上A只需要在locktime过期前，广播最后版本的交易即可）</p></li><li><p>为什么采用这样的方式呢，因为A诉求是及时支付薪水，但是因为量小，B不能每次都立即创造一个交易即刻支付，这样的交易费的成本太高了。所以利用这样的方式，既确保了A的薪水是及时得到确认的，又可以使得只需一个交易就一次性支付薪水</p></li><li><p>实际上，更改交易金额的输出，这个权利是在B的，因为B有A的签名但A没有B的签名，A拿的是经过B签名后的交易副本（这个交易被B签名过了，所以是有效的）。所以A能实时确保自己对应工作量的薪水能及时支付，就算中途B跑路了，也只是损失一小部分工作量的薪水，之前的薪水都可以得到支付。而对B来说，如果A没有工作，那B也能在locktime 过期后拿回自己的钱（不过这样就需要等待一个locktime的时间）</p></li><li><p>Coinjoin混币交易，增加隐匿性，保护隐私，当和其他输入输出混杂在一起时，别人就难以追踪输出记录了</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350075.(null)"></p><h2 id="Wallet钱包"><a href="#Wallet钱包" class="headerlink" title="Wallet钱包"></a>Wallet钱包</h2><ul><li>钱包程序主要可分为三个子程序，一个程序来发布公钥用于接收比特币，而另一个程序对交易做签名来花费比特币，还有一个网络程序用来跟P2P网络交互。更具体地说，一个完整的钱包程序应包括这些功能：生成私钥，生成对应的公钥，按照需要对公钥进行发布，监听以这些公钥作为输出的交易，创建交易并对其进行签名，广播已签名的交易。</li><li>Wallet file 是对私钥进行管理；描述了私钥和公钥的格式</li><li>参考：<a href="https://blog.csdn.net/omnispace/article/details/79816141">数字货币钱包 - 助记词 及 HD 钱包密钥原理_omnispace的博客-CSDN博客</a></li></ul><h2 id="Payment-Processing-支付处理"><a href="#Payment-Processing-支付处理" class="headerlink" title="Payment Processing 支付处理"></a>Payment Processing 支付处理</h2><ul><li>介绍四种支付比特币的方式和相关的具体细节，包括明文，bitcoin:URI，QR码，新的支付协议X.509</li><li>其中提到一种“Merge Avoidance合并规避”的方法来保护用户隐私，该方法大体的意思就是让减少各个账户连接在一起的次数（或者说减少输入的个数）。因为当你使用UTXO作为输入进行花费时，UTXO原先的owner就可以追溯这次交易的信息，输入的UTXO越多那么能追溯到这笔交易的人就越多，隐私就会受到影响。用官方的例子来说，你有100，200，500，900的UTXO，然后你现在需要支付300BTC，那么你该选用500的UTXO来进行支付（而不是选择100，200作为输入，体现了合并，规避风险）。</li></ul><h2 id="Operating-Modes运行模式"><a href="#Operating-Modes运行模式" class="headerlink" title="Operating Modes运行模式"></a>Operating Modes运行模式</h2><ul><li>比特币主要有两种运行模式：一个是全节点客户端（包含所有区块和交易信息），一个是SPV客户端（只保存区块头信息）。SPV客户端可以通过请求全节点拿到相应的区块信息，进行验证。然而SPV客户端有两个缺点，一个是可能会被全节点欺骗，解决办法是连接多个全节点，保证不要和诚实节点断开链接了；另一个是容易受到拒绝服务攻击，解决办法是布隆过滤器</li><li>参考：<a href="https://shuwoom.com/?p=857">布隆过滤器(Bloom Filter)、SPV和比特币 - shuwoom的博客</a></li></ul><h2 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h2><ul><li>因为共识规则不包括网络，所以有可选的网络和协议。这里用Bitcoin Core作为全节点代表，BitcoinJ作为SPV客户端代表。</li></ul><h3 id="Peer-Discovery"><a href="#Peer-Discovery" class="headerlink" title="Peer Discovery"></a>Peer Discovery</h3><ul><li>首先通过询问DNS seeds来获取对等网络其他有效运行的节点IP，和对等节点建立连接后，可以获取得到更多的网络节点IP。此外，在程序中会有一些固定的静态IP可以尝试连接，或者使用命令行工具尝试与指定IP连接。</li></ul><h3 id="Connecting-to-Peers"><a href="#Connecting-to-Peers" class="headerlink" title="Connecting to Peers"></a>Connecting to Peers</h3><ul><li>节点通过发送version消息连接到一个对等节点。消息version 包含了节点的版本信息、块信息和距离远程节点的时间。一旦这个消息被对等节点收到，它必须回复一个verack。如果它愿意建立对等关系，它将发送自己的version消息。</li><li>一旦建立对等关系，节点可以向远程节点发送getaddr和addr消息来获得其它的对等节点信息。为了维持与对等节点的连接，节点默认情况下每30分钟内会给对等节点至少发送一次信息。如果超过90分钟没有收到回复，节点会认为连接已经断开</li></ul><h3 id="Initial-Block-Download"><a href="#Initial-Block-Download" class="headerlink" title="Initial Block Download"></a>Initial Block Download</h3><ul><li>一个全节点在正式工作或者提供服务前，需要进行初始化，把除了硬编码生成的第一个区块外的所有区块下载下来，这个过程就是IBD。</li><li>Block-First 是其中一种下载方式，向一个对等网络节点进行询问，直接下载区块，其缺点也很明显<ul><li>下载速度的限制：只从一个同步节点下载，受限该节点的带宽</li><li>重新下载：同步节点可能会发送不是最长链上的区块，就会导致快结束时才发现需要重新下载</li><li>磁盘空间占用：和“重新下载”相关，下载时可能会将无用的区块保存到磁盘，占用空间</li><li>大量内存使用：因为同步节点发送过来的区块可能是无序的，所以需要先保存到内存中，直到接收到父块才能进行验证</li></ul></li><li>Header-First 的下载方式，解决了Block-First中四个缺陷，它的工作方式是：先向同步节点下载block headers，当部分地验证headers有效性后，IBD节点就可以并行地做两天事——一个是继续向同步节点发送请求下载headers，另一个是向其他对等节点发送请求下载block</li></ul><h2 id="Mining-挖矿"><a href="#Mining-挖矿" class="headerlink" title="Mining 挖矿"></a>Mining 挖矿</h2><ul><li>现在有两种挖矿方式：单独挖矿和矿池挖矿<ul><li>单独挖矿：bitcoind来获取P2P网络上的交易，挖矿软件通过RPC方法来获取列表，并构造一个Block模板，然后将对应的block header发送给ASIC进行运算。挖矿软件会将一个nonce值填入币基交易的的字段中，获得新的Merkle root的hash值，然后将新的Block header发送个ASIC。如果ASIC计算生成的block header hash小于预定的阈值，则表明添加的nonce值符合条件，将block header返回给挖矿软件，挖矿软件根据返回的block header更新block，最后将完整的block 返回给bitcoind，bitcoind再向网络传播区块</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350617.(null)"></p><ul><li>矿池挖矿：工作流跟单独挖矿类似。不同的是，矿池设定的阈值要比网络上设定的阈值小很多（降低了难度），因此各个矿工通过挖矿软件返回给矿池的block hearder中，有很多是满足矿池的阈值但不满足网络的阈值，这些返回的block header相当于是份额，证明了矿工的工作量；同时总会有几率产生同时满足两个阈值的block header，矿池将满足网络阈值条件的block发送给bitcoind，从而获得奖励。然后矿池根据矿工贡献的份额，平均分发奖励。举个具体例子就是，矿工们总共返回了100个满足矿池条件的block header（相当于有100份额），只有1个满足网络阈值，那么每份额的奖励就是总奖励的1/100，矿工根据自己的份额获得相应奖励。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350905.(null)"></p><ul><li>还介绍了三种挖矿软件获取Block的RPC<ul><li>getwork RPC：当前Bitcoin Core已经废弃，这个方法直接为矿工构造好block header，因此矿工可能需要调用成百上千次RPC</li><li>getblocktemplate RPC：获取以下内容；然后挖矿软件就能自己改变nonce值，自己生成block header<ul><li>构造币基交易的信息</li><li>bitcoind发送给矿池的交易列表和具体交易信息，这使得挖矿软件可以查看交易，并有选择性地添加或删除交易</li><li>构造block header的其他信息</li><li>矿池提供的难度值或者网络设定的难度值</li></ul></li><li>Stratum：跟getblocktemplate很类似，但是不同的是，挖矿软件获取到的是重新构造Merkle树的必要信息，而不是具体的交易列表和交易内容。因此，挖矿软件不能添加或者删除交易，不过此时挖矿软件和矿池建立双向的TCP连接；在getblocktemplate 里，挖矿软件用的是HTTP longpoll长轮询，来获取最近的更新。</li></ul></li></ul><h1 id="存在疑问"><a href="#存在疑问" class="headerlink" title="存在疑问"></a>存在疑问</h1><p>阅读完所有内容后，还是有很多问题和细节没有弄明白。</p><ol><li>原文：Since it is impractical to have separate transactions with identical txids, this does not impose a burden on honest software, but must be checked if the invalid status of a block is to be cached; otherwise, a valid block with the duplicates eliminated could have the same merkle root and block hash, but be rejected by the cached invalid outcome, resulting in security bugs such as <a href="https://en.bitcoin.it/wiki/CVEs#CVE-2012-2459">CVE-2012-2459</a>.</li></ol><blockquote><p>对于上述内容不是很能理解，不同的transactions怎么会有相同的TXID，可能是由于hash冲突导致的？虽然概率很小。然后“对于缓存一个无效区块的状态”，这该如何理解？什么时候用到了缓存，缓存什么内容（区块的状态？），以及如何判断区块是有效还是无效？如果因为有TXID冲突判定区块无效的话，可以去重TXID，达到有效？</p></blockquote><ol><li>标准交易中，Null Data的的pubkey scripts类型用来干什么的？</li><li>P2PK 被 P2PKH所取代了，支付到公钥哈希的地址，可以使得公钥直到UTXO被使用时才会发布，延迟公钥发布的原因是什么呢？是为了避免攻击者利用公钥进行某些攻击吗？</li><li>多种Signature hash types的用途是什么呢？为什么要有选择性的进行签名？</li><li>交易被打包到区块，交易的费用是根据交易的签名字节长度计算出来，那么这笔费是由买家（支付者）来付吗？在对应的一个交易中，是会增加一个output来指向矿工吗？</li><li>对于HD钱包，即分层确定性钱包中的工作原理还是不太理解，特别是extened keys到harderned keys的转变，为什么要这么做？这么做如何解决问题的？</li><li>SPV客户端具体是怎么使用布隆过滤器的？</li><li>矿工发布区块时，具体是怎么给矿工发放奖励的？是在创建区块的时候，直接生成一个币基交易（把钱转账给该矿工），然后矿工打包所有交易后，开始找满足条件的nonce，找到后广播区块，这样如果区块得到其他节点认可上链了，那么矿工就切实得到了收益。（这样的话，每个节点在生成区块）</li></ol><h1 id="所思所感"><a href="#所思所感" class="headerlink" title="所思所感"></a>所思所感</h1><p>阅读完这篇Guide概览，让我认识了解比特币中许多技术和实现细节，但是通读完一遍后，发现自己好像懂了，又好像没懂，或者说从整体上对比特币的整体架构有了一定的认识，具体有哪些部分组成，涉及哪些关键技术，但是对个各个模块进一步的细节还是似懂非懂，并且还是难以串联起来，各个部分有明显的联系（比如交易与钱包与支付处理），但是感觉自己还是很难将这三者的关系表示清楚，或者说，当把整个比特币看做一个整体时，各个部分是怎么样有机独立又相互配合的。</p><p>还有一个简单的思考，就是对于合约部分中多重签名的使用，例如托管和仲裁，A和B之间的交易还是要依赖于仲裁第三方C，这是否与比特币去中心化的思想相矛盾了呢？后来进一步思考和查阅资料，从另一个视角去看，去中心化，不是不要中心，而是由节点来自由选择中心、自由决定中心。简单地说，中心化的意思，是中心决定节点。节点必须依赖中心，节点离开了中心就无法生存（类似于没了支付宝就不能用淘宝？）。而在去中心化系统中，任何人都是一个节点，任何人也都可以成为一个中心。任何中心都不是永久的，而是阶段性的，任何中心对节点都不具有强制性。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【99%环境搭建系列】云计算管理平台Devstack安装</title>
    <link href="/2021/10/08/2021-10-08%20devstack%E5%AE%89%E8%A3%85/"/>
    <url>/2021/10/08/2021-10-08%20devstack%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p class='note note-success'>99%概率完成环境搭建，让天下没有搭建不了的环境！ </p><p>openstack作为开源的云计算管理平台，可以让我们体验云计算技术的各种组件和功能，然而官网繁琐的配置教程令人望而却步。好在devstack提供了一站式安装服务，<del>只需简单执行几个命令即可完成安装</del>（根本不是这样好吗！）。不过经过我的百般测试，只要安装教程里的方式执行命令，成功概率99%！</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082112035.png"></p><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>这里说一下我个人的安装环境</p><ul><li>PC操作系统：win10</li><li>VMware Workstation版本：16.x Pro</li><li>Ubuntu版本：18.04 </li></ul><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><ol start="0"><li><strong>简要说明</strong></li></ol><p class='note note-primary'>ubuntu操作系统在虚拟机的安装这里不再演示，假设你已经完成了ubuntu18.04的安装，然后继续；<br>在~/ 目录下，依次执行命令即可，没有特殊说明，不用执行别的多余命令</p><ol><li><strong>设置静态IP（可选）</strong></li></ol><blockquote><p>说明：这一步是可选的，之所以设置成静态IP，是为了方便后面的配置，以及排除IP变动的原因导致的种种意外；不过不进行配置的话，应该也是ok的，只要保证整个安装以及使用过程IP不会改变</p><p>参考网站：<a href="https://www.cnblogs.com/yaohong/p/11593989.html">ubuntu配置静态ip</a>       <a href="https://blog.csdn.net/zh2508/article/details/85250360">VMware配置静态ip</a></p></blockquote><p>首先给机器设置静态ip，修改<code>/etc/netplan</code>目录下对应的文件，按如下文件进行配置。</p><p class='note note-info'>  三个注意点：<br>  1. 注意配置里的"ens32" 根据自己的机器进行改动，可能是"ens33"，可以通过命令 ip addr 来进行查看 <br>  2. 这里复制的话，注意复制后的结果是否一致，可能需要自己手动输入一下，这样的话要严格注意格式，冒号后面需要一个空格，换行缩进是4个空格<br>  3. 设置的ip和网关要在同一个网段上，记住这里填入的ip，需要用在下面的配置中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br><span class="hljs-attr">network:</span><br><span class="hljs-string">​</span>    <span class="hljs-attr">ethernets:</span><br><span class="hljs-string">​</span>        <span class="hljs-attr">ens32:</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]<br><span class="hljs-string">​</span>            <span class="hljs-attr">optional:</span> <span class="hljs-literal">true</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.2</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">nameservers:</span><br><span class="hljs-string">​</span>                    <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.1</span>,<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.2</span>] <span class="hljs-comment"># 这里DNS的修改，是因为我配置了上面VMware配置静态ip</span><br></code></pre></td></tr></table></figure><p>然后执行<code>sudo netplan apply</code>，让配置生效，再通过<code>ip addr</code>查看是否生效，已经<code>ping</code>命令查看网络是否连通</p><ol start="2"><li><strong>切换apt源</strong></li></ol><p>切换apt源的目的是为了加快下载安装的速度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install vim #先安装下vim<br>sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak<br>sudo vim /etc/apt/sources.list # 如果vim还没有安装，改用 vi 复制下就行<br></code></pre></td></tr></table></figure><p>这里配置用的是阿里云的镜像，如果之后因为网络的问题可以尝试换下别的源，不过我测试使用的都是阿里云</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 注意ubuntu版本号对应不同的代号，这里用的是18.04，对应bionic</span><br>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>更换pip源</strong></li></ol><p>也是为了加快下载安装依赖的速度</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir .pip<br>vim .pip/pip.conf<br></code></pre></td></tr></table></figure><p>配置如下所示，用的是豆瓣的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[global]<br>index-url = http://pypi.douban.com/simple/<br>trusted-host = pypi.douban.com<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>更新并安装包</strong></li></ol><p>依次执行下列命令，主要是更新安装相关依赖，下载pip管理依赖工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get upgrade<br>sudo apt-get install git<br>sudo apt-get install python-pip<br>sudo pip install --upgrade pip<br>sudo pip install -U os-testr  # sudo pip install wcwidth 可选，如果这一步出了wcwidth相关的error的话<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>设置时区同步</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install ntpdate // 安装时间同步工具<br>sudo ntpdate cn.pool.ntp.org // 与网络服务器同步时间<br>date // 查看时间是否已经同步<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>下载devstack</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/openstack/devstack.git -b stable/queens</span> <br><span class="hljs-meta">#</span><span class="bash"> 推荐使用opendev.org官网的wallby这个分支，github上对应的queens这个分支尝试过有问题解决不了</span><br>git clone https://opendev.org/openstack/devstack.git -b stable/wallaby <br></code></pre></td></tr></table></figure><ol start="7"><li><strong>创建stack用户</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo devstack/tools/create-stack-user.sh<br></code></pre></td></tr></table></figure><ol start="8"><li><strong>移动并设置文件夹权限</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mv devstack /opt/stack<br>sudo chown -R stack:stack /opt/stack<br>sudo chown stack:stack /opt/stack<br></code></pre></td></tr></table></figure><ol start="9"><li><strong>切换到stack用户</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo su - stack<br></code></pre></td></tr></table></figure><ol start="10"><li><strong>创建local.conf配置文件</strong></li></ol><p>执行下列命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd devstack<br>vim local.conf<br></code></pre></td></tr></table></figure><p>配置文件内容如下，<strong>注意修改HOST_IP</strong>，改成自己当前的IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[[local|localrc]]<br><span class="hljs-meta">#</span><span class="bash"> Define images to be automatically downloaded during the DevStack built process.</span><br>DOWNLOAD_DEFAULT_IMAGES=False<br>IMAGE_URLS=&quot;http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> use TryStack git mirror</span><br>GIT_BASE=http://git.trystack.cn<br>NOVNC_REPO=http://git.trystack.cn/kanaka/noVNC.git<br>SPICE_REPO=http://git.trystack.cn/git/spice/sice-html5.git<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> Credentials</span><br>[[local|localrc]]<br>ADMIN_PASSWORD=admin<br>DATABASE_PASSWORD=$ADMIN_PASSWORD<br>RABBIT_PASSWORD=$ADMIN_PASSWORD<br>SERVICE_PASSWORD=$ADMIN_PASSWORD<br><span class="hljs-meta">#</span><span class="bash"> Host IP - get your Server/VM IP address from ip addr <span class="hljs-built_in">command</span></span><br>HOST_IP=192.168.10.112 # ifconfig获取本机ip<br>enable_service placement-api<br>enable_service placement-client<br></code></pre></td></tr></table></figure><ol start="11"><li><strong>提前下载依赖包</strong> </li></ol><p>因为是从github上连接下载依赖包，可能由于网络不好的问题，直接安装的话可能中途会因为下载失败导致安装失败，所以这里提前下载；如果下载失败了，就多执行几次，肯定是可以的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd files/<br>wget -c https://github.com/coreos/etcd/releases/download/v3.1.10/etcd-v3.1.10-linux-amd64.tar.gz<br>wget -c https://github.com/coreos/etcd/releases/download/v3.1.7/etcd-v3.1.7-linux-amd64.tar.gz<br>wget -c https://github.com/etcd-io/etcd/releases/download/v3.3.12/etcd-v3.3.12-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><ol start="12"><li><strong>安装simplejson</strong></li></ol><p>经过测试，之后安装的过程中可能会报错simplejson安装失败，所以这里提前进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> sudo apt-get purge python3-simplejson 清楚之前的软件包和配置</span><br>sudo apt-get install python3-simplejson<br><span class="hljs-meta">#</span><span class="bash"> sudo apt-get install python-simplejson <span class="hljs-comment"># 上面的命令不行可以试下这个</span></span><br></code></pre></td></tr></table></figure><ol start="13"><li><strong>修改pip安装配置</strong></li></ol><p class='note note-info'>  在测试中，pip相关安装可能会报错，这里提前修改下</p><p>修改对应的目录文件 <code>devstack/inc/python file 198 line</code></p><p> 源代码 <code>$cmd_pip $upgrade</code> </p><p> 修改成 <code>$cmd_pip $upgrade --ignore-installed</code></p><ol start="14"><li><strong>修改权限</strong></li></ol><p>经过测试，之后安装的过程可能会出现如下权限错误的错误，所以这里再次修改权限</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082049771.png" alt="pip下载报错"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chown -R stack:stack /opt/stack<br>sudo chown stack:stack /opt/stack<br>sudo chown -R stack:stack /opt/stack/devstack<br><span class="hljs-meta">#</span><span class="bash"> sudo chmod -R 777 /opt/stack  <span class="hljs-comment"># 先用前三个命令应该足够了，不行再试试这个</span></span><br></code></pre></td></tr></table></figure><ol start="15"><li><strong>开始安装</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>FORCE=yes ./stack.sh<br></code></pre></td></tr></table></figure><p>可能因为网络的原因，中途会连接不上github，导致安装失败，这样就需要重新尝试，先清理下环境再安装，多尝试几次应该都会成功的，不过确保网络质量也比较重要。</p><p>如果是因为下载github上某个依赖包导致的失败，可以事先安装好对应的依赖，使用pip命令下载即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">./unstack.sh<br>./clean.sh<br>FORCE=yes ./stack.sh<br></code></pre></td></tr></table></figure><ol start="16"><li><strong>见证奇迹的时刻</strong></li></ol><p>当你看到如下信息的时候，恭喜你，完成安装~</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110081954141.(null)" alt="成功截图"></p><ol start="17"><li><strong>openstack界面展示</strong></li></ol><p>具体如何使用openstack，这里就不再详细演示，openstack功能大家就自行地快乐玩耍吧~</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110081954271.(null)" alt="openstack界面展示"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到此为止，devstack的安装教程就到此结束了，如果安装上面的步骤成功了，恭喜你我的朋友！</p><div align='center'><img src='https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082121023.jpeg' width='30%' height='30%' > </div><p>当然如果出现了别的问题无法解决的话，可以评论留下你的问题，或者与我联系。</p><hr><p>如果真的山穷水尽了的话，microstack 官网教程值得你的拥有~</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082124003.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/hunjiancuo5340/article/details/85005995">https://blog.csdn.net/hunjiancuo5340/article/details/85005995</a></p><p><a href="https://blog.csdn.net/u013184378/article/details/84973629">https://blog.csdn.net/u013184378/article/details/84973629</a></p><p><a href="http://www.cnblogs.com/lianshuiwuyi/p/10955041.html">http://www.cnblogs.com/lianshuiwuyi/p/10955041.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devstack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动漫名台词收录</title>
    <link href="/2021/09/30/2021-09-30%20%E5%8A%A8%E6%BC%AB%E5%90%8D%E5%8F%B0%E8%AF%8D%E6%94%B6%E5%BD%95/"/>
    <url>/2021/09/30/2021-09-30%20%E5%8A%A8%E6%BC%AB%E5%90%8D%E5%8F%B0%E8%AF%8D%E6%94%B6%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏王"><a href="#游戏王" class="headerlink" title="游戏王"></a>游戏王</h1><h2 id="凯撒亮"><a href="#凯撒亮" class="headerlink" title="凯撒亮"></a>凯撒亮</h2><p>因为之前也入坑过游戏王决斗链接国际服，也就组过月光、不知火、电子龙三套牌组，电子龙是我退坑前最后组的卡组，因此也有着特殊的感情。不久前听闻电子龙被彻底削废了，直接入土为安，心情也是五味杂陈，还能继续挣扎吗？</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202109301523396.jpg" alt="img"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202109301531454.jpg" alt="img"></div></div></div><p><a href="https://www.bilibili.com/video/BV12b4y1C7wC">【日语每日一句】凯撒亮经典台词教学</a></p><p>Ko re ga, i ki no ku ru ta me no, o re no a ga ki da !</p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202109301537861.png" width="50%" height="50%" align="middle" ><p>你又是如何呢，你又是为了什么而奋战至今？只要为了达到理想的终点，就算是卑微的挣扎又如何，这就是我所选择的道路！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>动漫</tag>
      
      <tag>游戏王</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Fluid主题博客搭建（小白向）</title>
    <link href="/2021/09/28/2021-09-28%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/09/28/2021-09-28%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.fluid-dev.com/posts/fluid-write/">搭配 Fluid 如何优雅的写一篇文章</a></p><p><a href="https://www.cnblogs.com/mfrank/p/12829882.html">Hexo博客部署Github Pages</a></p><p><a href="https://blog.csdn.net/i_do_not_know_you/article/details/105594269">绑定域名的遇到坑</a></p><p><a href="https://evenweiss.github.io/2021-08-02-blog-building/#%E4%B8%80%E3%80%81Github-Pages-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%85%8D%E7%BD%AE">博客搭建教程</a></p><p>绑定阿里云的top域名，解析成功的问题是：访问速度变得巨慢，并且页面效果很差，图片几乎展示不出来；和vercel部署出来的效果一致（是不是存在什么共性？）；</p><p>当删除阿里云域名解析相关记录后，访问2017zhangyuxuan.github.io 依然会跳转到注册的域名上kingofdark.top，然后报错HTTP 502</p><p><a href="https://github.com/qixa/hexo-theme-fluid-mod#%E8%AF%A6%E7%BB%86%E4%BF%AE%E6%94%B9%E4%BF%A1%E6%81%AF">进阶修改版</a></p><p><a href="https://www.julydate.com/post/60859300/#%E6%80%BB%E7%BB%93">CDN加速</a></p><p>心态崩了，弄了几天也没绑定上自己的域名，然后CDN加速也需要配置自己的域名，后来想想还是算了，毕竟博客还是内容最重要，像是页面的美观或者是网站加载速度都是其次了，下次一定。（也只能这样安慰自己了，流下了无能的泪水）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/25/hello-world/"/>
    <url>/2021/09/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="取消评论时显示浏览器内核与操作系统信息"><a href="#取消评论时显示浏览器内核与操作系统信息" class="headerlink" title="取消评论时显示浏览器内核与操作系统信息"></a>取消评论时显示浏览器内核与操作系统信息</h3><p>hexo-theme-fluid/source/css/main.styl 路径下添加 (不过好像只有本地预览有效，部署到Github pages上依然不生效；在Vercel部署的，同样也已经生效了)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.vmeta</span> &#123;<br>  <span class="hljs-attribute">display</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure><p>更好的做法是在服务端配置DISABLE_USERAGENT 环境变量为true；重新部署后得到新的server url，一定要记得把这个server url填写到_config.fluid.yml文件中，更新！！ 着了踩了个大坑！！<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="细心很重要">[2]</span></a></sup></p><h3 id="Typora图床配置"><a href="#Typora图床配置" class="headerlink" title="Typora图床配置"></a>Typora图床配置</h3><p><a href="https://zhuanlan.zhihu.com/p/365829157"><strong>Typora+PicGo+Github = Markdown编辑器+图床</strong></a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="牛啊">[1]</span></a></sup></p><p>parallel desktop上 ubuntu20.04 配置国内镜像源无法生效，百度用的改DNS的方法都不行，还是汇报Failed Fetch的错误，找不到对应的IP（这个坑以后再看看吧，或者有那个好心人帮忙看看）</p><p>难道说是还没有arm的镜像吗。。。</p><section class="footnotes"><h2>备注/参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>牛啊<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>细心很重要<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
