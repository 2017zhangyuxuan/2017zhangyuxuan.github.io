<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++指针那些事</title>
    <link href="/2022/01/17/2022-01-17%20C++%E6%8C%87%E9%92%88%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/01/17/2022-01-17%20C++%E6%8C%87%E9%92%88%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>指针真的让人又爱又恨，每当自己认为已经参悟一二，现实总是狠狠地打了我脸，不是忘了这个，就是忘了那个。因此趁这个机会，再温习回顾下C/C++里指针的相关语法知识，并记录下来以便日后复习。</p><h1 id="基本知识"><a class="markdownIt-Anchor" href="#基本知识"></a> 基本知识</h1><h2 id="指针基本概念"><a class="markdownIt-Anchor" href="#指针基本概念"></a> 指针基本概念</h2><p>在C语言中，每定义一个变量，系统就会为变量分配一块内存，而内存是有地址的。C语言中，采用运算符 &amp; 来获取变量的地址。</p><p><strong>指针是一种特殊类型的变量，用于存储变量的地址</strong>。当指针变量赋值之后，就可以使用运算符 * （解引用运算符），取得指针所指向地址的值，简单用法如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span>* p;  <span class="hljs-comment">// 定义一个指针p，类型为 int;</span><br><span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<span class="hljs-comment">// 定义一个 int 变量</span><br><br>p = &amp;b;<span class="hljs-comment">//将 p 指向 b</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;变量 num 的地址为 &quot;</span> &lt;&lt; p &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;变量 num 的地址为 &quot;</span> &lt;&lt; (&amp;num) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;变量 num 的值为&quot;</span> &lt;&lt; num &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;变量 num 的值为&quot;</span> &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">// *p 表示指针p中存储的地址所对应的值；</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：在 C++ 创建指针时，计算机将会分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存 ，为数据分配的空间是一个独立的空间，不可省略，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> *pt;<span class="hljs-comment">// 定义一个指向 int 类型的指针 pt;</span><br>*pt = <span class="hljs-number">23</span>;<span class="hljs-comment">// 错误，指针 pt 未指向任何地址，</span><br></code></pre></td></tr></table></figure><p>所以需要谨记一点，在对指针应用解引用运算符(*) 之前，将指针初始化为一个确定的，适当的地址。</p><h2 id="空指针与野指针"><a class="markdownIt-Anchor" href="#空指针与野指针"></a> 空指针与野指针</h2><p>空指针：没有赋值的指针变量（没有指向内存变量的地址），对空指针进行操作会造成程序的Core dump（段错误）。如下代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span>* p = <span class="hljs-number">0</span>;<br>*p = <span class="hljs-number">10</span>;<span class="hljs-comment">// 运行报错</span><br></code></pre></td></tr></table></figure><p>野指针：指针指向内存已释放，但指针的值不会被清零，对野指针操作的结果不可预知。如下代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">delete</span> p ;<br><span class="hljs-keyword">if</span> (p !=  <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-comment">// 已经释放了对应内存空间，但指针的值还没有清零，此时成为野指针</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;not nullptr&quot;</span> &lt;&lt; endl;<br>&#125;<br>p = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">// 释放指针后，应当手动置指针为nullptr</span><br></code></pre></td></tr></table></figure><h2 id="sizeof的坑"><a class="markdownIt-Anchor" href="#sizeof的坑"></a> sizeof的坑</h2><p>sizeof(x) ，当 x 为指针变量时，求得的是指针类型的大小；当 x 为数组名时，求得的是数组的大小（数组元素个数 * 数组元素类型大小）。</p><p><strong>注意</strong>：当数组作为函数的参数进行传递时，数组自动退化为同类型的指针。参考下面示例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data[])</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(data);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> data1[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">int</span> size1 = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(data1);    <span class="hljs-comment">// 20 （输出的是数组大小)</span><br>    <br>    <span class="hljs-keyword">int</span>* data2 = data1;<br>    <span class="hljs-keyword">int</span> size2 = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(data2);    <span class="hljs-comment">// 8 (64位机器） 输出的是指针大小</span><br>    <br>    <span class="hljs-keyword">int</span> size3 = <span class="hljs-built_in">get_size</span>(data1);  <span class="hljs-comment">// 8 (64位机器）</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="指针与数组"><a class="markdownIt-Anchor" href="#指针与数组"></a> 指针与数组</h1><ul><li>数组名用法上 类似于一个指针常量，指向数组首元素的地址</li><li>对于指针p， p+1 的跨度，即移动p一次增加的字节数大小，等于指针p所指元素类型的大小<ul><li>对于int *p，增加4字节</li><li>对于double *p ，增加8字节</li><li>对于int (* p)[3)，增加 3 * 4 = 12 字节，因为p指向的是一个数组，整个数组的大小为3、*4 = 12字节</li><li>对于int* * p，增加8字节（64位系统），因为p指向的是一个int*指针，而指针大小为8字节</li></ul></li><li>对于new的使用，通常是和指针结合在一起，对于 Type* p （Type代表某种类型），通常new是有两种用法<ul><li><code>Type* p = new Type( )</code>，只分配单个Type的内存，new返回的也是这个Type的内存地址<ul><li>获取对应元素，通常使用 *p，但是 p[0] 也是同样的效果；使用 p[1] 的话，会访问超出了我们分配的内存，可能带来不可预知的后果</li></ul></li><li><code>Type* p = new Type[n]</code>，分配n个 Type的内存，new返回的是Type数组首元素的地址<ul><li>获取对应元素，通常使用 p[i]，获取下标为 i 的元素</li></ul></li></ul></li></ul><hr /><p>这样的话有这样一个疑惑，如下方图片中标红区域，可以有申请一个int的大小，申请一个指针的大小，如何单独申请一个数组对象？</p><center><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202201221755705.png" alt="" style="zoom: 50%;" /></center><p>似乎并没有相对应的方式，因为申请一个数组的空间已经用 <code>int* p = new int[3]</code> 表达了，其实这个问题有点类似钻牛角尖，或者说自以为有这样的对称规律在。但在实际使用中并不推荐使用new 和 delete，对于数组的需求，使用vector&lt; T&gt; 就行了；这里只是为了探讨研究语法问题。</p><h1 id="指针常量与常量指针"><a class="markdownIt-Anchor" href="#指针常量与常量指针"></a> 指针常量与常量指针</h1><p><strong>指针常量</strong>：指针类型的常量。表示这个指针变量用const修饰后成了常量，变量的值不能改变即不能指向其他地址，但是指针所指向地址里的值是可以修改的。同时注意这是个常量，所以在定义的时候要初始化。</p><p><strong>常量指针</strong>：指针变量指向的类型为常量类型，即指针指向地址里的值不可以修改。</p><p>具体示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p1 = &amp;a;<span class="hljs-comment">// p1是指针常量</span><br>*p1 = <span class="hljs-number">30</span>;   <span class="hljs-comment">// p1指向的地址是一定的，但其内容可以修改</span><br><span class="hljs-comment">// p1 = &amp;b;// p1指针常量不能指向其他变量的地址</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p2 = &amp;a; <span class="hljs-comment">// p2是常量指针</span><br><span class="hljs-comment">// int const *p2 = &amp;a; // 和上一行等价</span><br>p2 = &amp;b; <span class="hljs-comment">// p2可以指向其他地址，但是内容不可以改变</span><br><span class="hljs-comment">// *p2 = 10; // p2常量指针，所指向地址的值不可以修改</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p3 = &amp;a;<span class="hljs-comment">// p3既是指针常量又是常量指针</span><br><span class="hljs-comment">// p3 = &amp;b;// p3不能指向其他地址</span><br><span class="hljs-comment">// *p3 = 30;// p3所指向地址的值不能修改</span><br></code></pre></td></tr></table></figure><p>有时候指针常量和常量指针傻傻分不清，教大家一个小技巧，<strong>就是看 const  在 * 的哪一侧</strong>，如果const 在 * 左侧，表明const 靠近所指向的变量类型，即所指向的变量是个常量，也就是常量指针；如果 const 在 * 的右侧，表明 const 靠近指针变量名，所以这个指针变量是个常量，也就是指针常量。</p><h1 id="函数名与函数指针"><a class="markdownIt-Anchor" href="#函数名与函数指针"></a> 函数名与函数指针</h1><p>就像定义 int 变量时，会在内存里分配一个4字节的空间存储该变量，对应有一个地址；当定义了一个函数后，同样需要在内存中分配空间进行存储，调用函数就像使用变量一样需要一个地址来唯一的指向它，所以每个函数都需要一个地址来唯一标识自己，也就是所说的入口地址。</p><p>函数名标识映射该函数的入口地址，而函数指针是指向函数入口地址的指针变量（记住了函数名本身并不是一个指针类型）。</p><p>有了指向函数的指针变量后，可以用函数指针变量调用函数，就像用指针变量操作其他类型变量一样。函数指针主要有两个用途：调用函数和做函数的参数。</p><hr /><p>我们都知道在调用函数的时候有函数名就够了，比如fun(2)，但编译器在编译的时候会进行所谓的&quot;<strong>Function-to-pointer conversion</strong>&quot;，也就是把函数名隐式转换成函数指针类型，也就是要通过函数指针来调用函数，所以如果你在调用函数的时候写成(&amp;fun)(2)也是一样能工作的，因为&amp;fun实际上就是返回一个函数指针。参照下面例子，只是这种写法很不常见，即使你不显式的写出&amp;的话编译器也会隐式的进行转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;fun&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fun=%p\n&quot;</span>,fun);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*fun=%p\n&quot;</span>,*fun);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;fun=%p\n&quot;</span>,&amp;fun);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*******fun=%p\n&quot;</span>,*******fun);<br><br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*p1)(<span class="hljs-keyword">int</span>)=fun;<span class="hljs-comment">// 函数指针p1，fun进行一次隐式转换</span><br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*p2)(<span class="hljs-keyword">int</span>)=*fun;<span class="hljs-comment">// fun进行了两次隐式转换</span><br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*p3)(<span class="hljs-keyword">int</span>)=&amp;fun;<span class="hljs-comment">// 显示转换成函数指针</span><br><span class="hljs-comment">//    void(*p4)(int)=&amp;&amp;fun; // 不可以，连续取两次地址，就变成了函数指针的指针类型</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p1=%p\n&quot;</span>, p1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p2=%p\n&quot;</span>, p2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p3=%p\n&quot;</span>, p3);<br>&#125;<br></code></pre></td></tr></table></figure><p>正如上面代码示例所示，其实即使你写成(* fun)(2)也是可以正常运行的，这是因为当编译器看到fun的时候发现它前面没有&amp;，<strong>也就是如果没有将函数名显示地转换成指针，那么他就会隐式地转换成指针</strong>，当转换完之后发现前面又有一个 * 这时候也就是要进行所谓的&quot;解引用&quot;操作，也就是取出 * 指针里的值，而那么值实际上也就函数名fun，这样一次隐式换然后再来一次解引用实际上相当于什么也没做，所以系统还会再进行一次隐式的&quot;Function-to-pointer conversion&quot;，所以即使你写成(************fun)(2)也会正常运行，和刚才的一个道理，只是多做了几次反复的转解操作而已，都是编译器自己完成的。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p>[1] <a href="https://www.cnblogs.com/Esfog/archive/2012/04/23/2467249.html">C/C++的函数名和函数指针的关系剖析 - Esfog - 博客园</a></p><p>[2] <a href="https://www.jb51.net/article/54220.htm">数组名与数组指针、指针数组</a></p><p>[3] <a href="https://juejin.cn/post/6923743288407097351">C++ 指针详讲、及指针与数组 - 掘金</a></p><p>[4] <a href="https://www.bilibili.com/video/BV16T4y1w7wm?p=7">解决全部C语言指针的问题_哔哩哔哩</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年终总结</title>
    <link href="/2021/12/31/2021-12-31%202021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2021/12/31/2021-12-31%202021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>现在是2021年12月31日19点45分，后天的这个时候我应该在考云计算，所以保险起见，我还是先去复习吧，年终总结就放到考完试再补上~</p><center><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20190816%2Fc1bb1f88cc334de5bfdb433c1766f830.png&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643543259&t=b6769fbb96552656e2b401a1e9d5feea" alt="" style="zoom:50%;" /></center><hr /><p>今天是2022年1月2日，现在我已经考完了史诗级难度的算法分析与设计，以及差点没写完的云计算。等到我心情平复下来，也时候补交这份年终总结了。</p><center><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202201022151747.jpeg" alt="看开了" style="zoom:40%;" /></center><h1 id="实习"><a class="markdownIt-Anchor" href="#实习"></a> 实习</h1><h2 id="实习经历简介"><a class="markdownIt-Anchor" href="#实习经历简介"></a> 实习经历简介</h2><p>从去年11月开始，我就去了字节实习，而截至今年开学9月份才离职，再除去中间请假一个多月回学校做毕设，算起来也快实习了9个月，不禁令人感叹时间真的过得太快了，下面我就简单介绍一下自己的实习经历吧。我所在部门是抖音国际版（也就是Tiktok）的广告中台Global Ads Infra，负责广告投放的相关业务，也算是比较核心的部门了，毕竟广告营收是流量变现的重要途经。</p><p>在实习期间，的确是学习到了不少广告的相关知识，从零开始了解相关业务，记得一开始碰到的广告相关的陌生名词有满满一页，对具体的广告投放流程也是云里雾里，不知所踪。到后来，待久了，也渐渐熟悉起来，明白了大致流程，大体的模块架构，当然也非常浅显，只是对各个功能模块了解个大概。从硬看源码，到增加功能点，进行测试，开AB测试实验，再到提交自己的PR通过Review，最终代码上线，这一过程下来也让我些许了解了大厂的项目开发流程。</p><p>然后再谈谈我个人的工作吧，一开始我是维护一个线上服务的监控系统，简单来说就是在线上服务里增加打点逻辑，然后再另一个程序里进行流处理，实时输出相关监控指标，不过因为代码使用scala写的，我也不是很熟，所以只是简单修改了一下逻辑，修复Bug。老实说，因为这个项目是2年前的项目了，大概快一年没人在维护了，所以感觉问题还是很大的，但我个人又因为实力不足，无法进行重构，就是那种知道有问题，但又给不出解决方案，可以说是菜鸡落泪了，所以最后这个项目也就是做到了能跑的效果。不过这个监控服务后来也没有被怎么重视，没有什么人用，所以也就这样了，因为后来有了更重要的需求要做。</p><p>之后主要负责的工作是搭建实验指标，为开发同学实验测试提供指标参考，测试新增功能是否存在异常。具体来说，我就是收集各个服务Owner的需求，在对应服务的代码里增加相关逻辑，然后提交需求给实验指标平台，再让他们做完成实验平台上的开发工作。这个工作的主要难点，就在于要去看各个服务的代码，得稍微懂点其中运行流程和逻辑，然后再合适的地方加上数据打点，写的代码其实不多，还有就是处理逻辑需要写个Flink SQL，然后再把需求整理给文档提交给实验平台的同学。这个过程是收集需求，看代码了解逻辑，以及和其他部门的同学打交道，对接工作需求，虽然重复性工作挺多，但也有一定的收获。</p><p>最后的话，是对一个线上服务做了小优化，主要在mentor的指导下，优化了Go语言里Map序列化的问题，略微降低了在线服务机器的CPU和内存使用率。这个工作对我来说，感觉受益匪浅，学习到了怎么去进行测试，性能优化看哪些指标，怎么看，最后出了一份方案报告，虽然也比较简单吧，但也受到了大家的肯定，对我来说，感觉还是很不错的，就是那种你做的工作切实有效，是肉眼可见的，而没有白费，就感觉实现了自己的一点价值。</p><h2 id="实习收获与感受"><a class="markdownIt-Anchor" href="#实习收获与感受"></a> 实习收获与感受</h2><p>总的来说，这份实习经历我认为还是非常宝贵的，无论是mentor还是其他同事，都十分友善，也都很有能力，给了我不少帮助和指导。不过实习期间，代码写的不多，文档倒是写了不少……所以我感觉自己的代码能力或许没有提升多少，但是眼界和视野是拓展开阔了，接触了解到项目的开发流程，学习如何与人合作沟通交流，思维方式也发生了改变，开始重视时间规划，估算工作量，关注工作产出。还有一个很大的收获就是学习使用飞书了，到现在，飞书也成了我的笔记主力，提升了我不少学习效率。</p><p>还有特别深的感触就是，感觉自己真的好菜，很多地方都不会，不懂，没啥突出的能力，跟正式员工真的差距很大，觉得自己在学校里虽然考试能拿高分，但是到了实际开发中，自己的能力真的是远远不足，没有过硬的代码能力，也没有什么架构思维，可能也就基础马马虎虎吧。也正是如此，让我下定决心，回到学校后，一定要去把这些欠缺的能力都给补起来。</p><h2 id="自我反思与总结"><a class="markdownIt-Anchor" href="#自我反思与总结"></a> 自我反思与总结</h2><p>在实习的头两个月还好，还保持着一种比较高昂的斗志，但是之后可能是热情散去了，就陷入了一种懒散的状态，每天相当于是打卡上班实习，按部就班完成自己的工作任务，也没有想着再多去学习新技术啥的，可能就导致我成长得比较慢（自我感觉）。</p><p>在实习期间，我还染上了一大恶习，那就是熬夜玩手机、玩电脑。曾经我也认为超过12点不睡觉就是罪大恶极，对身体会造成极大危害，会给自己带来极大的负罪感。但是在实习独居期间，各种熬夜到2、3点，甚至好几次熬夜到6点多睡，10点起上班，记得情况最严重的一次，当时整个人脑袋昏昏沉沉的，到了公司一点状态都没有，工作效率极差。而熬夜带来的连锁反应就是，睡眠不足，晚起不吃早饭，与我之前的作息大相径庭，也造成了我实习期间状态不佳，都没充沛的精神，还谈何学习和工作呢？再加上每逢周末必点外卖，不太注意饮食，导致那段期间身体状况不容乐观，明显可以感觉到不如从前。</p><p>总结来说，该反思的有两点，一个是心态上，实习期间还是缺乏一种积极学习的态度，或者说当时也没有明确的目标，不知道要学什么，可以学什么，每天就只是完成工作任务，没有花更多的时间来拓展学习，的确该好好反思反思。另一个就是身体上，如果连自己的身体照顾不好，那还谈什么其他的呢？身体是革命的本钱，同时良好的健康状态也才能更好地支撑工作学习，提高效率，以后真的是需要保持健康的生活作息，多运动，多健身。</p><h1 id="研究生"><a class="markdownIt-Anchor" href="#研究生"></a> 研究生</h1><p>今年下半年，我成为了北京大学软件与微电子学院的研究生。老实说，没有太多实感，就像是被一股潮流推至此地。简单谈谈在软微的学习生活吧，软微地方很小，我住的5号楼离食堂和宿舍都很近，下个楼拐个弯就到了，很方便。软微的食堂比较小，菜式也比较固定，几个月下来，我的早饭基本上就是肉饼、素饼、土豆饼、酱香饼、培根煎鸡蛋、豆浆这五样里排列组合，不过我对吃饭也没过高的要求，所以也都还能接受吧。</p><p>软微的课程，感觉总体上和 本科差别不大吧，比较大的区别可能就是，成了研究生之后，自学的时间占了大量的课后时间，除了一些核心课需要考试考核，其他多数课程是类似于大作业的形式进行考查。在软微，你会遇到大佬，遇到<s>卷王</s>（废寝忘食的人），遇到像我这样的佛系的人，也可以说是各具特色了。或许是之前有过实习经历吧，和许多能人、专家共事过，所以虽然也知道自己和别人的差距很大，倒也没有太大的心理压力了，一步一步脚印嘛，慢慢来吧，抗压这一块我一直可以的（哈哈，躺平就直说~）。</p><p>此外，我又重视其自己的健康了。开学以来，我就在积极锻炼了，在宿舍里做Keep，室外跑步，入冬之后就只剩下室内运动了。但不幸的时候，12月初腰部出了点问题，久坐之后感到疼，可能是腰肌劳损了，后来去看了医生，开了药膏和药丸，告诫我之后不能久坐，每坐一小时，就需要起来活动一会儿。也是因为这个原因，我的健身计划也不得已搁置了，不过也算是给我敲响了警钟，我的身体真的没有我想象中那么乐观了，各位朋友，也要多多保重自己的身体啊。</p><h1 id="生活"><a class="markdownIt-Anchor" href="#生活"></a> 生活</h1><p>再来谈谈这一年来的生活吧，年初因为疫情原因没有选择回家过年，人生第一次在外地和驰哥一起在过春节，记得初一还是初二，吃的还是泡面哈哈。年后又是近3个月的实习，然后就请假一个多月，回学校做毕设去了。在最后短暂的日子里，和大学同学们相拥这最后的时光，毕竟毕业之后，再次相见不知何年何月了，但相信总会有重逢的一天，就让我们在那一天到来之前，各自努力成为更好的自己吧~</p><p>毕业之后，在家呆了一星期之后又回公司实习去了。再此后，就是9月份研究生开学，正式拉开了我研究生生活的序幕。还记得当时上学前，立下一个flag，10月前必脱单，或许是看到周围身边的人都脱单而感到焦虑了，或许是感到寂寞了，或许是认为再不谈一场校园恋爱以后再也没有机会。但结果来说，我失败了。然后，然后就没有后文了。或许真的是单身太久了，不知道心动到底是怎样一种感觉，不知道喜欢一个人你该去怎么行动，不知道怎么去爱一个人。想想自身的原因，长相一般，身高一般，不太会装扮，生活常识也有欠缺，同时还是个看动漫的宅男，还带有略微的中二，还喜欢打游戏，除了稍微，一丢丢对学习上点心外，似乎没有别的什么特别之处，这样的人设的确吸引不了别人啊。不过后来我也看开了，再遇到她之前，我还是继续努力，多多提升自己吧，成为更优秀的人。</p><p>接着谈谈游戏吧，这一年主要玩的还是英雄联盟，每周六晚更是成了开黑时段，也就玩玩大乱斗了，与其说是玩游戏，或许更多的是享受和朋友吹水时刻吧。此外还用模拟器玩了女神异闻录p5以及八方旅人，感觉都是不错的游戏。以后的话，打算是等有钱了，整上台式机，ps主机，Switch，大屏显示器，不过可能到了那个时候可能反而没有玩游戏的心思了，想玩的时候玩不了，能玩的时候不想玩了或者还是玩不了，这么想来，还是有些许的悲伤呢。</p><p>还能说点什么呢，哦，对了，那就是我感觉自己还是没有长大，或者说不够成熟，对于人情世故不太擅长，不擅交际，对生活的一些常识或者说是细节还不了解，感觉自己的心态还是孩子一样，不愿去思考更多的东西，或者说不想去承担某些责任，只是任由生活推着自己往前走，而不是自己挑起担子往前跑，当然也有做努力在改变，但似乎远远不够。就像是周围的朋友都有了大人模样，而我还是那个沉浸在自己世界里的少年。我希望自己能长大，但也畏惧着长大。我很焦虑，但又很佛系，就像是薛定谔的猫一般，处在一个叠加态。</p><p>再谈谈一些个人的体会感悟吧：</p><ol><li>身体健康是第一位。</li><li>多关爱自己的父母。</li><li>多珍视自己的朋友。</li><li>学会换位思考。</li><li>一日三省吾身。</li><li>学无止境，终身学习。</li></ol><h1 id="目标"><a class="markdownIt-Anchor" href="#目标"></a> 目标</h1><p>最后自然是设定来年的目标啦，这里简略地列出了一些目标：</p><ol><li>搭建好自己的博客网站；</li><li>持续写博客，尽量保持每周一篇，目标全年50篇以上；</li><li>写番剧回顾，回顾自己的看番历史，也算是给自己热爱这么久的二次元一个总结交代吧。可以的话再剪辑一些片段，最后做一个AMV或者MAD出来；</li><li>C++ 开发学习，包括语法和项目（比如写一个网站，服务器）；stackflow上解决C++ 问题，检验自己的知识成果，目标Reputation 过500；</li><li>算法强化，刷题，目标Leecode 300题；</li><li>书籍阅读</li></ol><ul><li>计算机相关书籍 10本；;</li><li>文学类小说等 5本；</li><li>其他杂项（金融理财、传记、为人处世等）3~5本；</li></ul><ol start="7"><li>健身，目标拥有腹肌；增强上肢力量，增强背部、核心力量，目标引体向上做10个以上；</li><li>参加一次大型比赛并获奖，满足毕业资格；</li><li>日语继续学习，可以做到基本的听和说。</li></ol><h1 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h1><p>写写停停，缝缝补补，最后是在2022年1月7日回家的高铁上，完成了这篇年度总结，突然感觉自己又行了呢，哈哈。希望在新的一年了，自己能有更大的成长吧，也衷地祝愿各位成为更好的自己~</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>年度总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的最佳日志实践</title>
    <link href="/2021/12/25/2021-12-25%20%E6%88%91%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5/"/>
    <url>/2021/12/25/2021-12-25%20%E6%88%91%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><blockquote><p>本文译自：<a href="https://tuhrig.de/my-logging-best-practices/">https://tuhrig.de/my-logging-best-practices/</a></p></blockquote><p>如果你是一名后端开发者，那么日志就相当于你的应用的窗口。不像前端，除了日志消息外没有太多别的东西。接下来将介绍一些我个人写日志时的指导思想。</p><h1 id="log-after-not-before"><a class="markdownIt-Anchor" href="#log-after-not-before"></a> Log After, not before</h1><p>回想以下以前，每艘船都会有一本航海日志，就像日记一样，记录着每天发生的重要事情。就像一本传统的航海日志，我们应该记录已经发生的事情，而不是我们将要做的事情。</p><p>举一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// don&#x27;t do that</span><br>log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Making request to REST API&quot;</span>)<br>restClient.<span class="hljs-built_in">makeRequest</span>()<br> <br><span class="hljs-comment">// do that</span><br>restClient.<span class="hljs-built_in">makeRequest</span>()<br>log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Made request to REST API&quot;</span>)<br></code></pre></td></tr></table></figure><p>第一个 log 声明并没有给出太多信息。当读到它的时候，你并不知道REST调用是否成功。而为了知道是否调用成功，你必须寻找是否存在异常。当你读到这条log，但是却没有找到相应的 exception 异常，你将会困惑一整天。</p><blockquote><p>这里感觉没太翻译明白，可以对照原文看：The first log statement doesn’t tell much. When reading it, you will not know if the REST call was successful or not. To do so you must look for the absence of an exception. And if you read this log but miss the subsequent exception you will be confused for the rest of the day (trust me).</p></blockquote><p>第二个 log 方式则好了许多。它清楚地表明了刚刚的操作成功了。如果REST调用失败了，你将看不到这条 log，而是会有一个 exception。</p><p>我将对所有 <strong>INFO</strong> 日志遵守这条规则，然后对于 <strong>DEBUG</strong> 来说会生成 exceptions。</p><h1 id="separate-parameters-and-messages"><a class="markdownIt-Anchor" href="#separate-parameters-and-messages"></a> Separate parameters and messages</h1><p>一个典型的 log 小心包含两种类型的数据，一种是手写的消息，来声明接下来的消息内容。另一种类型数据则是一系列包含在之前操作中的参数。你应该区分这两部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// don&#x27;t do that</span><br>restClient.<span class="hljs-built_in">makeRequest</span>()<br>log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Made request to &#123;&#125; on REST API.&quot;</span>, url)<br> <br><span class="hljs-comment">// do that</span><br>restClient.<span class="hljs-built_in">makeRequest</span>()<br>log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Made request to REST API. [url=&#123;&#125;]&quot;</span>, url)<br></code></pre></td></tr></table></figure><p>第一种 log 消息有一些缺点。它是难以解析的，比如他对于 Grok pattern</p><p>来说。所以在我们的日志工具中，自动抽取 IDs 或者其他参数就会变得更困难。并且它也是难以阅读的。想象一下，一个非常长的 URL 在末端带有一系列参数。该条 log 消息的一半就超过了你的屏幕。同时，这个 log 也是难以扩展的。如果你想添加另一个参数（比如使用的 HTTP 方法）你就必须重写整个句子。</p><p>第二个版本就没有以上的缺点。它是非常容易解析的，因为它有清晰的结构。你在句子的前部分就能看到整个句子的内容。并且也十分容易扩展，只需要在列表里添加另一个参数。</p><h1 id="distinguish-between-warning-and-error"><a class="markdownIt-Anchor" href="#distinguish-between-warning-and-error"></a> Distinguish between WARNING and ERROR</h1><p>显然，有多种级别的 log 是有它存在的原因的，你应该适当地使用它们。在 <strong>WARNING</strong> 和 <strong>ERROR</strong> 之间存在明显的区别。</p><p>如果你做一些操作并且切实生效了，但是依然存在一些问题，这就是 WARNING。当如果你做了一些操作，它并没有生效，那就是一个 ERROR。</p><p>再来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    restClient.<span class="hljs-built_in">makeRequest</span>()<br>    log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Made request to REST API. [url=&#123;&#125;]&quot;</span>, url)<br>&#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span>(e: UnauthorizedException) &#123;<br>    log.<span class="hljs-built_in">warn</span>(<span class="hljs-string">&quot;Request to REST API was rejected because user is unauthorized. [url=&#123;&#125;, result=&#123;&#125;]&quot;</span>, url, result)<br>&#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span>(e: Exception) &#123;<br>    log.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;Request to REST API failed. [url=&#123;&#125;, exception=&#123;&#125;]&quot;</span>, url, exception)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 REST 调用可能有三种输出情况：</p><ul><li>它可以正常工作。那就会有一个 INFO 输出。</li><li>当它失败了，遇到了一个预期外的异常，那就是一个 ERROR。</li><li>当它导致了一些预期内的异常，那就是 WARNING。</li></ul><p>所以在 WARNING 的例子中，你做了一些事情，但你没有完美地做好。而在 ERROR 中，你并没有做事情。</p><p>另外注意，一个 WARNING（当然 ERROR 也是）是一个调用动作。如果没有人需要对此做出反应或者要做些什么，那么你也就不必去 log 输出 WARNING。</p><h1 id="info-is-for-business-debug-for-technology"><a class="markdownIt-Anchor" href="#info-is-for-business-debug-for-technology"></a> INFO is for business, DEBUG for technology</h1><p>INFO 日志应该看起来像一本书，它告诉你发生了什么，而不是如何发生的。这意味着 INFO 更适合于业务逻辑消息，相比于技术细节来说。技术相关的消息应该使用 DEBUG。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">INFO  | User registered <span class="hljs-keyword">for</span> newsletter. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br>INFO  | Newsletter send to user. [user=<span class="hljs-string">&quot;Thomas&quot;</span>]<br>INFO  | User unsubscribed from newsletter. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br></code></pre></td></tr></table></figure><p>上面 INFO 类型的日志，从我们业务逻辑的视角告诉你发生了什么。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">DEBUG | Saved user to newsletter list. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br>DEBUG | Send welcome mail. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br>INFO  | User registered <span class="hljs-keyword">for</span> newsletter. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br>DEBUG | Started cron job to send newsletter of the day. [subscribers=24332]<br>INFO  | Newsletter send to user. [user=<span class="hljs-string">&quot;Thomas&quot;</span>]<br>INFO  | User unsubscribed from newsletter. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br></code></pre></td></tr></table></figure><p>每个业务用例都会导致一条 INFO 日志输出。此外，会有 DEBUG 日志来给出更多细节信息，来描述处理过程。</p><h1 id="much-more"><a class="markdownIt-Anchor" href="#much-more"></a> Much more</h1><p>当然，对于好的日志来说还有许多值得做的。你还需要考虑 tracing, log aggregation and metrics 。但当提及如何书写时，我非常推荐上面的规则。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算的“奇淫技巧”</title>
    <link href="/2021/12/18/2021-12-18%20%E4%BB%8B%E7%BB%8D%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2021/12/18/2021-12-18%20%E4%BB%8B%E7%BB%8D%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><blockquote><p>原文来源：<a href="https://catonmat.net/low-level-bit-hacks">https://catonmat.net/low-level-bit-hacks</a></p></blockquote><p>介绍一些位运算的技巧，比如对应计算一个二进制整数中 1 bit的个数，不是通过循环遍历每一bit 是否为1，而是可以选择一些 tricky 的位运算来完成。</p><p>先来介绍一下本文中所使用的一些位运算操作符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">&amp;    -  bitwise and  位与<br>|    -  bitwise or     位或<br>^    -  bitwise xor    异或<br>~    -  bitwise not    取反<br>&lt;&lt;   -  bitwise shift left    左移<br><span class="hljs-meta">&gt;</span><span class="bash">&gt;   -  bitwise <span class="hljs-built_in">shift</span> right  右移</span><br></code></pre></td></tr></table></figure><p>在这篇文章中，表示的数字均为 8 bit 有符号整数（但是上述这些操作是可以在任意长度的有符号整数上执行的），并用 ‘x’ 来表示，而位运算计算后的结果用 ‘y’ 来表示。 其中 ‘x’ 的每一bit，使用 b<sub>7</sub>, b<sub>6</sub>, b<sub>5</sub>, b<sub>4</sub>, b<sub>3</sub>, b<sub>2</sub>, b<sub>1</sub>, b<sub>0</sub> 来表示，b<sub>7</sub> 是权重最高位（在符号数里就是符号位），b<sub>0</sub> 是权重最小的位。</p><p>接下来会先基本的bit hacks 介绍，然后逐渐深入到更高效的方法。</p><h1 id="1-检验一个整数的奇偶性"><a class="markdownIt-Anchor" href="#1-检验一个整数的奇偶性"></a> 1. 检验一个整数的奇偶性</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">if ((x &amp; 1) == 0) &#123;<br>  x is even<br>&#125;<br>else &#123;<br>  x is odd<br>&#125;<br></code></pre></td></tr></table></figure><p>相信很多人都已经看到过上述的技巧，其最基本的思想就是如果一个整数是奇数，那么它的最低位 b<sub>0</sub> 就为1。通过 将 ‘x’ 和 1 进行 <strong>AND-ing</strong> 操作，忽略其他bits，只关注 b<sub>0</sub> 即可，如果结果为0 表示 ‘x’ 是偶数，结果为1 表示 ‘x’ 是奇数。</p><p>举个例子，比如数字43，二进制表示为00101011，通过与 1 进行 <strong>AND-ing</strong> 操作，清除更高位的数值而只保留 b<sub>0</sub> ，最终剩余结果为 1 就表示整数为奇数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    00101011<br>&amp;   00000001   (note: 1 is the same as 00000001)<br>    --------<br>    00000001<br></code></pre></td></tr></table></figure><p>再举一个偶数的例子98，其二进制表示为1100010。在 <strong>AND-ing</strong> 操作后，最终结果为0，因此98是一个偶数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01100010<br>&amp;   00000001<br>    --------<br>    00000000<br></code></pre></td></tr></table></figure><h1 id="2-检验第n位-bit-是否置1"><a class="markdownIt-Anchor" href="#2-检验第n位-bit-是否置1"></a> 2. 检验第n位 bit 是否置1</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">if (x &amp; (1&lt;&lt;n)) &#123;<br>  n-th bit is set<br>&#125;<br>else &#123;<br>  n-th bit is not set<br>&#125;<br></code></pre></td></tr></table></figure><p>在先前的第一个例子，我们看到了通过 <code>（x &amp; 1）</code>来检验第一位 b0 是否置1，这个技巧可以通过改善实现检验第n位是否置1。主要做法就是将 1 左移n个位置，然后做相同的<strong>AND</strong> 操作，将除了第n位的其他bits清0。</p><p>下面演示了当你将 1 左移不同位数的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#">1         00000001    (same as 1&lt;&lt;0)<br>1&lt;&lt;1      00000010<br>1&lt;&lt;2      00000100<br>1&lt;&lt;3      00001000<br>1&lt;&lt;4      00010000<br>1&lt;&lt;5      00100000<br>1&lt;&lt;6      01000000<br>1&lt;&lt;7      10000000<br></code></pre></td></tr></table></figure><p>现在，我们将 ‘x’ 与  左移n位的 数字1 进行 AND 操作，就可以保留 'x’上第n位bit （对于 b0 来说是第0位）而将其他bit 清零。所以如果最终结果为0，表明对应bit 是0，最终结果不为0，表明对应bit置为1。</p><p>接下来给出一些例子，比如说 122 的第3rd bit 是否置为1，我们可以通过<code>122 &amp; (1&lt;&lt;3)</code>来实现，具体来说如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01111010<br>&amp;   00001000<br>    --------<br>    00001000<br></code></pre></td></tr></table></figure><p>可以看到最终结果不为0，因此122 对应的 3rd bit 是置为1的。</p><p>注意：在本文中，bit 的位数下标从0开始，也就是第0位bit，第1位bit ，…， 第7位 bit。</p><h1 id="3-将第n位-bit-置-1"><a class="markdownIt-Anchor" href="#3-将第n位-bit-置-1"></a> 3. 将第n位 bit 置 1</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">y = x | (1 &lt;&lt; n)<br></code></pre></td></tr></table></figure><p>这个 bit hack 结合了左移 (1&lt;&lt;n) 和 <strong>OR</strong> 运算的技巧，<code>y = x | (1&lt;&lt;n)</code>通过和一个第n位 置1 的数值进行 <strong>OR</strong> 运算就可以使得 ‘x’ 的第n位 置1。因为和 0 进行 OR-ing 数值保持不变，和 1 进行 OR-ing 对应bit变为1（如果不是1的话）。</p><p>同样给出一个例子，对于数120，我们希望将其 2nd bit 置为1，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01111000    (120 in binary)<br>|   00000100    (1&lt;&lt;2)<br>    --------<br>    01111100<br></code></pre></td></tr></table></figure><h1 id="4-将第n位-bit-置-0"><a class="markdownIt-Anchor" href="#4-将第n位-bit-置-0"></a> 4. 将第n位 bit 置 0</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">y = x &amp; ~(1&lt;&lt;n)<br></code></pre></td></tr></table></figure><p>这个bit hack 主要通过<code>y = x &amp; ~(1&lt;&lt;n)</code>实现，<code>~(1&lt;&lt;n)</code>起到的作用是将除了第n位置0，其余位置1，比如下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#">~1        11111110  (same as ~(1&lt;&lt;0))<br>~(1&lt;&lt;1)   11111101<br>~(1&lt;&lt;2)   11111011<br>~(1&lt;&lt;3)   11110111<br>~(1&lt;&lt;4)   11101111<br>~(1&lt;&lt;5)   11011111<br>~(1&lt;&lt;6)   10111111<br>~(1&lt;&lt;7)   01111111<br></code></pre></td></tr></table></figure><p>再通过 AND-ing 操作，就可以使得将 ‘x’ 的第n位置0，因为 AND-ing 中有个 bit 为0，结果 bit 就为0。下面给出数127，将第4位 bit 置0的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01111111    (127 in binary)<br>&amp;   11101111    (~(1&lt;&lt;4))<br>    --------<br>    01101111<br></code></pre></td></tr></table></figure><h1 id="5-反转第n位-bit"><a class="markdownIt-Anchor" href="#5-反转第n位-bit"></a> 5. 反转第n位 bit</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">y</span> = x ^ (<span class="hljs-number">1</span>&lt;&lt;n)<br></code></pre></td></tr></table></figure><p>这个bit hack 主要实现方式为<code>y = x ^ (1&lt;&lt;n)</code>，结合了左移和XOR 运算。<code>(1&lt;&lt;n)</code>将对应的第n位置1，而通过 XOR 运算，如果 ‘x’ 第n位为0，就会变为1，如果第n位为1，就会变为0，从而实现反转的效果。</p><p>下面给出一个例子，将 01110101 的第5位进行反转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01110101<br>^   00100000<br>    --------<br>    01010101<br></code></pre></td></tr></table></figure><h1 id="6-将最右边的1-bit置为0"><a class="markdownIt-Anchor" href="#6-将最右边的1-bit置为0"></a> 6. 将最右边的1-bit置为0</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">y</span> = x &amp; (x-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>该方式主要通过<code>y = x &amp; (x-1)</code>来实现。比如对于一个整数 001010<strong>1</strong>0（最右边的1用黑体标出），当将最后边的1-bit置为0后，就变成了001010<strong>0</strong>0（对应位变成了0）。</p><p>这里给出更多的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01011000    (x)<br>&amp;   01010111    (x-1)<br>    --------<br>    01010000<br><br>    10000000    (x = -128)<br>&amp;   01111111    (x-1 = 127 (with overflow))<br>    --------<br>    00000000<br><br>    11111111    (x = all bits 1)<br>&amp;   11111110    (x-1)<br>    --------<br>    11111110<br><br>    00000000    (x = no rightmost 1-bits)<br>&amp;   11111111    (x-1)<br>    --------<br>    00000000<br></code></pre></td></tr></table></figure><p>这是如何实现的呢，主要有两个可能的场景：</p><ol><li>该整数值存在一个最右边的1-bit。在这种情况下，当该数值减去1后，会将该二进制数的最右边的1-bit置为0，同时其右边所有低位的0变成1（就是一个减法得到的结果）。这个减法操作得到的结果，相当于已经把最右边的1-bit置0，然后再通过和原始值进行AND-ing 操作，就可以把低位的1都置为0。</li><li>当该二进制数不存在一个最右边的 1-bit（全为0）。那么在这种情况下，减1后会下溢，即所有 bit 置为 1 ，那么再和原始值（全0）进行AND-ing操作得到的也还是0。</li></ol><h1 id="7-只保留最右边的-1-bit"><a class="markdownIt-Anchor" href="#7-只保留最右边的-1-bit"></a> 7. 只保留最右边的 1-bit</h1><p class='note note-info'>y = x & (-x)</p><p>该方法通过<code>y = x &amp; (-x)</code>实现，将只保留 x 的最右边的 1-bit ，把其他位都置为0。比如对于 01010<strong>1</strong>00 (最右侧 1 用黑体标出)，得到的结果为 00000<strong>1</strong>00。</p><p>这里再给出更多的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01110000  (x)<br>&amp;   10010000  (-x)<br>    --------<br>    00010000<br><br>    00000001  (x)<br>&amp;   11111111  (-x)<br>    --------<br>    00000001<br><br>    10000000  (x = -128)<br>&amp;   10000000  (-x = -128)<br>    --------<br>    10000000<br><br>    11111111  (x = all bits one)<br>&amp;   00000001  (-x)<br>    --------<br>    00000001<br><br>    00000000  (x = all bits 0, no rightmost 1-bit)<br>&amp;   00000000  (-x)<br>    --------<br>    00000000<br></code></pre></td></tr></table></figure><p><strong>接下来探讨其实现原理。主要就是依赖于在计算机中， -x （对应的负数）跟 ~x+1 （按位取反后加1） 是一样的。</strong></p><p>不妨设 x 最右边的 1-bit 为b<sub>i</sub>，以下标 i 为界，将 b<sub>i</sub> 左侧的 bits 位设为 b<sub>i+1</sub>, …, b<sub>n</sub>，将 b<sub>i</sub> 右侧的所有 bits 位设为 b<sub>i-1</sub>, b<sub>i-2</sub> , … , b<sub>0</sub> （位于右侧的全为 0 ，因为 b<sub>i</sub> 是最右侧的 1 ）。</p><p>现在当我计算 -x ，首先做取反操作 ~x ，也就是将 b<sub>i</sub> 置为0， b<sub>i-1</sub>…b<sub>0</sub> 都置为 1，将 b<sub>i+1</sub> … b<sub>n</sub> 等位进行反转。然后做加 1 操作。因为 b<sub>i-1</sub>…b<sub>0</sub> 都为1，所以加 1 后会想 b<sub>i</sub> 进位（因为 b<sub>i</sub> 是第一个 0 bit ）。</p><p>此时我们不难发现，对于 -x ，b<sub>i+1</sub> … b<sub>n</sub> 等位反转了， b<sub>i</sub> 依然保持不变，b<sub>i-1</sub>…b<sub>0</sub> 也依然全为 0 。所以现在将 x 与 -x 进行 AND-ing 操作，就可以使得 b<sub>i+1</sub> … b<sub>n</sub> 置为 0 ，b<sub>i</sub> 保持 1， b<sub>i-1</sub>…b<sub>0</sub> 也全为 0 。只有一个 bit 保留了下来，就是最右边的 1-bit 。</p><h1 id="8-将最右边-1-bit-右侧的所有低位-bit-置-1"><a class="markdownIt-Anchor" href="#8-将最右边-1-bit-右侧的所有低位-bit-置-1"></a> <strong>8. 将最右边 1-bit 右侧的所有低位 bit 置 1</strong></h1><p class='note note-info'>y = x | (x-1)</p><p>具体实现就是 <code>y = x | (x-1)</code> 。这个翻译过来有点拗口，给个例子就能理解了，给出数 010<strong>1</strong>0000 ，执行后就得到 010<strong>11111</strong>，原来最右边 1-bit 右边的低位都置为1 。接下来看更多的一些例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C#">    10111100  (x)<br>|   10111011  (x-1)<br>    --------<br>    10111111<br><br>    01110111  (x)<br>|   01110110  (x-1)<br>    --------<br>    01110111<br><br>    00000001  (x)<br>|   00000000  (x-1)<br>    --------<br>    00000001<br><br>    10000000  (x = -128)<br>|   01111111  (x-1 = 127)<br>    --------<br>    11111111<br><br>    11111111  (x = -1)<br>|   11111110  (x-1 = -2)<br>    --------<br>    11111111<br><br>    00000000  (x)<br>|   11111111  (x-1)<br>    --------<br>    11111111<br></code></pre></td></tr></table></figure><p>这个方法的实现原理跟方法6很像，所以这里就不再证明了。</p><h1 id="9-保留最右边的-0-bit"><a class="markdownIt-Anchor" href="#9-保留最右边的-0-bit"></a> <strong>9. 保留最右边的 0-bit</strong></h1><p class='note note-info'>y = ~x & (x+1)</p><p>该方法的实现为<code>y = ~x &amp; (x+1)</code> 。该方法与方法7正好相反，它是找到最右侧的 0-bit，将其他位都置为0，将该 bit 置为 1 。距离来说，给定数 10101<strong>0</strong>11，经过处理后的结果为，00000<strong>1</strong>00。再给出更多的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01110111  (x)<br>    --------<br>    10001000  (~x)<br>&amp;   01111000  (x+1)<br>    --------<br>    00001000<br><br>    00000001  (x)<br>    --------<br>    11111110  (~x)<br>&amp;   00000010  (x+1)<br>    --------<br>    00000010<br><br>    10000000  (x = -128)<br>    --------<br>    01111111  (~x)<br>&amp;   10000001  (x+1)<br>    --------<br>    00000001<br><br>    11111111  (x = no rightmost 0-bit)<br>    --------<br>    00000000  (~x)<br>&amp;   00000000  (x+1)<br>    --------<br>    00000000<br><br>    00000000  (x)<br>    --------<br>    11111111  (~x)<br>&amp;   00000001  (x+1)<br>    --------<br>    00000001<br></code></pre></td></tr></table></figure><p><strong>接下来给出证明</strong>。与之前类似，不妨设最右边的 0-bit 设置为 b<sub>i</sub> ，将 b<sub>i</sub> 左侧的 bits 位设为 b<sub>i+1</sub>, …, b<sub>n</sub>，将 b<sub>i</sub> 右侧的所有 bits 位设为 b<sub>i-1</sub>, b<sub>i-2</sub> , … , b<sub>0</sub> （位于右侧的全为 1 ，因为 b<sub>i</sub> 是最右侧的 0 ）。</p><p>那么对于 ~x 来说，将所有位进行反转，包括最右侧的 0-bit，b<sub>i</sub> 也从 0 变成了 1 。</p><p>对于 x+1 来说，因为 b<sub>i-1</sub>, b<sub>i-2</sub> , … , b<sub>0</sub> 全为1，加 1 之后会向 b<sub>i</sub> 进位，因此 b<sub>i</sub> 也变成了 1，b<sub>i-1</sub>, b<sub>i-2</sub> , … , b<sub>0</sub> 都变成了0，而高位  b<sub>i+1</sub>, …, b<sub>n</sub> 保持不变。</p><p>此时再将 ~x 与 x+1 进行 AND-ing 操作，就只有 b<sub>i</sub> 位保留下来，其他位均为 0 。</p><h1 id="10-将最右侧的-0-bit-置为1"><a class="markdownIt-Anchor" href="#10-将最右侧的-0-bit-置为1"></a> <strong>10. 将最右侧的 0-bit 置为1</strong></h1><p class='note note-info'>y = x | (x+1)</p>该方法实现为 `y = x | (x+1)`。主要就是将最右侧的 0-bit 置为1，例如对于数 10100**0**11 经过运算后，得到结果 10100**1**11。给出更多的例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C#">    10111100  (x)<br>|   10111101  (x+1)<br>    --------<br>    10111101<br><br>    01110111  (x)<br>|   01111000  (x+1)<br>    --------<br>    01111111<br><br>    00000001  (x)<br>|   00000010  (x+1)<br>    --------<br>    00000011<br><br>    10000000  (x = -128)<br>|   10000001  (x+1)<br>    --------<br>    10000001<br><br>    11111111  (x = no rightmost 0-bit)<br>|   00000000  (x+1)<br>    --------<br>    11111111<br><br>    00000000  (x)<br>|   00000001  (x+1)<br>    --------<br>    00000001<br></code></pre></td></tr></table></figure><p>正确性也非常好理解。x+1 的操作将原来 x 的最右侧的 0-bit， b<sub>i</sub> 置为1，b<sub>i-1</sub>, b<sub>i-2</sub> , … , b<sub>0</sub> 都变成了0，而高位  b<sub>i+1</sub>, …, b<sub>n</sub> 保持不变。此时再和 x 做 OR-ing 运算，就可以使得原来 x 的最右侧 0-bit  b<sub>i</sub> 置为 1。</p><h1 id="bonus"><a class="markdownIt-Anchor" href="#bonus"></a> Bonus</h1><p>一个简单的C语言函数，实现打印一个数字的低8位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">int_to_bin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> str[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">7</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>    str[i] = (num&amp;<span class="hljs-number">1</span>)?<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;<br>    num &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>椭圆曲线公钥恢复算法与SM2编程实现</title>
    <link href="/2021/12/13/2021-12-13%20%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95%E4%B8%8ESM2%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/12/13/2021-12-13%20%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95%E4%B8%8ESM2%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="椭圆曲线公钥恢复算法"><a class="markdownIt-Anchor" href="#椭圆曲线公钥恢复算法"></a> 椭圆曲线公钥恢复算法</h1><p>在以太坊中，交易消息中不包含“from”字段（即交易发起者的地址），这是因为交易发起者的公钥可以直接从ECDSA签名中计算出来。而一旦你有公钥，就可以很容易地计算出对应的地址。恢复签名者公钥的过程称为公钥恢复，对应的算法即为公钥恢复算法。</p><p>接下来描述以太坊中公钥恢复算法的过程。</p><p>首先根据给定 ECDSA签名算法 中计算的值 <strong>r</strong> 和 <strong>s</strong>，我们可以计算得到两个可能的公钥。我们根据签名中的 <strong>x</strong> 坐标 <strong>r</strong> 值计算两个椭圆曲线点 <strong>R</strong> 和 <strong>R’</strong>。对于 r 值，计算它关于 n 的逆元 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">r^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，其中 n 是椭圆曲线的阶数。最后计算 e ，它是消息的散列值。然后可以得到两个可能的公钥：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>1</mn></msub><mo>=</mo><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>s</mi><mi>R</mi><mo>−</mo><mi>e</mi><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_1 = r^{-1} (sR - eG)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>2</mn></msub><mo>=</mo><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>s</mi><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup><mo>−</mo><mi>e</mi><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_2 = r^{-1} (sR&#x27; - eG)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span></span></p><p>其中:</p><ul><li><p>K<sub>1</sub> 和 K<sub>2</sub> 是签名者公钥的两种可能性</p></li><li><p>r<sup>-1</sup>是签名的 r 值的逆元</p></li><li><p>s 是签名的 s 值</p></li><li><p>R 和 R’ 是临时公钥 Q 的两种可能性</p></li><li><p>e 是消息散列的最低位</p></li><li><p>G 是椭圆曲线生成点</p></li></ul><p>为了使计算更有效率，在以太坊交易签名里包括一个前缀值 v，它告诉我们两个可能的R值中哪一个是真正临时的公钥。如果 v 是偶数，那么R是正确的值。如果 v 是奇数，那么选择R’。这样，我们只需要计算R的一个值。这也就是以太坊交易中签名数据的（v, r, s）。</p><h2 id="椭圆曲线上点的压缩"><a class="markdownIt-Anchor" href="#椭圆曲线上点的压缩"></a> 椭圆曲线上点的压缩</h2><p>在上述过程，有一个地方可能还没有解释清楚，那就是为什么一个 x 坐标会对应有两个椭圆曲线上的点？其实这里用到了椭圆曲线上点的压缩和解压缩方法。</p><p>根据椭圆曲线方程，我们只需要知道 x 坐标，就可以通过方程计算出 y 坐标，这样就不用同时保存x，y的值，减少了存储和带宽。但是如果只知道x，带入方程会求出两个y，一正一负，对应两个不同的点，所以还必须有一个标志来区别实际使用的是哪个。在以太坊中就采用了压缩公钥格式，具体格式为：</p><ul><li>前缀02 + x （当y为偶数）</li><li>前缀03 + x （当y为奇数）</li></ul><p>为什么y一定是一奇一偶呢，刚刚不是说一正一负吗？</p><p>假设 y 是方程的一个解，那么 -y 也是方程的一个解，但在模运算的规则下，<code>-y ≡ p - y (mod p)</code>，所以 p-y 也是方程的解，y-p 也是方程的解，但是在mod p 的有限域中，取值范围是[0, p-1]，没有负数，所以 -y 和 y-p 在椭圆曲线上取不到，最终得到就是两个解 y 和 p-y，因为p是大素数，所以 y 和 p-y 一定是一奇一偶。</p><p>在<a href="http://www.oscca.gov.cn/sca/xxgk/2010-12/17/1002386/files/b791a9f908bb4803875ab6aeeb7b4e03.pdf">《SM2椭圆曲线公钥密码算法》</a>中也谈及了椭圆曲线上点的压缩和解压缩方法，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204090.(null)" alt="椭圆曲线上点的压缩与解压缩" /></p><h2 id="椭圆曲线签名过程"><a class="markdownIt-Anchor" href="#椭圆曲线签名过程"></a> 椭圆曲线签名过程</h2><p>在推导椭圆曲线公钥算法之前，还需要先回顾了解下椭圆曲线的签名过程。</p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204793.(null)" alt="椭圆曲线签名过程" style="zoom:67%;" /><ol><li>随机选择一个临时私钥 k 值，范围在 [1, n-1]，其中 n 为椭圆曲线的阶数</li><li>计算临时公钥 kG = (x , y)</li><li>计算 r 值， r = x mod n，如果 r 为0则返回第1步重新选择私钥 k</li><li>计算消息散列值，e = H(m)</li><li>计算 s 值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><msup><mi>k</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>e</mi><mo>+</mo><mi>d</mi><mi>r</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">s = k^{-1} (e + dr) \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span>，其中 d 是签名者的私钥，如果算得 s 为0则返回第一步重新选择 k</li><li>最终得到签名 (r, s)</li></ol><p>对应签名的验证过程如下：</p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204418.(null)" alt="椭圆曲线签名的验证过程" style="zoom:67%;" /><ol><li>检验 r, s 是否满足取值范围 [1, n-1]</li><li>计算消息散列值， e  = H(m)</li><li>计算 s 的逆元，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>=</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">w = s^{-1} \ mod\  n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span></li><li>计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>=</mo><mi>e</mi><mi>w</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mi mathvariant="normal">，</mi><msub><mi>u</mi><mn>2</mn></msub><mo>=</mo><mi>r</mi><mi>w</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">u_1 = ew \ mod \ n，u_2 = rw \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span></li><li>计算 $ X = (x, y) = u_1G + u_2Q$。 其中G是生成元，Q是签名者的公钥。如果X为无穷远点则验签失败。</li><li>计算 v = x mod n</li><li>如果 v = r 则验签成功，否则失败</li></ol><p>椭圆曲线签名和验证的正确性证明如下所示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>≡</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>e</mi><mo>+</mo><mi>d</mi><mi>r</mi><mo stretchy="false">)</mo><mo>≡</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>e</mi><mo>+</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>r</mi><mi>d</mi><mo>≡</mo><mi>w</mi><mi>e</mi><mo>+</mo><mi>w</mi><mi>r</mi><mi>d</mi><mo>≡</mo><msub><mi>u</mi><mn>1</mn></msub><mo>+</mo><msub><mi>u</mi><mn>2</mn></msub><mi>d</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k ≡ s^{-1}(e + dr) ≡ s^{-1}e + s^{-1}rd ≡we + wrd ≡ u_1 + u_2d (mod \ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.947438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>=</mo><msub><mi>u</mi><mn>1</mn></msub><mi>G</mi><mo>+</mo><msub><mi>u</mi><mn>2</mn></msub><mi>Q</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>u</mi><mn>1</mn></msub><mo>+</mo><msub><mi>u</mi><mn>2</mn></msub><mi>d</mi><mo stretchy="false">)</mo><mi>G</mi><mo>=</mo><mi>k</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">X = u_1G + u_2Q = (u_1+u_2d)G = kG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">G</span></span></span></span></span></p><p>即验签时计算的X与签名时的临时公钥是相等的，对应的 x 坐标也相等，所以验签时判断 v 值是否等于 r 值即可。</p><h2 id="椭圆曲线公钥恢复算法推导"><a class="markdownIt-Anchor" href="#椭圆曲线公钥恢复算法推导"></a> 椭圆曲线公钥恢复算法推导</h2><p>好的，前序准备都已经完成，现在来推导公钥恢复算法，这里主要用到了签名过程中的相关计算。</p><p>设临时公钥为R，即R = kG</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><msup><mi>k</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>e</mi><mo>+</mo><mi>d</mi><mi>r</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mspace width="1em"/><mo>⇒</mo><mspace width="1em"/><mi>k</mi><mo>=</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>e</mi><mo>+</mo><mi>d</mi><mi>r</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">s = k^{-1} (e + dr) \ mod \ n  \quad ⇒ \quad k = s^{-1} (e + dr) \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>G</mi><mo>=</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>e</mi><mo>+</mo><mi>d</mi><mi>r</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>G</mi><mspace width="1em"/><mo>⇒</mo><mspace width="1em"/><mi>R</mi><mo>=</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>e</mi><mi>G</mi><mo>+</mo><mi>r</mi><mi>Q</mi><mo stretchy="false">)</mo><mspace width="1em"/><mo>⇒</mo><mspace width="1em"/><mi>Q</mi><mo>=</mo><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>s</mi><mi>R</mi><mo>−</mo><mi>e</mi><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">kG = s^{-1} (e + dr) \ G  \quad ⇒ \quad R = s^{-1}(eG+rQ) \quad ⇒ \quad Q = r^{-1}(sR-eG)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span></span></p><p>因为通过 r 值可以计算逆元 r<sup>-1</sup>，s 值已知，消息散列e和生成元G已知，临时公钥 R 可以通过 r（对应公钥的x坐标）利用椭圆曲线上点的解压缩方法求解，因此公钥 Q 是可以被计算出来的。</p><p>在 <a href="http://www.secg.org/sec1-v2.pdf">椭圆曲线标准</a> 中也描述了普通椭圆曲线公钥恢复算法的实现，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204527.(null)" alt="椭圆曲线标准中定义的公钥恢复算法" /></p><h1 id="sm2公钥恢复算法编程实现"><a class="markdownIt-Anchor" href="#sm2公钥恢复算法编程实现"></a> SM2公钥恢复算法编程实现</h1><p>因为SM2公钥签名算法和以太坊上椭圆曲线的签名算法不太一样，所以需要先了解SM2的签名过程，然后再推导SM2对应的公钥恢复算法。</p><h2 id="sm2签名与验证过程"><a class="markdownIt-Anchor" href="#sm2签名与验证过程"></a> SM2签名与验证过程</h2><p>根据官方的 <a href="http://www.oscca.gov.cn/sca/xxgk/2010-12/17/1002386/files/b791a9f908bb4803875ab6aeeb7b4e03.pdf">SM2 椭圆曲线公钥密码算法</a> 可以找到SM2算法的签名过程。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204885.(null)" alt="SM2签名计算过程" /></p><ul><li>设待签名的消息为M，为了获取消息M的数字签名(r,s)，作为签名者的用户A应实现以下运算步骤：</li></ul><ol><li>置  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><msub><mi>Z</mi><mi>A</mi></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">\overline{M} = Z_A || M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></li><li>计算消息散列值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e = H(\overline{M})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，并将e的数据类型转换为整数</li><li>用随机数发生器产生随机数 k，取值范围 [1, n-1]</li><li>计算椭圆曲线上的点（也就是临时公钥），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">(x_1,y_1) = kG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">G</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">将</mi></mrow><annotation encoding="application/x-tex">，并将</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">将</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>$数据类型转换为整数</li><li>计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mo stretchy="false">(</mo><mi>e</mi><mo>+</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">r = (e+x_1) \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span>，若 r = 0 或 r+k = n 则 返回第3步，重新选择k</li><li>计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msub><mi>d</mi><mi>A</mi></msub><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mo separator="true">⋅</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mi>r</mi><mtext> </mtext><mo separator="true">⋅</mo><mtext> </mtext><msub><mi>d</mi><mi>A</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">s = ((1 + d_A)^{-1} \ · \ (k-r\ ·\ d_A ) ) \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span>，若s = 0 则返回第3步</li><li>将r、s类型转换为字符串，得到消息M的签名(r, s)</li></ol><p>SM2数字签名的算法流程图如下所示。</p><center><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204893.(null)" width="60%" height="60%" align="middle" > </center><p><strong>SM2验证过程</strong></p><ul><li>为了检验收到消息M’及其数字签名(r’,s’)，作为验证者的用户B应实现以下运算步骤：</li></ul><ol><li>检验 r’ 是否在 [1, n-1] 范围内</li><li>检验 s’ 是否在 [1, n-1] 范围内</li><li>置$$\overline{M}’ = Z_A \ || \  M’$$</li><li>计算消息散列值，$$e = H(\overline{M}’)$$，并将e的数据类型转换为整数</li><li>将 r’ , s’ 数据类型转换为整数，计算 $$t = (r’ + s’) \ mod \ n$$</li><li>计算椭圆曲线点 $$(x_1’, y_1’) = [s’]G + [t]P_A$$</li><li>计算$$R = (e’ + x_1’) \ mod \ n$$，检验 R = r’ 是否成立，如果成立则验证通过，否则验证不通过</li></ol><p>SM2数字签名的验证过程如下图所示。</p><center><img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=NDYyZjBkZGZiODc4OWE3Y2E3YTc2YmJlYWIwMTY0OThfa1FUVDVtZzNubmI4bVh4cVd5SzA2OFhoa2xQVW1NWnRfVG9rZW46Ym94Y25OckpUY3E0c3gzRmVSUGh0N1hRbzBjXzE2Mzk0MDQyNTM6MTYzOTQwNzg1M19WNA" width="60%" height="60%" align="middle" > </center><h2 id="sm2公钥恢复算法"><a class="markdownIt-Anchor" href="#sm2公钥恢复算法"></a> SM2公钥恢复算法</h2><p>跟椭圆曲线中方法类似，从SM2签名算法的相关计算中，可以推导出对应的公钥恢复算法 。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msub><mi>d</mi><mi>A</mi></msub><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mo separator="true">⋅</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mi>r</mi><mtext> </mtext><mo separator="true">⋅</mo><mtext> </mtext><msub><mi>d</mi><mi>A</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mspace width="1em"/><mo>⇒</mo></mrow><annotation encoding="application/x-tex">s = ((1 + d_A)^{-1} \ · \ (k-r\ ·\ d_A ) ) \ mod \ n \quad ⇒  </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">⇒</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/><mi>k</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msub><mi>d</mi><mi>A</mi></msub><mo stretchy="false">)</mo><mi>s</mi><mo>+</mo><mi>r</mi><msub><mi>d</mi><mi>A</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><msub><mi>d</mi><mi>A</mi></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">\quad k= (1+d_A)s + rd_A = (s + (s+r)d_A) \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span></span></p><p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>=</mo><mi>k</mi><mi>G</mi><mspace width="1em"/><mspace width="1em"/><mi>t</mi><mo>=</mo><mi>r</mi><mo>+</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">R = kG \quad\quad t = r+s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><msub><mi>d</mi><mi>A</mi></msub><mo stretchy="false">)</mo><mi>G</mi><mspace width="1em"/><mo>⇒</mo><mspace width="1em"/><mi>R</mi><mo>=</mo><mi>s</mi><mi>G</mi><mo>+</mo><mi>t</mi><msub><mi>P</mi><mi>A</mi></msub><mspace width="1em"/><mo>⇒</mo><mspace width="1em"/><msub><mi>P</mi><mi>A</mi></msub><mo>=</mo><msup><mi>t</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mi>s</mi><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">kG = (s+(s+r)d_A)G \quad ⇒ \quad R = sG+tP_A \quad ⇒ \quad P_A = t^{-1}(R-sG)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span></span></p><p>因为r，s值可以计算得到t，进而得到t的逆元 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>t</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">t^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，R 可以通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mi>r</mi><mo>−</mo><mi>e</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">x_1 = r - e \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span>，并利用椭圆曲线的压缩方法计算得到。s和G也都已知，因此，是可以计算得到公钥<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">P_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><h2 id="代码结构说明"><a class="markdownIt-Anchor" href="#代码结构说明"></a> 代码结构说明</h2><center><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204132.(null)" width="30%" height="30%" align="middle" > </center>附件代码结构如上图所示：<ul><li>cryptopp：该目录是开源库CryptoPP 的文件目录</li><li>test：测试文件目录，存放测试类TestCrypto，主要测试CryptoPP的相关API，模拟椭圆曲线的签名、验证以及公钥恢复算法；还有就是测试自定义实现的SM2 的签名、验证以及公钥恢复算法</li><li>util：该目录下，util类是cryptopp方法的封装，SM2是自定义实现类</li><li>main.cpp：实现测试函数</li></ul><h2 id="编程实现说明"><a class="markdownIt-Anchor" href="#编程实现说明"></a> 编程实现说明</h2><p>当了解了算法原理之后，实现起来就比较容易了，只要根据公式进行编程即可。在实现上借助了开源的CryptoPP库，来支持密码学里中原语操作，比如有限域上的计算，椭圆曲线上点的运算等。代码上主要是实现了一个<code>SM2</code>类，定义了签名，验证和公钥恢复算法，具体的代码实现这里不再展示，可见代码附件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 借助CryptoPP开源库 实现 SM2算法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SM2</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 签名：输入的消息和输出的签名数据  均为字节格式，签名是由(r,s)各32字节拼接得到的</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sign</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;message, std::string &amp;signature)</span></span>;<br>    <span class="hljs-comment">// 验证：输入的消息和签名均为字节格式，输出为bool值</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Verify</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;message, <span class="hljs-keyword">const</span> std::string &amp;signature)</span></span>;<br>    <span class="hljs-comment">// 公钥恢复算法，输入消息，签名（r,s），y值是否为奇数， 输出pubKey 字节格式，由(x,y) 各32字节拼接而成</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RecoverPublicKey</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;message, <span class="hljs-keyword">bool</span> isOdd,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-keyword">const</span> Integer &amp;r, <span class="hljs-keyword">const</span> Integer &amp;s, std::string &amp;pubKey)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">private</span>:</span><br><span class="hljs-function">    std::shared_ptr&lt;ECP&gt; ecp;</span>                   <span class="hljs-comment">// SM2 对应的椭圆曲线</span><br>    std::shared_ptr&lt;Integer&gt; p;<br>    std::shared_ptr&lt;Integer&gt; a;<br>    std::shared_ptr&lt;Integer&gt; b;<br>    std::shared_ptr&lt;Integer&gt; privateKey;        <span class="hljs-comment">// 私钥</span><br>    std::shared_ptr&lt;ECPPoint&gt; publicKey;        <span class="hljs-comment">// 公钥，以Point表示</span><br>    std::shared_ptr&lt;ECPPoint&gt; generator;        <span class="hljs-comment">// 生成元 点</span><br>    std::shared_ptr&lt;Integer&gt; n;                 <span class="hljs-comment">// 生成元 对应的阶数</span><br>    std::string ZA;                             <span class="hljs-comment">// 杂凑值，字节形式 ：ZA = H256(ENTL_A ∥ ID_A ∥ a ∥ b ∥ xG ∥ yG ∥ xA ∥ yA)</span><br><br>    <span class="hljs-comment">// 默认构造函数，使用官方参数</span><br>    <span class="hljs-built_in">SM2</span>();<br>    <span class="hljs-comment">// 初始化曲线参数，使用官方参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 计算杂凑值 ZA</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ComputeZA</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>测试代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 测试 SM2 类</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TestCrypto::Test_SM2</span><span class="hljs-params">()</span> </span>&#123;<br>    SM2 sm2;<br>    std::string message = <span class="hljs-string">&quot;message digest&quot;</span>;<br>    std::string signature;<br>    Integer k = Util::<span class="hljs-built_in">StringToInteger</span>(<span class="hljs-string">&quot;59276E27D506861A16680F3AD9C02DCCEF3CC1FA3CDBE4CE6D54B80DEAC1BC21&quot;</span>);<br>    sm2.<span class="hljs-built_in">Sign</span>(message, signature, k);<br><br>    Integer r = Util::<span class="hljs-built_in">StringToInteger</span>(Util::<span class="hljs-built_in">HexEncode</span>(signature.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>)));<br>    Integer s = Util::<span class="hljs-built_in">StringToInteger</span>(Util::<span class="hljs-built_in">HexEncode</span>(signature.<span class="hljs-built_in">substr</span>(<span class="hljs-number">32</span>,<span class="hljs-number">32</span>)));<br><br>    <span class="hljs-comment">// 打印输出，对照真实数据</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————————测试SM2 签名算法——————————————&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;真实 r:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;F5A03B0648D2C4630EEAC513E1BB81A15944DA3827D5B74143AC7EACEEE720B3&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;计算 r:&quot;</span> &lt;&lt; Util::<span class="hljs-built_in">HexEncode</span>(signature.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>)) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;真实 s:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;B1B6AA29DF212FD8763182BC0D421CA1BB9038FD1F7F42D4840B69C485BBC1AA&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;计算 s:&quot;</span> &lt;&lt; Util::<span class="hljs-built_in">HexEncode</span>(signature.<span class="hljs-built_in">substr</span>(<span class="hljs-number">32</span>,<span class="hljs-number">32</span>)) &lt;&lt; endl;<br><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————————测试SM2 验证签名——————————————&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;message: &quot;</span> &lt;&lt; message &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;r: &quot;</span> &lt;&lt; Util::<span class="hljs-built_in">IntegerToString</span>(r) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;s: &quot;</span> &lt;&lt; Util::<span class="hljs-built_in">IntegerToString</span>(s) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;签名验证结果: &quot;</span> &lt;&lt; boolalpha &lt;&lt; sm2.<span class="hljs-built_in">Verify</span>(message, signature ) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————————测试SM2 公钥恢复算法——————————————&quot;</span> &lt;&lt; endl;<br><br>    std::string pubKey;<br>    sm2.<span class="hljs-built_in">RecoverPublicKey</span>(message,<span class="hljs-literal">false</span>, r, s,pubKey);<br>    <span class="hljs-function">ECP::Point <span class="hljs-title">P</span><span class="hljs-params">(Util::StringToInteger(Util::HexEncode(pubKey.substr(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>))),</span></span><br><span class="hljs-params"><span class="hljs-function">                 Util::StringToInteger(Util::HexEncode(pubKey.substr(<span class="hljs-number">32</span>,<span class="hljs-number">32</span>))))</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;真实公钥 P.x:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;09F9DF311E5421A150DD7D161E4BC5C672179FAD1833FC076BB08FF356F35020&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;恢复公钥 P.x:&quot;</span> &lt;&lt; Util::<span class="hljs-built_in">IntegerToString</span>(P.x) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;真实公钥 P.y:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;CCEA490CE26775A52DC6EA718CC1AA600AED05FBF35E084A6632F6072DA9AD13&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;恢复公钥 P.y:&quot;</span> &lt;&lt; Util::<span class="hljs-built_in">IntegerToString</span>(P.y) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试数据来自：<a href="https://blog.csdn.net/beebeeyoung/article/details/91063358">SM2 自检数据</a></p><p>测试结果如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204273.(null)" alt="测试结果输出" /></p><p class="note note-primary">代码上传至Github仓库：https://github.com/2017zhangyuxuan/Learn-Blockchain</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p><a href="http://www.oscca.gov.cn/sca/xxgk/2010-12/17/1002386/files/b791a9f908bb4803875ab6aeeb7b4e03.pdf">SM2 椭圆曲线公钥密码算法</a></p><p><a href="https://blog.csdn.net/beebeeyoung/article/details/91063358">SM2 自检数据</a></p><p><a href="http://www.gmbz.org.cn/main/viewfile/2018010802371372251.html">SM2 官方参数定义</a></p><p><a href="https://github.com/inoutcode/ethereum_book/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0.asciidoc#%E7%AD%BE%E5%90%8D%E5%89%8D%E7%BC%80%E5%80%BCv%E5%92%8C%E5%85%AC%E9%92%A5%E6%81%A2%E5%A4%8D">以太坊：签名前缀值（v）和公钥恢复</a></p><p><a href="https://www.cryptopp.com/docs/ref/class_integer.html">CryptoPP 官方文档</a></p><p><a href="http://www.secg.org/sec1-v2.pdf">椭圆曲线标准</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SM2</tag>
      
      <tag>椭圆曲线密码算法</tag>
      
      <tag>公钥恢复算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题04】椭圆曲线密码算法在比特币中的应用</title>
    <link href="/2021/11/27/2021-11-27%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9804-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E5%9C%A8%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2021/11/27/2021-11-27%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9804-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E5%9C%A8%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li>不同于以太坊的账户模型，比特币采用的是UTXO模型，比特币的所有权是通过<em>数字密钥、比特币地址和数字签名</em>来确定的。数字密钥实际上并不存储在网络中，而是由用户生成之后，存储在一个叫做<em>钱包</em>的文件或简单的数据库中。用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问互联网。</li><li>密钥是成对出现的，由私钥和公钥所组成。公钥就像银行的帐号，而私钥就像银行卡的密码或支票的签名。比特币的用户很少会直接看到数字密钥。一般情况下，它们存储在钱包文件内，由比特币钱包软件进行管理。</li><li>在比特币交易的支付环节，收款人的公钥由数字指纹表示，称为<em>比特币地址</em>，就像支票上收款人名称 （即“付给谁的账户”）。一般情况下，比特币地址由公钥生成并与之对应。然而，并非所有比特币地址都代表公钥； 也可以代表其他支付对象，譬如脚本。这样一来，比特币地址就可以抽象成资金接收者，使得交易更灵活，就像纸质支票：可以支付到个人账户或公司账户，也可以支付账单和现金。比特币地址是密钥被用户能够看到的唯一形式，因为这个地址就是需要告诉别人的。</li><li>以上是对比特币和密码学应用的简单概述，而本篇文章将重点关注椭圆曲线密码算法在比特币中的应用，将从与之密切相关的密钥与地址、钱包、交易三部分介绍相关内容。</li></ul><h1 id="密钥与地址"><a class="markdownIt-Anchor" href="#密钥与地址"></a> 密钥与地址</h1><ul><li>在比特币系统中，我们用公钥密码学技术创建一个密钥对，用于控制对比特币的访问。密钥对包括一个私钥，和由其衍生出的唯一的公钥。公钥用于接收比特币，而私钥用于支付时进行交易签名。</li><li>比特币正是使用椭圆曲线密码算法作为其公钥密码学的基础。</li></ul><h2 id="私钥与公钥与地址"><a class="markdownIt-Anchor" href="#私钥与公钥与地址"></a> 私钥与公钥与地址</h2><p>一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。私钥（<em>k</em>）是一个数字，通常是随机选出的。基于私钥，我们就可以使用椭圆曲线乘法这个单向密码函数产生一个公钥（<em>K</em>）。基于公钥（<em>K</em>），我们就可以使用一个单向密码哈希函数生成比特币地址（<em>A</em>）。私钥、公钥和比特币地址之间的关系如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271547812.(null)" alt="私钥、公钥和比特币地址之间的关系" /></p><h2 id="私钥"><a class="markdownIt-Anchor" href="#私钥"></a> 私钥</h2><ul><li><p>私钥就是一个随机选出的数字而已。拥有和控制了私钥，就相当于控制了该私钥对应的比特币地址中的所有资金。通过证明比特币交易中资金的所有权，私钥可以生成花费该笔资金的签名。</p></li><li><p><em><strong>从一个随机数生成私钥</strong></em> 是生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源。生成一个比特币私钥在本质上与“在1到2<sup>256</sup>之间选一个数字”无异。只要选取的结果是不可预测或不可重复的，那么选取数字的具体方法并不重要。比特币软件使用操作系统底层的随机数生成器来产生256位的熵（随机性）。</p></li><li><p>更准确地说，私钥可以是1和n-1之间的任何数字，其中n是一个常数（n=1.158 * 10<sup>77</sup>，略小于2<sup>256</sup>），并被定义为由比特币所使用的椭圆曲线的阶（比特币使用的是 <strong>secp256k1</strong> 标准所定义的一种特殊的椭圆曲线和一系列数学常数。该标准由美国国家标准与技术研究院 （NIST）建立）。要生成这样的一个私钥，我们随机选择一个256位的数字，并检查它是否小于n-1。从编程的角度来看，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。如果运算结果小于n，我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。</p></li><li><h2 id="公钥"><a class="markdownIt-Anchor" href="#公钥"></a> 公钥</h2></li></ul><p>以一个随机生成的私钥<em>k</em>为起点，将其乘以曲线上一个预定的点，叫做<em>生成点G</em>得到曲线上的另一点，这就是相应的公钥 <em>K</em>。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>=</mo><mi>k</mi><mo>∗</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">K = k * G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span></span></p><p>其中<em>k</em>是私钥，<em>G</em>是生成点，在该曲线上所得的点<em>K</em>是公钥。因为所有比特币用户的生成点是相同的，一个私钥<em>k</em>乘以<em>G</em>将得到相同的公钥<em>K</em>。<em>k</em>和<em>K</em>之间的关系是固定的，但只能单向运算，即从<em>k</em>得到<em>K</em>。这就是可以把比特币地址（<em>K</em>的衍生） 与任何人共享而不会泄露私钥（<em>k</em>）的原因。</p><p>实现了椭圆曲线乘法，我们就可以用随机产生的私钥<em>k</em>和与生成点<em>G</em>相乘得到公钥<em>K</em>。下面给出一个简单例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash">k = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD <br>K = k * G<br><br>公钥K被定义为一个点 K = (x, y) ，其中：<br>x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A <br>y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB<br></code></pre></td></tr></table></figure><h2 id="比特币地址"><a class="markdownIt-Anchor" href="#比特币地址"></a> 比特币地址</h2><p>比特币地址可由公钥经过单向哈希算法得到。密码学哈希算法是一种单向函数，接收任意长度的输入产生指纹或哈希。哈希函数在比特币中被广泛使用 ：比特币地址、脚本地址以及在挖矿中的工作量证明算法。由公钥生成比特币地址时使用的算法是Secure Hash Algorithm (SHA)和the RACE Integ rity Primitives Evaluation Message Digest (RIPEMD)，具体来说是SHA256和RIPEMD160。</p><p>以公钥 <em>K</em> 为输入，计算其SHA256哈希值，并以此结果计算RIPEMD160 哈希值，得到一个长度为160位（20字节）的数字：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>R</mi><mi>I</mi><mi>P</mi><mi>E</mi><mi>M</mi><mi>D</mi><mn>160</mn><mo stretchy="false">(</mo><mi>S</mi><mi>H</mi><mi>A</mi><mn>256</mn><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A = RIPEMD160(SHA256(K))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">1</span><span class="mord">6</span><span class="mord">0</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">A</span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p>公式中，<em>K</em>是公钥，<em>A</em>是生成的比特币地址。</p><p>通常用户见到的比特币地址是经过“<strong>Base58Check</strong>”编码的（参见下面的“Base58Check Encoding”一图），这种编码使用了58个字符（Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。Base58Check编码也被用于比特币的其它地方，例如比特币地址、私钥、加密的密钥和脚本哈希中，用来提高可读性和录入的正确性。</p><center class="half"> <img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271513682.(null)" width="300"></img><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271513117.(null)" width="400"></img></center><hr /><ul><li><strong>WIF(Wallet import format)</strong> 钱包导入格式，(也被称为电子钱包的导出格式)是一种私有的 ESCDSA (椭圆曲线签名算法) 秘钥，意在使私钥更容易复制，私钥的各种形式如下表所示。</li></ul><table><thead><tr><th>Type</th><th>Prefix</th><th>Description</th></tr></thead><tbody><tr><td>Raw</td><td>None</td><td>32字节</td></tr><tr><td>Hex</td><td>None</td><td>64位Hex编码</td></tr><tr><td>WIF</td><td>5</td><td>使用Base58Check进行编码</td></tr><tr><td>WIF-compressed</td><td>K or L</td><td>使用Base58Check进行编码，但在编码前增加后缀0x01</td></tr></tbody></table><table><thead><tr><th style="text-align:left">Format</th><th>Private key</th></tr></thead><tbody><tr><td style="text-align:left">Hex</td><td>1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</td></tr><tr><td style="text-align:left">WIF</td><td>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</td></tr><tr><td style="text-align:left">WIF-compressed</td><td>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</td></tr></tbody></table><ul><li>公钥也可以用多种不同格式来表示，通常分为非压缩格式或压缩格式公钥这两种形式。</li><li>我们从前文可知，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256位的数字。其中一个256位数字是公钥的x坐标，另一个256位数字是y坐标。前缀04是是非压缩格式公钥， 压缩格式公钥是以02或者03开头。</li><li>正如前面所说，一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程来得到y坐标。这可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256位。这样每笔交易需要的字节数就会减少许多，随着时间推移，就能保存更多的交易数据。</li><li>未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。为什么会有两个前缀：当<strong>我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是偶数或者奇数</strong>。因此，为了区分y坐标的两种可能值，在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以让软件能够根据x坐标，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上点的完整坐标。下图阐释了公钥压缩的过程：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271547830.(null)"  height="50%" width="50%" align="center"> </img></p><p class="note note-primary"> 注意：实际上“压缩格式私钥”是一种名称上的误导，因为当私钥使用WIF压缩格式导出时，不但没有压缩，反而比“非压缩格式”私钥长出一个字节。这个多出来的一个字节是私钥被加了后缀01，用以表明该私钥是来自于一个较新的钱包，只能被用来生成压缩公钥。私钥并没有压缩的，也不能被压缩。“压缩私钥”实际上表示“只能生成压缩公钥的私钥”，而“非压缩私钥”用来表明“只能生成非压缩公钥的私钥”。为避免更多误解，应该只可以说导出格式 是“WIF压缩格式”或者“WIF”，而不能说这个私钥是“压缩”的。</p><h1 id="钱包"><a class="markdownIt-Anchor" href="#钱包"></a> 钱包</h1><ul><li>广义上，钱包是一个应用程序，为用户提供交互界面。钱包控制用户资金访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。</li><li>狭义上，“钱包”是指用于存储和管理用户密钥的数据结构。</li><li>在这一小节中，我们将更关注钱包是密钥容器的这一角度，探索椭圆曲线算法在其中的应用。</li></ul><h2 id="hd分层钱包"><a class="markdownIt-Anchor" href="#hd分层钱包"></a> HD分层钱包</h2><p>根据钱包包含的多个密钥之间是否有关系，主要分为两种类型：</p><ul><li><p>第一种类型是<em>非确定性钱包（nondeterministic wallet）</em>，其中每个密钥都是从随机数独立生成的。密钥彼此无关。</p></li><li><p>第二种类型是确定性钱包（deterministic wallet），其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包中使用了许多不同的密钥推导方法。最常用的推导方法是使用树状结构，称为分层确定性（hierarchical deterministic）钱包或HD钱包。</p><ul><li>相比随机（不确定性）密钥，HD钱包有两个主要的优势。第一，树状结构可以被用来表达附加的组织含义，比如子密钥的特定分支用来接收交易收入款项，另一个分支用来负责接收对外付款的找零。密钥的分支也可以用于公司设置，将不同的分支分配给部门、子公司、特定功能或会计类别。</li><li>HD钱包的第二个好处是，用户可以创建一系列公钥，而不需要访问对应的私钥。这样，HD钱包就能用在不安全的服务器上，或者仅作为接收用途，它为每个交易发布不同的公钥。公钥不需要被预先加载或者提前衍生，服务器也不需要有用来支付的私钥。</li></ul></li></ul><hr /><p>HD钱包密钥的生成过程如下图所示：通过记助词和 Salt 生成Root Seed种子，再通过HMAC-SHA512（单向哈希），输出512位bits，其中左256位作为主私钥（通过椭圆曲线密码算法可生成主公钥，采用的是压缩公钥格式264bits），右256位作为主链码。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271513500.(null)" width="70%" height="70%" alight="center"> </img></p><blockquote><p>HD钱包的种子生成过程，并没有涉及椭圆曲线密码算法，因此这里不再展开介绍，具体过程可参考：<br /><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch05.md#523-%E4%BB%8E%E5%8A%A9%E8%AE%B0%E8%AF%8D%E7%94%9F%E6%88%90%E7%A7%8D%E5%AD%90">HD分层钱包 种子生成过程</a></p></blockquote><h2 id="衍生子秘钥"><a class="markdownIt-Anchor" href="#衍生子秘钥"></a> 衍生子秘钥</h2><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271513760.(null)" width="60%" height="60%" aligh="center"> </img></p><ul><li>子秘钥的衍生推导如上图所示：父公钥 + 父链码 + 索引作为输入， 输出512bits，右256bits作为子链码；左256bits 与 父秘钥结合得到子秘钥</li><li>衍生得到的子私钥，推断不出兄弟姐妹的私钥；如果没有子链码，也无法推断出孙密钥</li><li>可以得到如下的推导公式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">child_private_key == (parent_private_key + lefthand_hash_output) % G<br>child_public_key  == point( (parent_private_key + lefthand_hash_output) % G )<br>child_public_key  == point(child_private_key) == parent_public_key + point(lefthand_hash_output)<br></code></pre></td></tr></table></figure><ul><li><p>可以看到，子公钥的推导有两种方式，一个是通过私钥推导，一个是直接通过公钥推导</p></li><li><p>正如我们之前看到的，密钥衍生函数可以被用来创造密钥树上任何层级的子密钥，基于以下三个输入量：密钥，链码以及想要的子密钥的索引。</p><p>密钥以及链码这两个重要的部分被结合之后，就叫做</p><p><em>扩展密钥（extended key）</em></p><p>。术语“扩展密钥”也被认为是“可扩展的密钥”，因为这种密钥可以用来衍生子密钥。</p><ul><li>扩展密钥编码用的 Base58Check使用特殊的版本号，Base58编码字符前缀分别为“xprv”和“xpub”</li></ul></li></ul><center class="half"> <img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271513936.(null)" width="300"></img><img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=MDYwZjYzODI5NTFjOThiYTQ3MzZiM2JhMjAyNWIxNTBfazRleGFLaGlDbFVMOHlsZzllb01uelhQVkJ3SUo5RnJfVG9rZW46Ym94Y256d2Z4M2ZhWWR1NDZmeEtiV2hJOHRlXzE2Mzc5OTcyMDk6MTYzODAwMDgwOV9WNA" width="300"></img></center><ul><li>上面左图为常规衍生，直接使用父公钥衍生子公钥，这样推导的好处就是不用访问私钥，就能衍生扩展出子公钥，用于收款，可以用在安全性较弱的web服务器上<ul><li>但是这种常规的扩展方式存在的问题是，当一个攻击者得到父公钥和对应的链码时，他可以衍生扩展出之后所有的子公钥和对应链码，如果此时再获得子私钥，那么就可以推导出这个子私钥之后所有的私钥（孙私钥等），甚至可能会推导出父私钥</li></ul></li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">child_private_key == <span class="hljs-comment">(parent_private_key + lefthand_hash_output)</span> <span class="hljs-meta">%</span> G<br></code></pre></td></tr></table></figure><ul><li>右图为强化衍生，不使用父公钥，直接用父私钥 + 父链码 + 索引 作为输入，得到输出（这样就算子公钥和子链码暴露了，也不能推导出父私钥）<ul><li>简单来说，如果想利用xpub的便捷来衍生公钥的分支，又不想冒泄露链码的风险， 就该从强化父密钥，而不是常规父密钥衍生。最好的方式是，为了避免主密钥泄露，主密钥所衍生的第一层级的子密钥总是通过强化衍生得来。</li></ul></li></ul><h1 id="交易"><a class="markdownIt-Anchor" href="#交易"></a> 交易</h1><ul><li>比特币交易是比特币系统中最重要的部分。比特币中的其他一切都是为了确保交易可以被创建、在网络上传播、验证，并最终添加到全局交易分类账本（区块链）中。比特币交易的本质是数据结构，这些数据结构是对比特币交易参与者价值传递的编码。比特币区块链是一本全局复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。</li><li>交易主要的功能就是实现比特币的转移，而其实现过程就用到了密码学技术。支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名（每次交易的签名都不同，但都由同一个私钥生成）。针对展示的公钥和签名，比特币网络中的所有人都可以验证该交易有效并予以接受，从而确认支付者对该交易中的比特币的所有权。</li><li>这一小节中，将介绍交易的基本数据结构，关注比特币交易过程的实现，并聚焦密码学技术的使用。</li></ul><h2 id="交易的输出"><a class="markdownIt-Anchor" href="#交易的输出"></a> 交易的输出</h2><p>每一笔比特币交易都会创造输出，并被比特币正本记录下来。几乎所有的输出，除了一个例外（见“数据输出操作符”（OP_RETURN）），都能创造称为UTXO的比特币块，然后被整个网络识别，供所有者在未来交易中使用。</p><p>交易输出包含两部分：</p><ul><li><p>一定量的比特币，面值为“聪”（satoshis） ，是最小的比特币单位；</p></li><li><p>确定花费输出所需条件的加密难题（cryptographic puzzle），这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥 (scriptPubKey)。</p><ul><li>只有出示对应的解锁脚本，成功执行锁定脚本（相当于进行签名验证的过程），才能花费这笔输出</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-string">&quot;vout&quot;</span>: [<br>  &#123;<br>    <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-number">0.01500000</span>,<br>    <span class="hljs-attr">&quot;scriptPubKey&quot;</span>: <span class="hljs-string">&quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-number">0.08450000</span>,<br>    <span class="hljs-attr">&quot;scriptPubKey&quot;</span>: <span class="hljs-string">&quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot;</span>,<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><h2 id="交易的输入"><a class="markdownIt-Anchor" href="#交易的输入"></a> 交易的输入</h2><p>交易的输入包含四个元素：</p><ul><li><p>一个交易ID，引用包含将要消费的UTXO的交易</p></li><li><p>一个输出索引（vout），用于标识来自该交易的哪个UTXO被引用（第一个为零）</p></li><li><p>一个 scriptSig（解锁脚本），满足UTXO的消费条件，解锁用于支出</p></li><li><p>一个序列号，用于指定这笔输入的生效时间</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-string">&quot;vin&quot;</span>: [<br>  &#123;<br>    <span class="hljs-attr">&quot;txid&quot;</span>: <span class="hljs-string">&quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;</span>,<br>    <span class="hljs-attr">&quot;vout&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;scriptSig&quot;</span> : <span class="hljs-string">&quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;</span>,<br>    <span class="hljs-attr">&quot;sequence&quot;</span>: <span class="hljs-number">4294967295</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><h2 id="数字签名"><a class="markdownIt-Anchor" href="#数字签名"></a> 数字签名</h2><p>在上述交易的输入中提到了一个关键元素解锁脚本，实际上这就是应用了椭圆曲线密码算法的数字签名。在比特币的ECDSA算法的实现中，被签名的“消息”是交易，或更确切地说是交易中特定数据子集的哈希值。签名密钥是用户的私钥，结果就是签名：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>i</mi><mi>g</mi><mo>=</mo><msub><mi>F</mi><mrow><mi>s</mi><mi>i</mi><mi>g</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>F</mi><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi></mrow></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>d</mi><mi>A</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sig = F_{sig}(F_{hash}(m),  d_A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><ul><li><p><em>dA</em> 是签名私钥</p></li><li><p><em>m</em> 是交易（或其部分数据）</p></li><li><p><em>Fhash</em> 是散列函数</p></li><li><p><em>Fsig</em> 是签名算法</p></li><li><p><em>Sig</em> 是结果签名</p></li></ul><p>函数<em>Fsig</em> 产生由两个值组成的签名Sig，通常称为R和S：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>i</mi><mi>g</mi><mo>=</mo><mi mathvariant="normal">（</mi><mi>R</mi><mi mathvariant="normal">，</mi><mi>S</mi><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">Sig = （R，S）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">）</span></span></span></span></span></p><p>现在已经计算了两个值R和S，它们就使用一种称为<em>可分辨编码规则Distinguished Encoding Rules</em>或<em>DER</em>的国际标准编码方案，序列化为字节流，正如我们在交易输入的JSON字符串中看到的那样。</p><hr /><p><strong>签名序列化（DER）</strong></p><p>我们再来之前在交易输入中展示的一个解锁脚本，其中以下DER编码签名：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">3045022100884</span>d<span class="hljs-number">142</span>d<span class="hljs-number">86652</span>a<span class="hljs-number">3</span>f<span class="hljs-number">47</span>ba<span class="hljs-number">4746</span>ec<span class="hljs-number">719</span>bbfbd<span class="hljs-number">040</span>a<span class="hljs-number">570</span>b<span class="hljs-number">1</span>deccbb<span class="hljs-number">6498</span><span class="hljs-keyword">c</span><span class="hljs-number">75</span><span class="hljs-keyword">c</span><span class="hljs-number">4</span>ae<span class="hljs-number">24</span>cb<span class="hljs-number">02204</span>b<span class="hljs-number">9</span>f<span class="hljs-number">039</span>ff<span class="hljs-number">08</span>df<span class="hljs-number">09</span>cbe<span class="hljs-number">9</span>f<span class="hljs-number">6</span>addac<span class="hljs-number">960298</span>cad<span class="hljs-number">530</span>a<span class="hljs-number">863</span>ea<span class="hljs-number">8</span>f<span class="hljs-number">53982</span><span class="hljs-keyword">c</span><span class="hljs-number">09</span>db<span class="hljs-number">8</span>f<span class="hljs-number">6e381301</span><br></code></pre></td></tr></table></figure><p>该签名是用户钱包生成的R和S值的序列化字节流，证明对应用户拥有授权花费该输出的私钥。 序列化格式包含以下9个元素：</p><ul><li><p><em>0x30</em>表示DER序列的开始</p></li><li><p><em>0x45</em> - 序列的长度（69字节）</p></li><li><p><em>0x02</em> - 一个整数值</p></li><li><p><em>0x21</em> - 整数的长度（33字节）</p></li><li><p><em>00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb</em> - R值</p></li><li><p><em>0x02</em> - 接下来是一个整数</p></li><li><p><em>0x20</em> - 整数的长度（32字节）</p></li><li><p><em>4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813</em> - S值</p></li><li><p>后缀（<em>0x01</em>）指示使用的哈希的类型（SIGHASH_ALL）</p></li></ul><hr /><p><strong>验证签名</strong></p><ul><li>要验证签名，必须有签名（<em>R</em>和<em>S</em>）、序列化交易和公钥（对应于用于创建签名的私钥）。本质上，签名的验证意味着“只有生成此公钥的私钥的所有者，才能在此交易上产生此签名。”</li><li>签名验证算法采用消息（交易或其部分的哈希值）、签名者的公钥和签名（R和S值），如果签名对该消息和公钥有效，则返回 TRUE 值。</li></ul><h2 id="交易脚本"><a class="markdownIt-Anchor" href="#交易脚本"></a> 交易脚本</h2><p>正如之前内容提到的，锁定脚本和解锁脚本正是组成数字签名和签名验证过程的关键数据。</p><ul><li>锁定脚本：锁定脚本是一个放置在交易输出上面的花费条件——它指定了今后花费这笔输出必须要满足的条件。 由于锁定脚本往往含有一个公钥或比特币地址（公钥哈希值），在历史上它曾被称为<em>脚本公钥scriptPubKey</em>。</li><li>解锁脚本：解锁脚本是这样一个脚本，它“解决”或满足由锁定脚本放置在输出上的条件，并允许使用输出。解锁脚本是每一笔比特币交易输入的一部分，而且往往含有一个由用户的比特币钱包（通过用户的私钥）生成的数字签名。由于解锁脚本常常包含一个数字签名，因此它曾被称作<em>脚本签名ScriptSig</em>。</li><li>当结合锁定脚本和解锁脚本，在堆栈中执行脚本，如果堆栈中最后剩余的结果为“TRUE”，表明解锁脚本中签名跟锁定脚本中的公钥哈希是相匹配的，即用于签名的私钥跟公钥是匹配的。其中，签名验证的这个验证操作正是锁定脚本中 “<strong>OP_CHECKSIG</strong>” 所执行的，即比对消息（交易或其部分的哈希值）、签名者的公钥和签名（R和S值）。</li></ul><hr /><p><strong>脚本执行</strong></p><ul><li>在最初版本的比特币客户端中，解锁脚本和锁定脚本按顺序连起来执行。出于安全因素考虑，在2010年发生了改变，因为存在一个漏洞，允许格式错误的解锁脚本将数据推送到堆栈并损坏锁定脚本。而在当前的方案中，脚本是单独执行的，在两次执行之间传输堆栈，如下所述。<ul><li>首先，使用堆栈执行引擎执行解锁脚本。如果解锁脚本在执行过程中未报错（例如：没有留下“dangling”操作码），则复制主堆栈，并执行锁定脚本。如果从解锁脚本中复制而来的堆栈数据执行锁定脚本的结果为“TRUE&quot;，那么解锁脚本就成功地满足了锁定脚本所设置的条件，因此，该输入是一个能使用该UTXO的有效授权。如果合并脚本执行后的结果是”TRUE“以外的任何结果，输入都是无效的，因为它不能满足UTXO中所设置的使用该笔资金的条件。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271513603.(null)" alt="结合scriptSig和scriptPubKey执行脚本" /></p><p class="note note-info"> 具体脚本在堆栈中的执行过程，可参考：<a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch06.md#644-p2pkhpay-to-public-key-hash">P2PKH 脚本执行流程</a></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>比特币系统中大量使用了密码学技术，例如使用椭圆曲线密码算法生成密钥和公钥，以及交易中的数字签名和验证，确保比特币的所有者在进行转账操作。密码学实现了比特币的许多有趣特性，包括去中心化信任和控制、所有权认证和基于密码学证明的安全模型。可以说，密码学是比特币实现的一大基石。</p><p class="note note-success"> 更多比特币知识可参考我的这个Github项目：<a href="https://github.com/2017zhangyuxuan/Learn-Blockchain">比特币系统 C++ 实现</a></p><h1 id="参考资料附录"><a class="markdownIt-Anchor" href="#参考资料附录"></a> 参考资料附录</h1><p><a href="https://github.com/tianmingyun/MasterBitcoin2CN">《精通比特币》中文电子书</a></p><p><a href="https://zhuanlan.zhihu.com/p/21298725">比特币（地址、私钥）压缩与非压缩的区别</a></p><p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch05.md#523-%E4%BB%8E%E5%8A%A9%E8%AE%B0%E8%AF%8D%E7%94%9F%E6%88%90%E7%A7%8D%E5%AD%90">HD分层钱包 种子生成过程</a></p><p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch06.md#644-p2pkhpay-to-public-key-hash">P2PKH 脚本执行流程</a></p><p><a href="https://bitcoin.stackexchange.com/questions/72657/signature-verification-in-python-using-compressed-public-key">Signature verification in python using compressed public key</a></p><p><a href="https://medium.com/@bitaps.com/exploring-bitcoin-signing-the-p2pkh-input-b8b4d5c4809c">Exploring Bitcoin: signing the P2PKH input</a></p><p><a href="https://www.jianshu.com/p/a560e0605ff2">比特币私钥，公钥和地址的关系</a></p><p><a href="https://live.blockcypher.com/">在线搜索交易记录、区块信息（各种数字货币）</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
      <tag>ECDSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SM4算法介绍与代码实现</title>
    <link href="/2021/11/13/2021-11-13%20SM4/"/>
    <url>/2021/11/13/2021-11-13%20SM4/</url>
    
    <content type="html"><![CDATA[<h1 id="sm4算法介绍"><a class="markdownIt-Anchor" href="#sm4算法介绍"></a> SM4算法介绍</h1><h2 id="加密过程"><a class="markdownIt-Anchor" href="#加密过程"></a> 加密过程</h2><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131454563.(null)" alt="SM4加密过程" /></p><ul><li>首先左侧描述了SM4加密的整体流程：</li></ul><ol><li>输入的一个消息分组为128bits，划分成4个小块，每个小块32bits</li><li>这四个小块经过32轮加密处理</li><li>加密处理后，再经过一次Permutation置换，得到最终加密结果</li></ol><ul><li>右侧描述其中一轮的加密过程，其他轮函数加密过程是类似的，只是轮密钥不同：</li></ul><ol><li>X_3 先后跟 X_2 、X_1 进行异或  —— ①</li><li>① 得到的结果再与轮密钥 RK_i 进行异或  —— ②</li><li>② 得到的记过为32bits，再分成4组8bits，每一组8bits 使用相同的S-Box进行替换，得到新的8bits   —— ③</li><li>③ 得到的4组8bits重新拼接得到32bits，将这32bits复制成5份输入，第1份循环左移2位，第2份循环左移10位，第3份循环左移18位，第4份循环左移24位，第5份不改动直接输出 —— ④</li><li>④ 的得到的5份输出的32bits与X_0 一起进行异或 —— ⑤</li><li>最终得到输出 X’_3 就是 ⑤ 的输出，其他输出X’_0 = X_1 ， X’_1 = X_2， X’_2 = X_3</li></ol><p>用公式进行描述如下所示，其中S代表使用S-box进行替换，L表示线性函数执行循环左移的操作</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>X</mi><mn>0</mn><mo mathvariant="normal">′</mo></msubsup><mo>=</mo><msub><mi>X</mi><mn>1</mn></msub><mspace linebreak="newline"></mspace><msubsup><mi>X</mi><mn>1</mn><mo mathvariant="normal">′</mo></msubsup><mo>=</mo><msub><mi>X</mi><mn>2</mn></msub><mspace linebreak="newline"></mspace><msubsup><mi>X</mi><mn>2</mn><mo mathvariant="normal">′</mo></msubsup><mo>=</mo><msub><mi>X</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">X&#x27;_0 = X_1  \\X&#x27;_1 = X_2\\X&#x27;_2 = X_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>X</mi><mn>3</mn><mo mathvariant="normal">′</mo></msubsup><mo>=</mo><msub><mi>X</mi><mn>0</mn></msub><mo>⊕</mo><mi>L</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mn>3</mn></msub><mo>⊕</mo><msub><mi>X</mi><mn>2</mn></msub><mo>⊕</mo><msub><mi>X</mi><mn>1</mn></msub><mo>⊕</mo><mi>R</mi><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X&#x27;_3 =X_0⊕ L( S (X_3 ⊕ X_2 ⊕ X_1 ⊕ RK_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi mathvariant="normal">替</mi><mi mathvariant="normal">换</mi><mi mathvariant="normal">操</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">输</mi><mi mathvariant="normal">入</mi><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">输</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">为</mi><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">则</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">：</mi><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><msub><mi>b</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>S</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S替换操作输入A=(a_0,a_1,a_2,a_3)，输出为B=(b_0,b_1,b_2,b_3)，则有： \\ (b_0,b_1,b_2,b_3) = S(A)= (Sbox(a_0),Sbox(a_1),Sbox(a_2),Sbox(a_3))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">替</span><span class="mord cjk_fallback">换</span><span class="mord cjk_fallback">操</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">入</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">：</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi mathvariant="normal">线</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">输</mi><mi mathvariant="normal">入</mi><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">输</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">为</mi><mi>C</mi><mo stretchy="false">(</mo><mn>32</mn><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>C</mi><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mn>10</mn><mo stretchy="false">)</mo><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mn>18</mn><mo stretchy="false">)</mo><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mn>24</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L线性函数输入B=(b_0,b_1,b_2,b_3),输出为C (32bits) \\ C = L(B) = B ⊕ (B&lt;&lt;2) ⊕(B&lt;&lt;10) ⊕(B&lt;&lt;18)⊕(B&lt;&lt;24)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">入</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">3</span><span class="mord">2</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span></p><p class='note note-success'>  通过观察SM4加密过程可以看到，在一轮加密中，有3个输出完全等同于3个输入，只有一个输出需要经过一些复杂操作，即计算X'_3，所以在进行解密时，只需要计算原来的X_0，而这可以通过现有的输出得到的（具体操作见下面的解密过程）。</p><h2 id="解密过程"><a class="markdownIt-Anchor" href="#解密过程"></a> 解密过程</h2><ul><li>在了解了SM4一轮的加密过程后，不难得出一轮的解密过程，如下图所示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131519980.png" alt="SM4解密过程" /></p><ul><li>同样左侧描述了SM4解密的整体流程：</li></ul><ol><li>输入的一个密文C为128bits，划分成4个小块，每个小块32bits</li><li>对这四个小块经过一次Permutation置换</li><li>对置换结果进行32轮类似的解密处理，得到最终的明文输出</li></ol><ul><li>具体描述一轮的解密过程，进行32轮类似的解密操作，其中X’_0对应加密过程中的输入X_1，X’_1对应输入X_2，X’_2对应输入X_3，所以重点计算得到原来输入的X_0，下面直接用公式来表示计算过程</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>=</mo><msubsup><mi>X</mi><mn>0</mn><mo mathvariant="normal">′</mo></msubsup><mspace width="2em"/><msub><mi>X</mi><mn>2</mn></msub><mo>=</mo><msubsup><mi>X</mi><mn>1</mn><mo mathvariant="normal">′</mo></msubsup><mspace width="2em"/><msub><mi>X</mi><mn>3</mn></msub><mo>=</mo><msubsup><mi>X</mi><mn>2</mn><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">X_1 = X&#x27;_0     \qquad X_2 = X&#x27;_1 \qquad X_3 = X&#x27;_2     </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:2em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:2em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub><mo>=</mo><msubsup><mi>X</mi><mn>3</mn><mo mathvariant="normal">′</mo></msubsup><mo>⊕</mo><mi>L</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">(</mo><msubsup><mi>X</mi><mn>2</mn><mo mathvariant="normal">′</mo></msubsup><mo>⊕</mo><msubsup><mi>X</mi><mn>1</mn><mo mathvariant="normal">′</mo></msubsup><mo>⊕</mo><msubsup><mi>X</mi><mn>0</mn><mo mathvariant="normal">′</mo></msubsup><mo>⊕</mo><mi>R</mi><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_0 =X&#x27;_3⊕ L( S (X&#x27;_2 ⊕ X&#x27;_1 ⊕ X&#x27;_0 ⊕ RK_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><strong>其中L线性函数跟S-box置换 都跟加密过程中一致；但需要注意的是解密过程中，轮密钥的使用次序是（31, 30, …, 1,0），跟加密过程使用的轮密钥次序正好是相反的</strong></p><h2 id="轮密钥生成"><a class="markdownIt-Anchor" href="#轮密钥生成"></a> 轮密钥生成</h2><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131454839.(null)" alt="轮密钥生成" /></p><ul><li>轮密钥生成过程如上图所示，其中K代表的是16字节的密钥，公式里的S用的和加密过程中相同的Sbox</li></ul><h1 id="c实现sm4加密与解密"><a class="markdownIt-Anchor" href="#c实现sm4加密与解密"></a> C++实现SM4加密与解密</h1><h2 id="实现目标"><a class="markdownIt-Anchor" href="#实现目标"></a> 实现目标</h2><ol><li>使用C++实现SM4算法的加密和结果，实现包括ECB、CBC两种加密模式。并提供命令⾏接⼝对⼆进制⽂件 进⾏加/解密。</li><li>实现对png图像文件的加密，只对图像数据部分进行加密，使得对加密png文件后仍能以png格式打开</li></ol><h2 id="命令行格式说明"><a class="markdownIt-Anchor" href="#命令行格式说明"></a> 命令行格式说明</h2><ul><li>生成的二进制可执行文件为 AppliedCryptography，共有以下几种可选配置<ul><li>-enc：进行加密操作</li><li>-dec：进行解密操作</li><li>-mode：指定加密/解密操作，其后跟着ecb或者cbc（如果没有指定，默认为ecb模式）</li><li>-png：指定输入和输出文件为png格式（对png文件做特殊处理，只加密数据块部分）；如果指定了，请保证文件的后缀名以.png格式结尾</li><li>-in：输入文件的路径，请使用相对路径</li><li>-out：输出文件的路径，请使用相对路径</li><li>-key：指定密钥，默认为&quot;123456&quot;</li><li>-iv：指定初始化向量，默认为&quot;123456&quot;</li><li>-test：如果指定了，执行测试函数</li></ul></li></ul><p class='note note-warning'>1. 配置的命令请用小写 <br>2. 一些配置之后请紧跟对应的参数值 <br>3. 输入和输出的路径请用相对路径 <br></p><ul><li>参考的测试命令如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试cbc模式加密png文件</span><br>./AppliedCryptography -enc -mode cbc -png -in logo.png -out test.png -iv 123456 -key 123456<br>./AppliedCryptography -dec -mode cbc -png -in test.png -out dec_test.png -iv 123456 -key 123456<br><span class="hljs-meta">#</span><span class="bash"> 测试ecb加密文件</span><br>./AppliedCryptography -enc -mode ecb -in test.txt -out ecb_test.txt -iv 123456 -key 123456<br>./AppliedCryptography -dec -mode ecb -in ecb_test.txt -out dec_test.txt -iv 123456 -key 123456<br></code></pre></td></tr></table></figure><h2 id="代码结构说明"><a class="markdownIt-Anchor" href="#代码结构说明"></a> 代码结构说明</h2><p>首先说明进行代码目录的说明，如下图所示：</p><center><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131454890.(null)" width="40%" height="40%" ></center><p align="middle"><font size="2" color="grey">代码目录结构</font></p><ul><li>项目使用CMake 构建，build目录是构建目录，build/output/bin下是对应可执行文件的输出目录，build/output/bin/test 目录下存放测试用的相关文件</li><li>Cmake-build-debug：使用CLion 编译构建时生成的目录</li><li>FirstWork：主要目录，sm4对应源代码是算法的具体实现；test对应的是测试相关方法，主要用于测试算法的正确性</li><li>hash-library：一个简单的第三方库，封装了hash操作和hex编码和解码等操作</li><li>util：其中util是一个工具类，主要封装了一些辅助函数</li><li>main.cpp：程序入口，主要实现了解析命令行参数，执行对应的操作</li></ul><h2 id="实现相关说明"><a class="markdownIt-Anchor" href="#实现相关说明"></a> 实现相关说明</h2><ul><li><p>在<code>sm4.h</code>和<code>sm4.cpp</code>中实现了SM4算法，具体实现逻辑只要是拆分成多个子函数</p><ul><li>L线性函数和Sbox替换函数实现</li><li>轮密钥生成</li><li><code>SM4EncRound</code>和<code>SM4DecRound</code>实现一轮的加密和解密</li><li><code>Encryption</code>和<code>Decryption</code>实现128bits输入的加密和解密</li><li><code>EncFile</code>和<code>DecFile</code>实现文件的加密和解密</li><li><code>EncPNG</code>和<code>DecPNG</code>实现对png格式文件的加密和解密</li></ul></li><li><p>需要注意的是，png图片文件，有自己的固定格式，主要为头部8字节固定签名，加其他数据块的结构，所以解析时要得到真正的数据块（IDAT)，对这一部分进行加密，这样才能加密后依然能够以png方式打开，具体的PNG格式参考：<a href="https://blog.csdn.net/einsteinlike/article/details/41803193">PNG格式说明</a></p></li><li><p>测试函数主要有4个</p><ul><li><code>TestAll()</code> ：进行所有测试</li><li><code>TestEncDec()</code>： 测试SM4 单次加解密128bits</li><li><code>TestEncDecFileECB()</code>： 测试SM4 加密和解密文件 ECB模式</li><li><code>TestEncDecFileCBC()</code>： 测试SM4 加密和解密文件 CBC模式</li><li><code>TestEncDecPNG()</code>： 测试SM4 加密和解密PNG图片</li></ul></li></ul><p class='note note-info'>  代码已上传Github仓库：https://github.com/2017zhangyuxuan/AppliedCryptography <br></p><p class='note note-danger'>  但是当前代码还存在问题是，大端和小端的问题没有彻底解决，如果对比一些官方实现，加密结果是不同的，因为时间原因没有能排查出来，只能作罢。所以仅仅是提供一些思路。</p><center><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//hexo_img/菜狗.jpeg" width="40%" height="40%" align="middle" ></center><h1 id="参考附录"><a class="markdownIt-Anchor" href="#参考附录"></a> 参考附录</h1><p>SM4算法原理 ：<a href="https://blog.csdn.net/bird_tp/article/details/105988468">https://blog.csdn.net/bird_tp/article/details/105988468</a></p><p>SM4 实现参考：<a href="https://cryptopp.com/docs/ref/class_s_m4_1_1_base.html#details">https://cryptopp.com/docs/ref/class_s_m4_1_1_base.html#details</a></p><p><a href="https://blog.csdn.net/weixin_39672443/article/details/110806799">png文件头_图片格式知识PNG_weixin_39672443的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/einsteinlike/article/details/41803193">PNG格式说明</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SM4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题03】隔离见证、闪电网络</title>
    <link href="/2021/11/13/2021-11-13%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9803-%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81%E3%80%81%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/11/13/2021-11-13%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9803-%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81%E3%80%81%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>最近通读了一遍《精通比特币》，对比特币中运行机制和实现原理有了初步的认识和了解。其中隔离见证和闪电网络是此前学习中遇到到两个困惑点，现在也大致有所了解，故而本篇文章就来谈谈我的个人理解，基本上是对书里关键知识点的提炼和总结，下方也给出了电子书连接。如有任何错误，欢迎批评指出~</p><p class='note note-info'><a href=https://github.com/tianmingyun/MasterBitcoin2CN>精通比特币电子书链接</a>  </p><h1 id="隔离见证"><a class="markdownIt-Anchor" href="#隔离见证"></a> 隔离见证</h1><p>隔离见证提出的背景：随着比特币火热发展，网络上的交易量越来越大，而由于区块大小受限，一个区块能打包的交易数量是有一定限制的，而出块速度限定在10分钟一次，这就导致无法满足交易吞吐量的增长。那么隔离见证提出，挑战了交易结构，使得一个区块可以容纳更多的交易，从而提高了交易吞吐量，当时隔离见证还有别的好处，可以去看书中内容<a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch07.md#781-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81">隔离见证的好处</a>。当然提高比特币性能（比如提高交易吞吐量）的方法还有很多，这里不再展开。</p><p class='note note-primary'>隔离见证相关BIP方案:<br>  <a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">BIP-141 隔离见证的定义</a>  <br>    <a href="https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki">BIP-144 隔离见证网络序列化</a></p><h2 id="关键知识"><a class="markdownIt-Anchor" href="#关键知识"></a> 关键知识</h2><ul><li>在比特币环境中，数字签名是见证的<em>一种类型</em>，但更广义来说，见证是指能够满足对UTXO施加的条件并解锁该UTXO以供消费的任何解决方案。术语“见证”是“解锁脚本”或“scriptSig”的更一般的术语。</li><li>在引入隔离见证之前，交易中的每一个输入后面紧跟着的就是解锁它的见证数据。见证数据作为每个输入的一部分嵌入到交易中。术语<em>隔离见证</em>（简称<em>segwit</em>）只是指把特定输出的签名或解锁脚本隔离开。“单独的scriptSig”或“单独的签名”就是它最简单的形式。</li><li>乍一看，隔离见证似乎只是对交易构造方式的改变，属于交易级特性，但事实并非如此。其实，隔离见证是对单独的UTXO花费方式的更改，因此可以说是每个输出层面的特性。</li><li>当交易使用UTXO时，必须提供一个见证。在传统的UTXO中，锁定脚本要求见证数据<em>内嵌</em>在花费UTXO的交易的输入部分。但是，隔离见证UTXO指定了一个锁定脚本，该脚本可以用输入之外的见证数据（隔离）满足。</li><li><strong>隔离见证是一个软分叉</strong></li></ul><h2 id="txid-和-wtxid"><a class="markdownIt-Anchor" href="#txid-和-wtxid"></a> TXID 和 WTXID</h2><ul><li>隔离见证的最大好处之一就是<strong>消除了第三方交易延展性</strong>。</li><li>在隔离见证之前，交易可以通过第三方巧妙地修改其签名，在不改变任何基本属性（输入，输出，金额）的情况下更改其交易ID（哈希）。这为拒绝服务DOS攻击，以及对有缺陷的钱包软件的攻击创造了机会，这些软件假定未经证实的交易哈希是不可变的。</li><li>通过引入隔离见证，交易有两个标识符txid和wtxid。传统的txid是序列化交易的双SHA256哈希，没有见证数据。交易的wtxid是具有见证数据的交易的新序列化格式的双SHA256哈希。</li><li>传统txid的计算方式与非隔离见证交易完全相同。但是，由于隔离见证交易在每个输入中都有空的scriptSig，不存在可由第三方修改的交易部分。因此，在隔离交易中，即使交易未经确认，txid也是不能被第三方修改的。</li></ul><blockquote><p><strong>提示</strong> 隔离见证交易有两个ID：txid和wtxid。txid是没有见证数据的交易的哈希，wtxid是包含见证数据的哈希。所有输入都是隔离见证输入的交易，不受第三方交易延展性影响。</p></blockquote><hr /><ul><li>TXID的生成和传统方式一致：是对version, txins, txouts, nLocktime序列化后的数据，进行两次SHA256哈希</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[nVersion][txins][txouts][nLockTime]<br></code></pre></td></tr></table></figure><ul><li>WTXID的生成：对version, marker, flag, txins, txouts, witness, nLocktime序列化后的数据，进行两次SHA256哈希</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[nVersion][marker][flag][txins][txouts][witness][nLockTime]<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131049973.png" alt="TXID与WTXID的生成" /></p><h2 id="隔离见证的数据到底放在哪里"><a class="markdownIt-Anchor" href="#隔离见证的数据到底放在哪里"></a> 隔离见证的数据到底放在哪里</h2><p>在了解隔离见证的大致原理后，我其实还是存在一个疑惑：既然说见证相当于是原来的签名数据（解锁脚本），与原来的交易数据隔离开，那么这些见证数据到底放在哪里了？</p><ul><li><p>通过<a href="https://www.jianshu.com/p/eef8e260b9f7">比特币探究之隔离见证</a> 这篇文章，了解到原来的签名数据放到了见证数据中，见证数据在CTxIn 是一个新的字段，但是只有在交易被序列化网络传输时才参与，呼应上文计算TXID时，witness是不需要序列化的；</p></li><li><p>通过<a href="https://boinnex.com/what-is-segwit/">外文- Segwit如何工作的</a> 这篇文章，进一步了解到在生成区块时，输入的见证数据同样构成一棵Merkle Tree，并把root放到了区块中的币基交易的output的锁定脚本中，具体原文描述如下图。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131137534" alt="ScriptPubKey of Witness in coinbase " /></p><h1 id="闪电网络"><a class="markdownIt-Anchor" href="#闪电网络"></a> 闪电网络</h1><p>闪电网络其实也是一种提高比特币交易性能的方法，简单来说，就是将大量交易放到比特币区块链之外进行。在具体介绍闪电网络是如何工作运行前，还需要先介绍状态通道，支付通道，HTLC哈希时间锁合约等概念。</p><h2 id="状态通道和支付通道"><a class="markdownIt-Anchor" href="#状态通道和支付通道"></a> 状态通道和支付通道</h2><p>基本概念：</p><ul><li><em>支付通道Payment channels</em>是在比特币区块链之外，双方交换比特币交易的无信任机制。</li><li>实际上，<em>通道channel</em> 一词是一个比喻。状态通道是区块链外，由双方之间的交换状态代表的虚拟构想。实际上没有“通道”，底层数据传输机制也并不是通道。我们使用通道这个术语来表示链外双方之间的关系和共享状态。</li><li>支付通道是更广泛的<em>状态通道state channel</em>概念的一部分，状态通道代表了链外状态的变化，通过最终在区块链上结算得到保障。支付通道是一种状态通道，其中被改变的状态是虚拟货币余额。</li></ul><hr /><p>《精通比特币》中对支付通道的描述感觉过于复杂，这里用Bitcoin Developer Guide里的微支付通道来举例说明，在之前博客[【比特币专题02】Developer Guide导读](<a href="https://2017zhangyuxuan.github.io/2021/10/11/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9802-Developer">https://2017zhangyuxuan.github.io/2021/10/11/2021-10-11比特币专题02-Developer</a> Guide/) 也有介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131147856.(null)" alt="微支付通道" /></p><ul><li>其工作原理大体上可以这样描述：A给B打工，B首先使用A和B的签名，使用P2SH的方式，发送一定金额到脚本地址，并将该交易立即传播到比特币网络上；然后B创造第二个交易，并用到刚刚A的签名，其输入是第一个交易的脚本地址，输出是B的地址（相当于全额返回给B），然后给这个交易加上Locktime，比如说一天后才能广播这个交易。然后A给B工作一部分内容后，A要求B先支付这份工作量的薪水，那么B就创建一份新的交易，从原来全额给B变成分出一部分金额给A，这个新的交易拷贝给A，这样A就可以广播这个新的交易从而获得薪水。（实际上A只需要在locktime过期前，广播最后版本的交易即可）<ul><li>B创建的第一笔交易和第二笔交易，可以理解为《精通比特币》中的<em>注资交易funding transaction</em>或<em>锚点交易anchor transaction</em>：通过在区块链上锁定共享状态的交易，在交易两方之间建立了一个状态通道。在支付通道的示例中，锁定的状态即为通道的初始余额（以货币计）</li><li>随后双方交换已签名的交易，这被称为<em>承诺交易commitment transactions</em>。承诺交易会改变初始状态。这些交易是有效的交易，因为它们<em>可以</em>被任何一方提交进行结算，但是在通道关闭之前，每一方都会将其在链下保留。</li><li>最后，通道可以协商关闭，即向区块链提交最后的<em>结算交易settlement transaction</em>，或者由任何一方单方面提交最后承诺交易到链上。</li></ul></li><li>为什么采用支付通道这样的方式呢，因为A诉求是及时支付薪水，但是因为量小，B不能每次都立即创造一个交易即刻支付，这样的交易费的成本太高了。所以利用这样的方式，既确保了A的薪水是及时得到确认的，又可以使得只需一个交易就一次性支付薪水</li><li>实际上，更改交易金额的输出，这个权利是在B的，因为B有A的签名但A没有B的签名，A拿的是经过B签名后的交易副本（这个交易被B签名过了，所以是有效的）。所以A能实时确保自己对应工作量的薪水能及时支付，就算中途B跑路了，也只是损失一小部分工作量的薪水，之前的薪水都可以得到支付。而对B来说，如果A没有工作，那B也能在locktime 过期后拿回自己的钱（不过这样就需要等待一个locktime的时间）</li></ul><h2 id="htlc哈希时间锁合约"><a class="markdownIt-Anchor" href="#htlc哈希时间锁合约"></a> HTLC哈希时间锁合约</h2><p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch12.md#1255-%E5%93%88%E5%B8%8C%E6%97%B6%E9%97%B4%E9%94%81%E5%90%88%E7%BA%A6htlc">HTLC 哈希时间锁合约</a> 原文中介绍得比较详细了，这里简单总结一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过密钥R生成哈希值H</span><br>H = Hash(R)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 实现HTLC的脚本可能如下所示：</span><br>IF<br>Payment if you have the secret R<br>    HASH160 &lt;H&gt; EQUALVERIFY<br>ELSE<br>    # Refund after timeout.<br>    &lt;locktime&gt; CHECKLOCKTIMEVERIFY DROP<br>    &lt;Payer Public Key&gt; CHECKSIG<br>ENDIF<br></code></pre></td></tr></table></figure><ul><li>任何知道密钥R，其哈希值等于H的人，都可以通过行使IF语句的第一个子句来兑换该输出。</li><li>如果密钥R没有被透露，HTLC中写明了，在一定数量的区块之后，付款人可以使用IF语句中的第二个子句申请退款。</li></ul><h2 id="闪电网络运行"><a class="markdownIt-Anchor" href="#闪电网络运行"></a> 闪电网络运行</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131152708.(null)" alt="" /></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131152805.(null)" alt="" /></div></div></div><p align="middle"><font size="2" color="grey">左图：支付通道初始状态；右图：闪电网络运行流程</font></p><p>接下来说明一下，闪电网络是如何工作：</p><ul><li>在这个例子中，我们有五个参与者：Alice, Bob, Carol, Diana, and Eric。这五名参与者已经彼此之间开设了支付通道。Alice和Bob有支付通道。Bob连接Carol，Carol连接到Diana，Diana连接Eric。为了简单起见，我们假设每个通道每个参与者都注资2个比特币资金，每个通道的总容量为4个比特币，也就是如左图所示的初始状态</li><li>Alice想要支付给Eric1个比特币。但是，Alice并没有直接连接Eric的支付通道。创建支付通道需要注资交易，而这笔交易必须首先提交给比特币区块链。Alice不想建立一个新的支付通道还要支出更多的手续费。那么就可以通过闪电网络来进行支付。</li></ul><ol><li>Alice通过路由发现了一条从Alice到Eric的一条支付路由，由多个支付通道组成。此时Alice和Eric可以进行通信，Eric生成一个密钥R，并进行hash，将哈希值H发送给Alice。</li><li>Alice构造一个HTLC，支付1.003BTC到哈希H（多出来的0.003BTC是给路由上3个节点的费用），并可以在10区块内得到退款。Alice将此HTLC提供给Bob，从和Bob之间的通道余额中扣除1.003比特币，并将其提交给HTLC。该HTLC具有以下含义：<em>“如果Bob知道密钥，Alice将其通道余额的1.003支付给Bob，或者如果超过10个区块后，则退还入Alice的余额”</em>。</li><li>Bob构造一个新的HTLC，支付1.002BTC到哈希H，如果Carol知道了密钥R，可以去取走HTLC中的1.002BTC，然后Bob也可以取走Alice提供的1.003BTC，相当于赚取了0.001BTC；如果Carol不能提供密钥，Bob也可以在9个区块时间内取回1.002BTC</li><li>Carol向Diana提供1.001BTC的HTLC，同上面一样</li><li>Dinana向Eric提供1.0BTC的HTLC</li><li>Eric知道密钥，向Diana出示了密钥R，因此取走了HTLC中的1.0BTC</li><li>Diana从Eric知道了密钥R，再向Carol出示密钥R，获得了1.001BTC，此时在Eric和Diana中支付通道中，Diana余额只有1.0BTC了，但在Carol和Diana的支付通道中，Diana余额为3.001BTC，对比原来的2+2，赚取了0.001BTC</li><li>Carol向Diana支付了1.001BTC，再从Bob处赚取了1.002BTC，赚取了0.001BTC</li><li>Bob向Carol支付了1.002BTC，从Alice处赚取了1.003BTC，赚取了0.001BTC</li><li>最终Alice支付了1.003BTC，实际上1BTC转账给了Eric，0.003支付给了路由上的其他节点</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CryptoPP C++库学习使用</title>
    <link href="/2021/11/01/2021-11-01%20CryptoPP%E5%BA%93%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/11/01/2021-11-01%20CryptoPP%E5%BA%93%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><blockquote><p>参考书籍：《深入浅出CryptoPP密码学库》<br />crypto++  密码学库 ：<a href="https://github.com/weidai11/cryptopp">https://github.com/weidai11/cryptopp</a><br />电子书下载 ：<a href="https://gitee.com/locomotive_crypto">https://gitee.com/locomotive_crypto</a></p></blockquote><p>最近在学习比特币相关技术，在比特币系统中使用大量哈希加密、签名验证等操作，为了用代码来模拟实现比特币的运行过程，学习一个支持密码原语操作的第三方库是非常有必要的。</p><p>最为知名的密码学相关开源库应该是OpenSSL了，但是由于官网是一堆英文，学习起来太吃力，后来机缘巧合下发现了CryptoPP这个库，而且还有专门的中文书籍来讲解使用，因此就决定学习CryptoPP库，本篇论文也是基于《深入浅出CryptoPP密码学库》阅读，整理出关键章节内容，供大家参考学习。</p><p class='note note-info'>1. CryptoPP库的安装使用这里不再详细说明，请大家自行搜索网上教程  <br>2. 后来看到OpenSSL也有一个中文手册学习网站，也推荐给大家https://www.openssl.net.cn/</p><h1 id="string-和-secbyteblock类型互换"><a class="markdownIt-Anchor" href="#string-和-secbyteblock类型互换"></a> string 和 SecByteBlock类型互换</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// SecByteBlock 转 string</span><br><br>SecByteBlock iv; ... <span class="hljs-comment">// C++-style cast </span><br><br>std::string token = std::<span class="hljs-built_in">string</span>(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt;(iv.<span class="hljs-built_in">data</span>()), iv.<span class="hljs-built_in">size</span>());<br><br><br><br><span class="hljs-comment">// string 转 SecByteBlock</span><br><br>std::string str; ... <span class="hljs-comment">// C++-style cast </span><br><br><span class="hljs-function">SecByteBlock <span class="hljs-title">sbb</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> byte*&gt;(str.data()), str.size())</span></span>;<br></code></pre></td></tr></table></figure><h1 id="第四章-初识cryptopp库"><a class="markdownIt-Anchor" href="#第四章-初识cryptopp库"></a> 第四章 初识CryptoPP库</h1><h2 id="hex编解码字符串"><a class="markdownIt-Anchor" href="#hex编解码字符串"></a> Hex编解码字符串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;filters.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;hex.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 第一种编码方式</span><br><br>    HexEncoder hex;<br><br>    string str = <span class="hljs-string">&quot;I like&quot;</span>;<br><br>    string hexstr;<br><br>    hex.<span class="hljs-built_in">Detach</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(hexstr));<br><br>    hex.<span class="hljs-built_in">Put</span>(<span class="hljs-keyword">reinterpret_cast</span>&lt;byte*&gt;(&amp;str[<span class="hljs-number">0</span>]),str.<span class="hljs-built_in">size</span>());  <span class="hljs-comment">// 注意是会追加写入的</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;str:&quot;</span> &lt;&lt; str &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;hexstr:&quot;</span> &lt;&lt; hexstr &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// 第二种编解码写法  Source -&gt; Filter -&gt; Sink  这是一种Pipeline的方式</span><br><br>    string encode,decode;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">enc</span><span class="hljs-params">(str, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> HexEncoder(<span class="hljs-keyword">new</span> StringSink(encode)))</span></span>;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">dec</span><span class="hljs-params">(hexstr, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> HexDecoder(<span class="hljs-keyword">new</span> StringSink(decode)))</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;encode:&quot;</span>&lt;&lt;encode &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;decode:&quot;</span>&lt;&lt;decode &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第五章-随机数生成器"><a class="markdownIt-Anchor" href="#第五章-随机数生成器"></a> 第五章 随机数生成器</h1><p>主要可以关注GenerateBlock方法，生成指定字节长度的随机数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;osrng.h&gt;</span> <span class="hljs-comment">// 可以使用 AutoSeededRandomPool ，该随机器不用设置种子</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;rng.h&gt;</span> <span class="hljs-comment">//包含LC_RNG算法的头文件</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span> <span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP; <span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Array_Size 64</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//定义一个LC_RNG随机数发生器对象，并设置其种子</span><br><br>    <span class="hljs-function">LC_RNG  <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生一个比特的随机数：&quot;</span> &lt;&lt; rng.<span class="hljs-built_in">GenerateBit</span>() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生一个字节的随机数：&quot;</span> &lt;&lt; rng.<span class="hljs-built_in">GenerateByte</span>() &lt;&lt; endl;<br><br>    byte output[Array_Size + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//定义一个缓冲区      </span><br><br><br><br>    <span class="hljs-comment">//产生Array_Size字节长度的随机数</span><br><br>    rng.<span class="hljs-built_in">GenerateBlock</span>(output, Array_Size);  <span class="hljs-comment">// 这里也可直接传入SecByteBlock</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生Array_Size长度的随机数（十六进制）：&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Array_Size; ++i)<br><br>    &#123;<span class="hljs-comment">//将获得的随机数转换成十六进制并输出</span><br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X&quot;</span>, output[i]);<br><br>    &#125;<br><br>    cout &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生一个100到1000之间的随机数：&quot;</span> &lt;&lt; rng.<span class="hljs-built_in">GenerateWord32</span>(<span class="hljs-number">100</span>, <span class="hljs-number">1000</span>) &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">//丢弃掉随机数发生器接下来产生的100个字节数据</span><br><br>    rng.<span class="hljs-built_in">DiscardBytes</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">int</span> arry[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><br>    rng.<span class="hljs-built_in">Shuffle</span>(arry, arry + <span class="hljs-number">10</span>); <span class="hljs-comment">//打乱数组arry中元素的顺序</span><br><br>    <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第六章-hash函数"><a class="markdownIt-Anchor" href="#第六章-hash函数"></a> 第六章 Hash函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sha.h&gt;</span> <span class="hljs-comment">//使用SHA384</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;filters.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;hex.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span> <span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP; <span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">try</span><br><br>    &#123;<br><br>        SHA256 sha; <span class="hljs-comment">//定义一个SHA256的类对象</span><br><br>        byte msg[] = <span class="hljs-string">&quot;I like cryptography very much&quot;</span>;<br><br><br><br>        <span class="hljs-comment">// 使用pipeline范式</span><br><br>        <span class="hljs-function">SecByteBlock <span class="hljs-title">tmp</span><span class="hljs-params">(msg, <span class="hljs-keyword">sizeof</span>(msg)<span class="hljs-number">-1</span>)</span></span>;<br><br>        string r;<br><br>        <span class="hljs-function">StringSource <span class="hljs-title">s1</span> <span class="hljs-params">(tmp, tmp.size(),<span class="hljs-literal">true</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HashFilter(sha,    <span class="hljs-comment">// 使用其他hash函数，更换一下类型即可</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HexEncoder(</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> StringSink(r))))</span></span>;<br><br>        cout &lt;&lt; r &lt;&lt; endl;<br><br>        r.<span class="hljs-built_in">clear</span>();  <span class="hljs-comment">// 清空一下，不然后面会追加</span><br><br><br><br>        <span class="hljs-comment">// 连续两次Hash256，再用Hex编码输出</span><br><br>        SHA256 sha2;<br><br>        <span class="hljs-function">StringSource <span class="hljs-title">s2</span> <span class="hljs-params">(<span class="hljs-string">&quot;I like cryptography very much&quot;</span>,<span class="hljs-literal">true</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HashFilter(sha,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HashFilter(sha2,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HexEncoder(</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> StringSink(r)))) )</span></span>;<br><br>        cout &lt;&lt; r &lt;&lt; endl;<br><br><br><br>        <span class="hljs-function">SecByteBlock <span class="hljs-title">digest</span><span class="hljs-params">(sha.DigestSize())</span></span>; <span class="hljs-comment">//申请内存空间以存放消息摘要</span><br><br>        <span class="hljs-comment">//CalculateDigest()相当于Update()+Final()</span><br><br>        <span class="hljs-comment">// Update用来向sha输入，Final计算hash值，同时重置hash函数内部状态</span><br><br>        sha.<span class="hljs-built_in">CalculateDigest</span>(digest, msg, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(msg) - <span class="hljs-number">1</span>);<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;digest2=&quot;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; sha.<span class="hljs-built_in">DigestSize</span>(); ++i)<br><br>        &#123;<span class="hljs-comment">//以十六进制输出Hash值</span><br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X&quot;</span>, digest[i]);<br><br>        &#125;<br><br>        cout &lt;&lt; endl;<br><br><br><br>        <span class="hljs-comment">//计算msg消息的Hash值</span><br><br>        <span class="hljs-keyword">bool</span> res;<br><br>        res = sha.<span class="hljs-built_in">VerifyDigest</span>(digest, <span class="hljs-comment">//可能抛出异常</span><br><br>                               msg, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(msg) - <span class="hljs-number">1</span>); <span class="hljs-comment">//去掉字符串最后的&#x27;\0&#x27;</span><br><br>        cout &lt;&lt; <span class="hljs-string">&quot;res = &quot;</span> &lt;&lt; boolalpha &lt;&lt;res &lt;&lt; endl;  <span class="hljs-comment">// 这里的boolalpha 是为了输出bool值true或者false</span><br><br><br><br>    &#125;<br><br>    <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword">const</span> Exception&amp; e)<br><br>    &#123;<span class="hljs-comment">//出现异常</span><br><br>        cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl; <span class="hljs-comment">//异常原因</span><br><br>    &#125;<br><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十一章-公钥密码学数学基础"><a class="markdownIt-Anchor" href="#第十一章-公钥密码学数学基础"></a> 第十一章 公钥密码学数学基础</h1><h2 id="大整数-与-大素数生成"><a class="markdownIt-Anchor" href="#大整数-与-大素数生成"></a> 大整数 与 大素数生成</h2><ul><li>可以再研究一下大整数的一些用法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;integer.h&gt;</span><span class="hljs-comment">//使用Integer</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span><span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;osrng.h&gt;</span><span class="hljs-comment">//使用AutoSeededRandomPool</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;nbtheory.h&gt;</span><span class="hljs-comment">//使用PrimeAndGenerator、VerifyPrime</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP;<span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    AutoSeededRandomPool rng; <span class="hljs-comment">// 定义随机数发生器对象</span><br><br>    <span class="hljs-comment">// 定义PrimeAndGenerator对象，利用随机数发生器rng产生素数p和q</span><br><br>    <span class="hljs-comment">// 要求产生的p是1024比特的素数，q是512比特的素数</span><br><br>    <span class="hljs-function">PrimeAndGenerator <span class="hljs-title">pag</span><span class="hljs-params">(<span class="hljs-number">1</span>, rng, <span class="hljs-number">1024</span>, <span class="hljs-number">512</span>)</span></span>;<br><br>    Integer p = pag.<span class="hljs-built_in">Prime</span>(); <span class="hljs-comment">// 获取素数p的值</span><br><br>    Integer q = pag.<span class="hljs-built_in">SubPrime</span>(); <span class="hljs-comment">// 获取素数q的值</span><br><br>    Integer r = (p - <span class="hljs-number">1</span>) / q / <span class="hljs-number">2</span>; <span class="hljs-comment">// 计算r的值，因为p=2*r*q+1，delta=1</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p(&quot;</span> &lt;&lt; p.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot;)：&quot;</span> &lt;&lt; p &lt;&lt; endl; <span class="hljs-comment">// 打印p的值及比特数</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;q(&quot;</span> &lt;&lt; q.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot;)：&quot;</span> &lt;&lt; q &lt;&lt; endl; <span class="hljs-comment">// 打印q的值及比特数</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;r(&quot;</span> &lt;&lt; r.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot;)：&quot;</span> &lt;&lt; r &lt;&lt; endl; <span class="hljs-comment">// 打印r的值及比特数</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">VerifyPrime</span>(rng, r, <span class="hljs-number">10</span>)) <span class="hljs-comment">// 验证r是否为素数</span><br><br>    &#123;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;r是素数&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 如果r为素数，则输出该信息</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">else</span><br><br>    &#123;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;r不是素数&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 如果r不为素数，则输出该信息</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十三章-数字签名"><a class="markdownIt-Anchor" href="#第十三章-数字签名"></a> 第十三章 数字签名</h1><p>电子书给出的参考是ECNR数字签名算法</p><p><a href="https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA椭圆曲线 - Crypto++</a></p><p><a href="https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm">https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm</a> -》关于压缩公钥的实现可以参考 Compressed Point 这一部分</p><h2 id="私钥和公钥生成-保存"><a class="markdownIt-Anchor" href="#私钥和公钥生成-保存"></a> 私钥和公钥生成、保存</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;integer.h&gt;</span><span class="hljs-comment">//使用Integer</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span><span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;osrng.h&gt;</span><span class="hljs-comment">//使用AutoSeededRandomPool</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;eccrypto.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;oids.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;files.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;filters.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;filesystem&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;hex.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;base32.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP;<span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ECDSA_Generate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 指定 private exponent  32字节随机数，生成对应的私钥</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    string exp = &quot;E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB&quot;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    HexDecoder decoder;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    decoder.Put((byte*)&amp;exp[0], exp.size());</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    decoder.MessageEnd();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Integer x;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    x.Decode(decoder, decoder.MaxRetrievable());</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    privateKey.Initialize(ASN1::secp256r1(), x);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br><br><br>    AutoSeededRandomPool prng;<br><br>    ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;<br><br><br><br>    privateKey.<span class="hljs-built_in">Initialize</span>( prng, ASN1::<span class="hljs-built_in">secp256k1</span>() );<br><br><br><br>    <span class="hljs-comment">/* 使用ByteQueue 方便将公私钥存储在内存中，如果要持久化到磁盘，可以使用FileSink</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ByteQueue queue;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    privateKey.Save(queue);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    privateKey.Load(queue);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br><br><br><br>    <span class="hljs-comment">// 验证密钥强度</span><br><br>    <span class="hljs-keyword">bool</span> result = privateKey.<span class="hljs-built_in">Validate</span>( prng, <span class="hljs-number">3</span> );<br><br>    cout &lt;&lt; boolalpha &lt;&lt; result &lt;&lt; endl;<br><br><br><br>    Integer p = privateKey.<span class="hljs-built_in">GetPrivateExponent</span>();<br><br>    cout&lt;&lt; <span class="hljs-string">&quot;len:&quot;</span> &lt;&lt; p.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot; Private Key:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    string priHexKey;<br><br>    <span class="hljs-function">HexEncoder <span class="hljs-title">encoder</span><span class="hljs-params">(<span class="hljs-keyword">new</span> StringSink(priHexKey))</span></span>;<br><br>    p.<span class="hljs-built_in">Encode</span>(encoder, <span class="hljs-number">32</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;priHexKey:&quot;</span>&lt;&lt;priHexKey.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; priHexKey &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// Save private key in PKCS #8 format</span><br><br>    <span class="hljs-function">FileSink <span class="hljs-title">fs1</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/private.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*binary*/</span> )</span></span>;<br><br>    privateKey.<span class="hljs-built_in">Save</span>( fs1 );<br><br><br><br>    <span class="hljs-comment">// Generate publicKey</span><br><br>    ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey publicKey;<br><br>    privateKey.<span class="hljs-built_in">MakePublicKey</span>(publicKey);<br><br>    <span class="hljs-keyword">const</span> ECP::Point&amp; q = publicKey.<span class="hljs-built_in">GetPublicElement</span>();<br><br>    <span class="hljs-keyword">const</span> Integer&amp; qx = q.x;<br><br>    <span class="hljs-keyword">const</span> Integer&amp; qy = q.y;<br><br>    string qxHex, qyHex;<br><br>    <span class="hljs-function">HexEncoder <span class="hljs-title">encoderx</span><span class="hljs-params">(<span class="hljs-keyword">new</span> StringSink(qxHex))</span></span>;<br><br>    <span class="hljs-function">HexEncoder <span class="hljs-title">encodery</span><span class="hljs-params">(<span class="hljs-keyword">new</span> StringSink(qyHex))</span></span>;<br><br>    qx.<span class="hljs-built_in">Encode</span>(encoderx, <span class="hljs-number">32</span>);<br><br>    qy.<span class="hljs-built_in">Encode</span>(encodery, <span class="hljs-number">32</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;len:&quot;</span> &lt;&lt; qx.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot; Public Point x:&quot;</span> &lt;&lt; qx &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;qxHex:&quot;</span> &lt;&lt; qxHex &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;len:&quot;</span> &lt;&lt; qy.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot; Public Point y:&quot;</span> &lt;&lt; qy &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;qyHex:&quot;</span> &lt;&lt; qyHex &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// Save public key in X.509 format</span><br><br>    <span class="hljs-function">FileSink <span class="hljs-title">fs2</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/public.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*binary*/</span> )</span></span>;<br><br>    publicKey.<span class="hljs-built_in">Save</span>( fs2 );<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="私钥和公钥的加载-签名和认证"><a class="markdownIt-Anchor" href="#私钥和公钥的加载-签名和认证"></a> 私钥和公钥的加载、签名和认证</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 头文件和上述一样</span><br><br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ECDSA_LOAD</span><span class="hljs-params">()</span></span>&#123;<br><br>    AutoSeededRandomPool prng;<br><br>    <span class="hljs-function">FileSource <span class="hljs-title">fs1</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/private.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span> )</span></span>;<br><br>    <span class="hljs-function">FileSource <span class="hljs-title">fs2</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/public.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span> )</span></span>;<br><br>    ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;<br><br>    ECDSA&lt;ECP, SHA256&gt;::PublicKey publicKey;<br><br>    <span class="hljs-comment">// 加载私钥， 私钥格式：PKCS #8</span><br><br>    privateKey.<span class="hljs-built_in">Load</span>( fs1 );<br><br>    publicKey.<span class="hljs-built_in">Load</span>(fs2);<br><br><br><br>    <span class="hljs-comment">// 用私钥进行签名</span><br><br>    ECDSA&lt;ECP, SHA256&gt;::<span class="hljs-function">Signer <span class="hljs-title">signer</span><span class="hljs-params">(privateKey)</span></span>;<br><br>    string message = <span class="hljs-string">&quot;Yoda said, Do or do not. There is no try.&quot;</span>;<br><br>    string signature;<br><br><br><br><br><br>    <span class="hljs-function">StringSource <span class="hljs-title">s</span><span class="hljs-params">( message, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">new</span> SignerFilter( prng,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                                      signer,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-keyword">new</span> StringSink( signature )</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                    ) <span class="hljs-comment">// SignerFilter</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>; <span class="hljs-comment">// StringSource</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;signature len:&quot;</span> &lt;&lt; signature.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; output:&quot;</span> &lt;&lt; signature &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// 将签名（包含R，S）转换成 DER 格式</span><br><br>    std::string derSign;<br><br>    <span class="hljs-comment">// Make room for the ASN.1/DER encoding</span><br><br>    derSign.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>+<span class="hljs-number">3</span>+<span class="hljs-number">3</span>+<span class="hljs-number">2</span>+signature.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-keyword">size_t</span> converted_size = <span class="hljs-built_in">DSAConvertSignatureFormat</span>(<br><br>            (byte*) (&amp;derSign[<span class="hljs-number">0</span>]), derSign.<span class="hljs-built_in">size</span>(), DSA_DER,<br><br>            (<span class="hljs-keyword">const</span> byte*) (signature.<span class="hljs-built_in">data</span>()), signature.<span class="hljs-built_in">size</span>(), DSA_P1363);<br><br>    derSign.<span class="hljs-built_in">resize</span>(converted_size);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;DER len:&quot;</span> &lt;&lt; derSign.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; DER:&quot;</span> &lt;&lt; derSign &lt;&lt; endl;<br><br>    string hexDER;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">toDER</span><span class="hljs-params">(derSign, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> HexEncoder(<span class="hljs-keyword">new</span> StringSink(hexDER)))</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;DER hex:&quot;</span> &lt;&lt; hexDER &lt;&lt; endl;<br><br><br><br>    <br><br>    <span class="hljs-comment">// 进行验证</span><br><br>    <span class="hljs-keyword">bool</span> result;<br><br>    ECDSA&lt;ECP, SHA256&gt;::<span class="hljs-function">Verifier <span class="hljs-title">verifier</span><span class="hljs-params">(publicKey)</span></span>;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">ss</span><span class="hljs-params">( signature+message, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-keyword">new</span> SignatureVerificationFilter(</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                             verifier,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">new</span> ArraySink( (byte*)&amp;result, <span class="hljs-keyword">sizeof</span>(result) )</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                     ) <span class="hljs-comment">// SignatureVerificationFilter</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>;<br><br><br><br>    <span class="hljs-comment">// 传统的C 方式 - 函数调用形式</span><br><br><span class="hljs-comment">//    result = verifier.VerifyMessage( (const byte*)message.data(), message.size(), (const byte*)signature.data(), signature.size() );</span><br><br>    <span class="hljs-keyword">if</span>(result)<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Verified signature on message&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">else</span><br><br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to verify signature on message&quot;</span> &lt;&lt; std::endl;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第三方库</tag>
      
      <tag>CryptoPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu-arm apt源配置</title>
    <link href="/2021/10/20/2021-10-20%20Ubuntu-arm%20apt%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/10/20/2021-10-20%20Ubuntu-arm%20apt%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="配置环境"><a class="markdownIt-Anchor" href="#配置环境"></a> 配置环境</h1><p>PC：M1 MacBook Air</p><p>虚拟机软件：Parallel Desktop 16.5</p><p>虚拟机操作系统：<a href="https://ubuntu.com/download/server/arm">Ubuntu Server 20.04 TLS</a></p><h1 id="遇到问题"><a class="markdownIt-Anchor" href="#遇到问题"></a> 遇到问题</h1><p>首先就是随便搜索了一篇网上教程，来配置apt源，比如这篇</p><p><a href="https://blog.csdn.net/p1279030826/article/details/111640455">https://blog.csdn.net/p1279030826/article/details/111640455</a></p><p class='note note-info'>要注意自己的ubuntu版本和apt源设置的版本一致</p><p>但是然后呢，满怀期待执行<code>sudo apt-get update</code> 却报错了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110201532536.png" alt="apt-get update报错 " /></p><p>当时很郁闷啊，因为之前在windows虚拟机上配置的时候都好使的，怎么到你这就拉胯了呢？</p><p>后来在网上找各种资料、解决办法，有的说是网络的问题，有的说是DNS解析的问题，但经过各种尝试都没有效果，后来无奈放弃，就此作罢。</p><h1 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h1><p>但是天无绝人之路，当我第二次再次尝试配置的时候，终于让我找到了正确答案：<a href="https://zongxp.blog.csdn.net/article/details/90604966?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link">解决方案</a></p><p>重点就是后缀要加上-ports，这样对应的镜像源才是arm源，才能适配M1的mac系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">deb http://mirrors.aliyun.com/ubuntu-ports/ focal main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-proposed main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>​</p><p>换源之后执行成功，nice！</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110201533176.png" alt="apt-get update成功" /></p><h1 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h1><p>总的来说踩了个坑，而究其原因，还是自己对这个apt配置参数没有理解到位，仅仅只是照猫画虎，复制教程，而没有领会其中的真意。同时对这个系统架构arm 和 x86的差异没有深刻认识，不同架构之间软件肯定是需要进行适配的，没有很清楚的认识到这一点。所以呢，学海无涯，我还差得远呢~</p><div align='center'><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110251023808.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" width="50%" height="50%" align="middle" ></div>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题01】白皮书导读</title>
    <link href="/2021/10/16/2021-10-16%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9801-%E7%99%BD%E7%9A%AE%E4%B9%A6/"/>
    <url>/2021/10/16/2021-10-16%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9801-%E7%99%BD%E7%9A%AE%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="论文概述"><a class="markdownIt-Anchor" href="#论文概述"></a> 论文概述</h1><p>论文地址：<a href="https://bitcoin.org/bitcoin.pdf">https://bitcoin.org/bitcoin.pdf</a></p><p>由于在“基于信任”模式下的交易，存在交易成本增加、限制了交易额的大小即阻断小额交易、商家欺诈行为等问题，本论文提出解决方案即比特币，这是一个P2P分布式的电子现金交易网络，依靠hash和加盖时间戳，以及工作量证明机制等手段，解决了双重支付问题，并在极大程度上保证了交易的有效性、正确性、抗伪性。论文中也详细介绍了实现所用到的技术、机制、原理等。</p><h1 id="主要收获"><a class="markdownIt-Anchor" href="#主要收获"></a> 主要收获</h1><p>个人感觉最大的收获就是对比特币的运行机制有了大体的认识，了解了整体流程，虽然可能一些技术的实现细节还是不够明朗。下面就是我对其中各个部分的认识和理解。</p><ul><li>在引言介绍部分，引出了比特币的产生背景，基于第三方机构的交易存在的种种问题，并提出比特币这一解决方案。然后接下来的各个章节介绍比特币涉及的主要关键技术。</li><li>Transactions部分描述了交易是如何被记录的，其中运用了Hash和公私钥，但仅仅记录是无法验证交易的有效性，即存在双重支出问题。</li><li>Timestamp Server部分描述了具体每个节点（服务器）的工作，即对形成的区块进行Hash，并加盖上时间戳，根据时序进行排列形成链。</li><li>Proof-of-Work部分描述了进一步说明Timestamp server的实现，即使用工作证明机制，通过找到满足条件的nonce来获得记账权，因为寻找这个nonce依靠CPU算力，CPU算力越高找到的概率越大，即one-CPU-one-vote规则，解决了多数决策中的代表问题。同时这样的方式，也保证了如果攻击者想要篡改某个区块，就先得把这个区块之后的区块都进行修改，而每个区块都是需要靠大量CPU算力来找到nonce，获得记账权进行修改，这样的成本是很大的。</li><li>Network部分则是描述了比特币网络的工作流程。其中提到的一个很重要的原则就是，所有人是默认最长链是最正确的。而正是有这一前提，才有了只要网络里超过51%的算力属于诚实节点，就能保证区块链里交易信息的正确性，因为诚实节点的算力超过一半，算得比攻击节点快，那么最长链肯定属于诚实节点一方。</li><li>Incentive部分说明的是激励机制，给予抢到记账权的节点一定的比特币，正是有这样的激励机制，各个节点才会愿意投入算力去争夺记账权，也才能是之前的工作量证明机制正常运行。还有一种就是以交易手续费的方式进行奖励。</li><li>Reclaiming Disk Space部分说明区块链可以通过Merkel Tree技术方法来压缩数据，减小空间存储。</li><li>Simplified Payment Verification部分则是说明了如何来检验交易的有效性，因为基于之前最长链总是正确的原则， 因此只要向网络上的节点进行询问，找到最长链就可以验证所有的有效交易记录。</li><li>Combining and Splitting Value部分描述的是形成交易的细节，是可以有多个输入的，而输出最多是两个。</li><li>Privacy部分则是说明比特币网络中的隐私相关问题。</li><li>Calculations部分用具体的数学计算来说明了，当一个攻击者在落后最长链Z个块的情况下，想要追上最长链的概率。结果表明，当落后的块数越多，追上的概率就越小，也就保证了区块链的安全性和稳定性。</li><li>Conclusion部分则是最后进行了总结。</li></ul><h1 id="存在疑问"><a class="markdownIt-Anchor" href="#存在疑问"></a> 存在疑问</h1><ul><li><strong>问题1：怎么理解数字货币中的double-spending problem？</strong></li></ul><p>用数字货币交易时，是用先前的交易和下一个拥有者的公钥做Hash，然后用拥有者的私钥进行签名形成这一次交易，比如这次交易A支付给B 1个电子货币，然后A的余额只有1个电子货币，如果没有第三方机构进行监管，确认这个电子货币已经交易出去了，那么A可以继续拿这1个电子货币继续交易，而接受者也无法确认这1个电子货币是否真正的属于他。也就是说，没有第三方监管机构，也没有引入区块链P2P这个网络的话，相当于就没有办法确认交易的有效性，这里产生的交易仅仅起到一个记录的作用。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110162135282" alt="交易链示意图" /></p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110162150429.png" alt="双重支出问题" /></p><ul><li>进一步，那么比特币是怎么解决这个问题的呢？</li></ul><p>比特币建立起了一个用工作量证明机制的P2P网络，网络上的节点都可以进行记账（也就是记录交易信息），记账的方式是基于区块链技术，区块上记录着一段时间内的交易信息，然后按时序用链串联起来，就有了所有的交易信息；同时最长的区块链是被网络上的节点所共同认可是正确的，即相当于第三方监管的确认作用，证明某次交易有效。</p><p>用上面的例子继续说明A的余额只有一个，然后他又同时和B、C进行交易，这两条交易信息传播到网络上，各个节点进行记录。有节点先收到A给B一个比特币的消息，他们检查余额之后会自动忽略另外一条交易消息（这个检查应该是基于他们当前的链？）；同样，会有先收到A给C一个比特币消息的节点，在检查余额之后也会自动忽略另外一条消息。接下来算力最高的（CPU最多的）节点获得记账权，把他记录的区块加到主链上，然后网络上其他节点都会以主链上的交易信息为准。如果放入主链的交易信息是A转给B一个比特币，那么B将会获得比特币，交易的有效性得到确认；同理，如果放入主链的交易信息是A转给C一个比特币，那么C将会获得比特币。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110162150837.png" alt="区块链解决双重支出问题" /></p><ul><li><p><strong>问题2</strong>：不过这样又引出一个问题，这个主链是怎么确定下来，或者说找到的呢？是假设大部分节点都是有着相同的最长主链，然后直接在本地的区块链上加上最新的，然后把新产生的区块信息广播出去？然后再根据最长主链正确性的假设前提，其他节点根据该最长主链更新本地的区块链</p></li><li><p><strong>问题3</strong>：在上面的例子里，还有一个问题，怎么去检验一个交易里付款者的余额？或者说怎么找到该付款者之前的所有交易记录？用公私钥的话好像不太行，因为每次都可能变换。还是说这个账户是可以直接找到的，那隐私性是怎么保护？</p></li><li><p>**问题4：**文中的网络部分提到了容错性，即有的网络节点可能会丢失之前的区块信息，那么这些节点该怎么找到当前的最长主链？</p><ul><li>我理解每次传播的区块都是最新的区块，节点会因此意识到自己丢失了区块信息（这个怎么意识到也是个问题，用最新区块里的的prev hash来验证？），那么怎么来获取丢失的区块信息呢？是从最新区块广播节点那拉取区块吗？</li></ul></li><li><p><strong>问题5</strong>：Merkel Tree剪枝压缩的具体实现</p></li><li><p><strong>问题6</strong>：论文通篇介绍了比特币的实现原理，那么比特币有什么问题，缺点呢？</p></li><li><p><strong>问题7</strong>：在存储部分提到，因为Merkel Tree的技术，存储并不是问题，那么有没有可能用优势来弥补劣势，像是空间换时间？</p></li></ul><h1 id="所思所感"><a class="markdownIt-Anchor" href="#所思所感"></a> 所思所感</h1><ul><li>比特币本身没有价值，但是却有着无比昂贵的价格，甚至有大量的电力、算力耗费在这上面，进行所谓的“挖矿”，从中获得真实的金钱财富，这对我来说有些不可思议，难以理解。我自身也说不太清楚，可能这是个哲学问题？一个从计算机里产生的电子货币，对现实世界没有实质性的价值或者说实用性，为什么却能被人们追捧，赋予了天价？把那些花费在找随机数、挖矿的电力和算力用在更需要的地方，会不会能创造有实际价值的事物？</li><li>通过阅读本篇论文，了解比特币大致的工作流程，实现原理，也认识到比特币最大的特点就是去中心化，没有了第三方机构，改变以往“基于信任”的交易模式，或许正是这种去中心化的、隐蔽的并且可靠的交易方式满足了一定人群的需求（可能并不正当），逃离政府监管，以我们的国情来说，这是不可接受的，对大部分人或许也不好理解。但是区块链这种技术，这种去中心化的网络不一定要落地在电子货币里，应该会有更广阔的应用场景，也需要我自己再学习了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题02】Developer Guide导读</title>
    <link href="/2021/10/11/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9802-Developer%20Guide/"/>
    <url>/2021/10/11/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9802-Developer%20Guide/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文阅读地址：<a href="https://developer.bitcoin.org/devguide/transactions.html">Bitcoin Developer Guide</a></p><p>预计通读耗时：12小时（个人数据，仅供参考）</p><p>中文翻译：</p><p><a href="https://www.8btc.com/books/834/bitcoin-developer-guide/_book/5/5.html">比特币开发者指南-巴比特图书</a></p><p><a href="https://www.bookstack.cn/read/bitcoin_developer_guide/README.md">简介 - 《比特币开发者指南 | Bitcoin Developer Guide》 - 书栈网 · BookStack</a></p></blockquote><h1 id="章节概述"><a class="markdownIt-Anchor" href="#章节概述"></a> 章节概述</h1><p>此次阅读的内容是比特币Developer Guide，详细介绍了比特币中各种设计和技术细节。</p><ul><li>Block Chain：介绍比特币的结构基础区块链，包括工作量证明，块高与分叉，交易数据，共识规则改变引起分叉等内容。</li><li>Transaction：详细介绍了比特币中交易的相关内容，重点说明了交易的组成，交易中的UTXO的类型（使用何种支付方式P2PKH或者P2SH）。</li><li>Contracts：这里的合约跟以太坊的智能合约不太一样，感觉更像是来说明交易双方（针对人而不是交易）该如何进行交易，应该遵守哪些规则。主要介绍了托管和仲裁、微支付通道、Coinjoin（混币）</li><li>Wallet：钱包用来管理和花费UTXO，因为UTXO实际对应的是一个hash地址，因此钱包实际就是在管理公私钥，这部分内容也就更多在介绍公私钥的管理问题。</li><li>Payment Processing：这部分重点介绍如何使用比特币进行支付的相关问题。</li><li>Operating Modes：介绍比特币中全节点和SPV客户端。</li><li>P2P Network：这部分就是详细介绍了比特币运行在P2P网络中相关细节，包括对等节点的发现与链接，全节点的初始化，区块传播等。</li><li>Mining：介绍了单独挖矿和矿池挖矿两种挖矿（添加新的区块）方式。</li></ul><h1 id="重点内容"><a class="markdownIt-Anchor" href="#重点内容"></a> 重点内容</h1><blockquote><p>大部分是阅读各个模块时记录下的重点内容。</p></blockquote><h2 id="block-chain-区块链"><a class="markdownIt-Anchor" href="#block-chain-区块链"></a> Block Chain 区块链</h2><ul><li>Block chain里UTXO的作用，只能使用一次，这也解决了双花问题</li><li>Proof of work里也是充分利用了加密hash算法里随机的天然特性，hash number不可预知<ul><li>每2016块调整难度值，根据生成这2016块block的时间来调整，理想时间是1,209,600秒(two weeks).</li></ul></li><li>Transaction data：block里的第一个交易是一个coinbase交易（由生成的区块奖励和输入输出费用差组成），通常只有在100块之后，才能被花费使用，这么做的目的是因为分叉比较常见，防止因为分叉的原因导致原先的区块失效<ul><li>有个问题是，如何保证必须要在100块之后才能进行花费，是在创建block的时候，判断输入的UTXO所在的区块的深度超过100吗？</li></ul></li><li>共识规则改变：共识规则改变，会有两种不同的情形，分别导致硬分叉和软分叉，不是很能理解其中的含义，查阅相关资料有了进一步认识。（现在比特币的更新，基本就是软分叉）</li></ul><blockquote><p><strong>常见的理解是“硬分叉和老版本软件不兼容、软分叉和老版本兼容”</strong>，这个定义是<strong>不准确</strong>的，但是很多地方已经在用了。。<br /><strong>硬分叉的定义是扩宽共识规则</strong>，允许做之前禁止的事情，以前无效的交易/区块在硬分叉后会变成有效的；<strong>软分叉是收紧共识规则</strong>，禁止之前允许做的事情，以前有效的交易在软分叉后就无效了。<br />**软/硬分叉是共识规则的改变，和链分叉/链重组完全是两码事；这两对概念的关系类似于“红烧/清蒸”与“烧糊/夹生”。**不当部署的软/硬分叉都有可能导致链分叉/链重组。<br />所以，可以想见：<br />硬分叉之后，几乎一定会产生让老节点拒绝接受的区块，所以，硬分叉会破坏前向兼容性；<br />软分叉之后，产生的新区块肯定是老节点也愿意接受的，前向兼容性得以保留。</p></blockquote><ul><li>Detecting forks 发现分叉：通过监控区块链工作量证明而发现硬分叉的代码；监控最近区块的版本号</li></ul><h2 id="transaction交易"><a class="markdownIt-Anchor" href="#transaction交易"></a> Transaction交易</h2><ul><li><strong>P2PKH</strong> 即 pay to public key hash，向公钥哈希地址支付<ul><li>交易的输入使用一个TXID和output index number（对于output来说处在交易的哪个位置）来标识，然后还有一个签名脚本，验证该input对应的output包含的公钥脚本，用来证明这笔输入的钱的确是本人持有</li><li>交易的输出包含一个隐含的index number，以聪为单位的余额量，一个公钥脚本</li><li>Bob要使用Alice的支付给他的UTXO，Alice创建转账的Tx交易时需要用到Bob的公钥，因此Bob的公私钥是提前生成好的，使用ECDSA椭圆签名曲线生成；然后Bob将公钥hash，使用Base58编码地址版本编号、公钥哈希、错误校验码，然后传给Alice，Alice可以进行解码得到公钥hash，并添加到交易中，作为output中的pubkey script，来标识输出到哪个地址；</li><li>而当Bob需要使用这份UTXO，发布交易时，需要构造input，引用Alice创造的交易TX（即TXID和对应的output index number），还需要包含一个签名脚本(signature script），这个签名脚本用来验证这笔输入的确是Bob所有。这个签名脚本里包含了Bob的公钥和签名，而签名的数据包含了Alice创造的交易TXID和index number，输出给其他用户的pubkey script，输出的余额。而输出output，正如上述所说，包含一个隐含的index number，以聪为单位的余额量，一个公钥脚本。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350637.(null)" alt="" /></p><ul><li><p><strong>P2SH</strong>：提出P2SH的目的主要是因为在之前的交易中，都是由发送者负责指定赎出币的条件。这样的话，如果赎出币的过程比较复杂，譬如要使用MULTISIG，那么对付钱的用户，也就是买家，就不够友好。使用P2SH的方式，可以由币的接收方设计好执行的脚本，然后不论脚本多么复杂，发送方只需要将币发送到一个20字节的哈希地址就行。</p><ul><li>有关资料参考：<a href="https://zhuanlan.zhihu.com/p/46072343">P2SH机制</a></li></ul></li><li><p>标准的公钥脚本类型：P2PKH、P2SH、Multisig、Pubkey、Null Data</p></li><li><p>交易中Locktime和Sequence numbers的说明</p><ul><li>Locktime, 也被称为nLockTime, 它定义了个最早时间，只有过了这个最早时间，这个transaction可以被发送到比特币网络。通常被设置为0，表示transaction一创建好就马上发送到比特币网络</li><li>Sequence numbers用来使签名者更新交易，如果sequence numbers设置成0xffffffff时，表明更新完成，就可以立即生效加入到比特币区块中，这个生效是不管Locktime是否过期。</li><li>另一种理解：<ul><li>LockTime ：绝对时间，用的是整个区块链的长度，或者时间戳来表达的。</li></ul></li></ul></li><li><p>Sequence Number : 相对时间，当前交易所引用的UTXO所在的块（也就是输入所在的块），后面追加了多少个块。</p></li><li><p>参考：<a href="https://zhuanlan.zhihu.com/p/43171481">深入浅出微支付通道</a></p></li></ul><h2 id="contract合约"><a class="markdownIt-Anchor" href="#contract合约"></a> contract合约</h2><ul><li>结合之前的P2SH方式中，对multisig有了更进一步的理解。A向B买东西，A使用P2SH，把钱支付到一个脚本地址并使用2-of-3签名（此时比特币只属于这个脚本地址），当B发货了，A收到确认没问题了，那么使用A和B的签名就可以把脚本地址的UTXO转给B的地址。如何A反悔了，不肯提供签名，那么B可以找仲裁机构C，使用B和C的签名也能将脚本地址的UTXO转给B；同理B如果没有发货，A也能找C把钱转回给A。也就是说，相比P2PKH直接转账方式，P2SH相当于多了一步验证等待，验证成功了再转账到用户地址。</li><li>Micropayment Channel 微支付通道</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350785.(null)" alt="" /></p><ul><li><p>其工作原理大体上可以这样描述：A给B打工，B首先使用A和B的签名，使用P2SH的方式，发送一定金额到脚本地址，并将该交易立即传播到比特币网络上；然后B创造第二个交易，并用到刚刚A的签名，其输入是第一个交易的脚本地址，输出是B的地址（相当于全额返回给B），然后给这个交易加上Locktime，比如说一天后才能广播这个交易。然后A给B工作一部分内容后，A要求B先支付这份工作量的薪水，那么B就创建一份新的交易，从原来全额给B变成分出一部分金额给A，这个新的交易拷贝给A，这样A就可以广播这个新的交易从而获得薪水。（实际上A只需要在locktime过期前，广播最后版本的交易即可）</p></li><li><p>为什么采用这样的方式呢，因为A诉求是及时支付薪水，但是因为量小，B不能每次都立即创造一个交易即刻支付，这样的交易费的成本太高了。所以利用这样的方式，既确保了A的薪水是及时得到确认的，又可以使得只需一个交易就一次性支付薪水</p></li><li><p>实际上，更改交易金额的输出，这个权利是在B的，因为B有A的签名但A没有B的签名，A拿的是经过B签名后的交易副本（这个交易被B签名过了，所以是有效的）。所以A能实时确保自己对应工作量的薪水能及时支付，就算中途B跑路了，也只是损失一小部分工作量的薪水，之前的薪水都可以得到支付。而对B来说，如果A没有工作，那B也能在locktime 过期后拿回自己的钱（不过这样就需要等待一个locktime的时间）</p></li><li><p>Coinjoin混币交易，增加隐匿性，保护隐私，当和其他输入输出混杂在一起时，别人就难以追踪输出记录了</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350075.(null)" alt="" /></p><h2 id="wallet钱包"><a class="markdownIt-Anchor" href="#wallet钱包"></a> Wallet钱包</h2><ul><li>钱包程序主要可分为三个子程序，一个程序来发布公钥用于接收比特币，而另一个程序对交易做签名来花费比特币，还有一个网络程序用来跟P2P网络交互。更具体地说，一个完整的钱包程序应包括这些功能：生成私钥，生成对应的公钥，按照需要对公钥进行发布，监听以这些公钥作为输出的交易，创建交易并对其进行签名，广播已签名的交易。</li><li>Wallet file 是对私钥进行管理；描述了私钥和公钥的格式</li><li>参考：<a href="https://blog.csdn.net/omnispace/article/details/79816141">数字货币钱包 - 助记词 及 HD 钱包密钥原理_omnispace的博客-CSDN博客</a></li></ul><h2 id="payment-processing-支付处理"><a class="markdownIt-Anchor" href="#payment-processing-支付处理"></a> Payment Processing 支付处理</h2><ul><li>介绍四种支付比特币的方式和相关的具体细节，包括明文，bitcoin:URI，QR码，新的支付协议X.509</li><li>其中提到一种“Merge Avoidance合并规避”的方法来保护用户隐私，该方法大体的意思就是让减少各个账户连接在一起的次数（或者说减少输入的个数）。因为当你使用UTXO作为输入进行花费时，UTXO原先的owner就可以追溯这次交易的信息，输入的UTXO越多那么能追溯到这笔交易的人就越多，隐私就会受到影响。用官方的例子来说，你有100，200，500，900的UTXO，然后你现在需要支付300BTC，那么你该选用500的UTXO来进行支付（而不是选择100，200作为输入，体现了合并，规避风险）。</li></ul><h2 id="operating-modes运行模式"><a class="markdownIt-Anchor" href="#operating-modes运行模式"></a> Operating Modes运行模式</h2><ul><li>比特币主要有两种运行模式：一个是全节点客户端（包含所有区块和交易信息），一个是SPV客户端（只保存区块头信息）。SPV客户端可以通过请求全节点拿到相应的区块信息，进行验证。然而SPV客户端有两个缺点，一个是可能会被全节点欺骗，解决办法是连接多个全节点，保证不要和诚实节点断开链接了；另一个是容易受到拒绝服务攻击，解决办法是布隆过滤器</li><li>参考：<a href="https://shuwoom.com/?p=857">布隆过滤器(Bloom Filter)、SPV和比特币 - shuwoom的博客</a></li></ul><h2 id="p2p网络"><a class="markdownIt-Anchor" href="#p2p网络"></a> P2P网络</h2><ul><li>因为共识规则不包括网络，所以有可选的网络和协议。这里用Bitcoin Core作为全节点代表，BitcoinJ作为SPV客户端代表。</li></ul><h3 id="peer-discovery"><a class="markdownIt-Anchor" href="#peer-discovery"></a> Peer Discovery</h3><ul><li>首先通过询问DNS seeds来获取对等网络其他有效运行的节点IP，和对等节点建立连接后，可以获取得到更多的网络节点IP。此外，在程序中会有一些固定的静态IP可以尝试连接，或者使用命令行工具尝试与指定IP连接。</li></ul><h3 id="connecting-to-peers"><a class="markdownIt-Anchor" href="#connecting-to-peers"></a> Connecting to Peers</h3><ul><li>节点通过发送version消息连接到一个对等节点。消息version 包含了节点的版本信息、块信息和距离远程节点的时间。一旦这个消息被对等节点收到，它必须回复一个verack。如果它愿意建立对等关系，它将发送自己的version消息。</li><li>一旦建立对等关系，节点可以向远程节点发送getaddr和addr消息来获得其它的对等节点信息。为了维持与对等节点的连接，节点默认情况下每30分钟内会给对等节点至少发送一次信息。如果超过90分钟没有收到回复，节点会认为连接已经断开</li></ul><h3 id="initial-block-download"><a class="markdownIt-Anchor" href="#initial-block-download"></a> Initial Block Download</h3><ul><li>一个全节点在正式工作或者提供服务前，需要进行初始化，把除了硬编码生成的第一个区块外的所有区块下载下来，这个过程就是IBD。</li><li>Block-First 是其中一种下载方式，向一个对等网络节点进行询问，直接下载区块，其缺点也很明显<ul><li>下载速度的限制：只从一个同步节点下载，受限该节点的带宽</li><li>重新下载：同步节点可能会发送不是最长链上的区块，就会导致快结束时才发现需要重新下载</li><li>磁盘空间占用：和“重新下载”相关，下载时可能会将无用的区块保存到磁盘，占用空间</li><li>大量内存使用：因为同步节点发送过来的区块可能是无序的，所以需要先保存到内存中，直到接收到父块才能进行验证</li></ul></li><li>Header-First 的下载方式，解决了Block-First中四个缺陷，它的工作方式是：先向同步节点下载block headers，当部分地验证headers有效性后，IBD节点就可以并行地做两天事——一个是继续向同步节点发送请求下载headers，另一个是向其他对等节点发送请求下载block</li></ul><h2 id="mining-挖矿"><a class="markdownIt-Anchor" href="#mining-挖矿"></a> Mining 挖矿</h2><ul><li>现在有两种挖矿方式：单独挖矿和矿池挖矿<ul><li>单独挖矿：bitcoind来获取P2P网络上的交易，挖矿软件通过RPC方法来获取列表，并构造一个Block模板，然后将对应的block header发送给ASIC进行运算。挖矿软件会将一个nonce值填入币基交易的的字段中，获得新的Merkle root的hash值，然后将新的Block header发送个ASIC。如果ASIC计算生成的block header hash小于预定的阈值，则表明添加的nonce值符合条件，将block header返回给挖矿软件，挖矿软件根据返回的block header更新block，最后将完整的block 返回给bitcoind，bitcoind再向网络传播区块</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350617.(null)" alt="" /></p><ul><li>矿池挖矿：工作流跟单独挖矿类似。不同的是，矿池设定的阈值要比网络上设定的阈值小很多（降低了难度），因此各个矿工通过挖矿软件返回给矿池的block hearder中，有很多是满足矿池的阈值但不满足网络的阈值，这些返回的block header相当于是份额，证明了矿工的工作量；同时总会有几率产生同时满足两个阈值的block header，矿池将满足网络阈值条件的block发送给bitcoind，从而获得奖励。然后矿池根据矿工贡献的份额，平均分发奖励。举个具体例子就是，矿工们总共返回了100个满足矿池条件的block header（相当于有100份额），只有1个满足网络阈值，那么每份额的奖励就是总奖励的1/100，矿工根据自己的份额获得相应奖励。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350905.(null)" alt="" /></p><ul><li>还介绍了三种挖矿软件获取Block的RPC<ul><li>getwork RPC：当前Bitcoin Core已经废弃，这个方法直接为矿工构造好block header，因此矿工可能需要调用成百上千次RPC</li><li>getblocktemplate RPC：获取以下内容；然后挖矿软件就能自己改变nonce值，自己生成block header<ul><li>构造币基交易的信息</li><li>bitcoind发送给矿池的交易列表和具体交易信息，这使得挖矿软件可以查看交易，并有选择性地添加或删除交易</li><li>构造block header的其他信息</li><li>矿池提供的难度值或者网络设定的难度值</li></ul></li><li>Stratum：跟getblocktemplate很类似，但是不同的是，挖矿软件获取到的是重新构造Merkle树的必要信息，而不是具体的交易列表和交易内容。因此，挖矿软件不能添加或者删除交易，不过此时挖矿软件和矿池建立双向的TCP连接；在getblocktemplate 里，挖矿软件用的是HTTP longpoll长轮询，来获取最近的更新。</li></ul></li></ul><h1 id="存在疑问"><a class="markdownIt-Anchor" href="#存在疑问"></a> 存在疑问</h1><p>阅读完所有内容后，还是有很多问题和细节没有弄明白。</p><ol><li>原文：Since it is impractical to have separate transactions with identical txids, this does not impose a burden on honest software, but must be checked if the invalid status of a block is to be cached; otherwise, a valid block with the duplicates eliminated could have the same merkle root and block hash, but be rejected by the cached invalid outcome, resulting in security bugs such as <a href="https://en.bitcoin.it/wiki/CVEs#CVE-2012-2459">CVE-2012-2459</a>.</li></ol><blockquote><p>对于上述内容不是很能理解，不同的transactions怎么会有相同的TXID，可能是由于hash冲突导致的？虽然概率很小。然后“对于缓存一个无效区块的状态”，这该如何理解？什么时候用到了缓存，缓存什么内容（区块的状态？），以及如何判断区块是有效还是无效？如果因为有TXID冲突判定区块无效的话，可以去重TXID，达到有效？</p></blockquote><ol><li>标准交易中，Null Data的的pubkey scripts类型用来干什么的？</li><li>P2PK 被 P2PKH所取代了，支付到公钥哈希的地址，可以使得公钥直到UTXO被使用时才会发布，延迟公钥发布的原因是什么呢？是为了避免攻击者利用公钥进行某些攻击吗？</li><li>多种Signature hash types的用途是什么呢？为什么要有选择性的进行签名？</li><li>交易被打包到区块，交易的费用是根据交易的签名字节长度计算出来，那么这笔费是由买家（支付者）来付吗？在对应的一个交易中，是会增加一个output来指向矿工吗？</li><li>对于HD钱包，即分层确定性钱包中的工作原理还是不太理解，特别是extened keys到harderned keys的转变，为什么要这么做？这么做如何解决问题的？</li><li>SPV客户端具体是怎么使用布隆过滤器的？</li><li>矿工发布区块时，具体是怎么给矿工发放奖励的？是在创建区块的时候，直接生成一个币基交易（把钱转账给该矿工），然后矿工打包所有交易后，开始找满足条件的nonce，找到后广播区块，这样如果区块得到其他节点认可上链了，那么矿工就切实得到了收益。（这样的话，每个节点在生成区块）</li></ol><h1 id="所思所感"><a class="markdownIt-Anchor" href="#所思所感"></a> 所思所感</h1><p>阅读完这篇Guide概览，让我认识了解比特币中许多技术和实现细节，但是通读完一遍后，发现自己好像懂了，又好像没懂，或者说从整体上对比特币的整体架构有了一定的认识，具体有哪些部分组成，涉及哪些关键技术，但是对个各个模块进一步的细节还是似懂非懂，并且还是难以串联起来，各个部分有明显的联系（比如交易与钱包与支付处理），但是感觉自己还是很难将这三者的关系表示清楚，或者说，当把整个比特币看做一个整体时，各个部分是怎么样有机独立又相互配合的。</p><p>还有一个简单的思考，就是对于合约部分中多重签名的使用，例如托管和仲裁，A和B之间的交易还是要依赖于仲裁第三方C，这是否与比特币去中心化的思想相矛盾了呢？后来进一步思考和查阅资料，从另一个视角去看，去中心化，不是不要中心，而是由节点来自由选择中心、自由决定中心。简单地说，中心化的意思，是中心决定节点。节点必须依赖中心，节点离开了中心就无法生存（类似于没了支付宝就不能用淘宝？）。而在去中心化系统中，任何人都是一个节点，任何人也都可以成为一个中心。任何中心都不是永久的，而是阶段性的，任何中心对节点都不具有强制性。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【99%环境搭建系列】云计算管理平台Devstack安装</title>
    <link href="/2021/10/08/2021-10-08%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97%20-devstack%E5%AE%89%E8%A3%85/"/>
    <url>/2021/10/08/2021-10-08%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97%20-devstack%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p class='note note-success'>99%概率完成环境搭建，让天下没有搭建不了的环境！ </p><p>openstack作为开源的云计算管理平台，可以让我们体验云计算技术的各种组件和功能，然而官网繁琐的配置教程令人望而却步。好在devstack提供了一站式安装服务，<s>只需简单执行几个命令即可完成安装</s>（根本不是这样好吗！）。不过经过我的百般测试，只要安装教程里的方式执行命令，成功概率99%！</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082112035.png" alt="" /></p><h1 id="安装环境"><a class="markdownIt-Anchor" href="#安装环境"></a> 安装环境</h1><p>这里说一下我个人的安装环境</p><ul><li>PC操作系统：win10</li><li>VMware Workstation版本：16.x Pro</li><li>Ubuntu版本：18.04</li></ul><h1 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h1><ol start="0"><li><strong>简要说明</strong></li></ol><p class='note note-primary'>ubuntu操作系统在虚拟机的安装这里不再演示，假设你已经完成了ubuntu18.04的安装，然后继续；<br>在~/ 目录下，依次执行命令即可，没有特殊说明，不用执行别的多余命令</p><ol><li><strong>设置静态IP（可选）</strong></li></ol><blockquote><p>说明：这一步是可选的，之所以设置成静态IP，是为了方便后面的配置，以及排除IP变动的原因导致的种种意外；不过不进行配置的话，应该也是ok的，只要保证整个安装以及使用过程IP不会改变</p><p>参考网站：<a href="https://www.cnblogs.com/yaohong/p/11593989.html">ubuntu配置静态ip</a>       <a href="https://blog.csdn.net/zh2508/article/details/85250360">VMware配置静态ip</a></p></blockquote><p>首先给机器设置静态ip，修改<code>/etc/netplan</code>目录下对应的文件，按如下文件进行配置。</p><p class='note note-info'>  三个注意点：<br>  1. 注意配置里的"ens32" 根据自己的机器进行改动，可能是"ens33"，可以通过命令 ip addr 来进行查看 <br>  2. 这里复制的话，注意复制后的结果是否一致，可能需要自己手动输入一下，这样的话要严格注意格式，冒号后面需要一个空格，换行缩进是4个空格<br>  3. 设置的ip和网关要在同一个网段上，记住这里填入的ip，需要用在下面的配置中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br><span class="hljs-attr">network:</span><br><span class="hljs-string">​</span>    <span class="hljs-attr">ethernets:</span><br><span class="hljs-string">​</span>        <span class="hljs-attr">ens32:</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]<br><span class="hljs-string">​</span>            <span class="hljs-attr">optional:</span> <span class="hljs-literal">true</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.2</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">nameservers:</span><br><span class="hljs-string">​</span>                    <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.1</span>,<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.2</span>] <span class="hljs-comment"># 这里DNS的修改，是因为我配置了上面VMware配置静态ip</span><br></code></pre></td></tr></table></figure><p>然后执行<code>sudo netplan apply</code>，让配置生效，再通过<code>ip addr</code>查看是否生效，已经<code>ping</code>命令查看网络是否连通</p><ol start="2"><li><strong>切换apt源</strong></li></ol><p>切换apt源的目的是为了加快下载安装的速度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install vim #先安装下vim<br>sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak<br>sudo vim /etc/apt/sources.list # 如果vim还没有安装，改用 vi 复制下就行<br></code></pre></td></tr></table></figure><p>这里配置用的是阿里云的镜像，如果之后因为网络的问题可以尝试换下别的源，不过我测试使用的都是阿里云</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 注意ubuntu版本号对应不同的代号，这里用的是18.04，对应bionic</span><br>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>更换pip源</strong></li></ol><p>也是为了加快下载安装依赖的速度</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir .pip<br>vim .pip/pip.conf<br></code></pre></td></tr></table></figure><p>配置如下所示，用的是豆瓣的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[global]<br>index-url = http://pypi.douban.com/simple/<br>trusted-host = pypi.douban.com<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>更新并安装包</strong></li></ol><p>依次执行下列命令，主要是更新安装相关依赖，下载pip管理依赖工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get upgrade<br>sudo apt-get install git<br>sudo apt-get install python-pip<br>sudo pip install --upgrade pip<br>sudo pip install -U os-testr  # sudo pip install wcwidth 可选，如果这一步出了wcwidth相关的error的话<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>设置时区同步</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install ntpdate // 安装时间同步工具<br>sudo ntpdate cn.pool.ntp.org // 与网络服务器同步时间<br>date // 查看时间是否已经同步<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>下载devstack</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/openstack/devstack.git -b stable/queens</span> <br><span class="hljs-meta">#</span><span class="bash"> 推荐使用opendev.org官网的wallby这个分支，github上对应的queens这个分支尝试过有问题解决不了</span><br>git clone https://opendev.org/openstack/devstack.git -b stable/wallaby <br></code></pre></td></tr></table></figure><ol start="7"><li><strong>创建stack用户</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo devstack/tools/create-stack-user.sh<br></code></pre></td></tr></table></figure><ol start="8"><li><strong>移动并设置文件夹权限</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mv devstack /opt/stack<br>sudo chown -R stack:stack /opt/stack<br>sudo chown stack:stack /opt/stack<br></code></pre></td></tr></table></figure><ol start="9"><li><strong>切换到stack用户</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo su - stack<br></code></pre></td></tr></table></figure><ol start="10"><li><strong>创建local.conf配置文件</strong></li></ol><p>执行下列命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd devstack<br>vim local.conf<br></code></pre></td></tr></table></figure><p>配置文件内容如下，<strong>注意修改HOST_IP</strong>，改成自己当前的IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[[local|localrc]]<br><span class="hljs-meta">#</span><span class="bash"> Define images to be automatically downloaded during the DevStack built process.</span><br>DOWNLOAD_DEFAULT_IMAGES=False<br>IMAGE_URLS=&quot;http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> use TryStack git mirror</span><br>GIT_BASE=http://git.trystack.cn<br>NOVNC_REPO=http://git.trystack.cn/kanaka/noVNC.git<br>SPICE_REPO=http://git.trystack.cn/git/spice/sice-html5.git<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> Credentials</span><br>[[local|localrc]]<br>ADMIN_PASSWORD=admin<br>DATABASE_PASSWORD=$ADMIN_PASSWORD<br>RABBIT_PASSWORD=$ADMIN_PASSWORD<br>SERVICE_PASSWORD=$ADMIN_PASSWORD<br><span class="hljs-meta">#</span><span class="bash"> Host IP - get your Server/VM IP address from ip addr <span class="hljs-built_in">command</span></span><br>HOST_IP=192.168.10.112 # ifconfig获取本机ip<br>enable_service placement-api<br>enable_service placement-client<br></code></pre></td></tr></table></figure><ol start="11"><li><strong>提前下载依赖包</strong></li></ol><p>因为是从github上连接下载依赖包，可能由于网络不好的问题，直接安装的话可能中途会因为下载失败导致安装失败，所以这里提前下载；如果下载失败了，就多执行几次，肯定是可以的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd files/<br>wget -c https://github.com/coreos/etcd/releases/download/v3.1.10/etcd-v3.1.10-linux-amd64.tar.gz<br>wget -c https://github.com/coreos/etcd/releases/download/v3.1.7/etcd-v3.1.7-linux-amd64.tar.gz<br>wget -c https://github.com/etcd-io/etcd/releases/download/v3.3.12/etcd-v3.3.12-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><ol start="12"><li><strong>安装simplejson</strong></li></ol><p>经过测试，之后安装的过程中可能会报错simplejson安装失败，所以这里提前进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> sudo apt-get purge python3-simplejson 清楚之前的软件包和配置</span><br>sudo apt-get install python3-simplejson<br><span class="hljs-meta">#</span><span class="bash"> sudo apt-get install python-simplejson <span class="hljs-comment"># 上面的命令不行可以试下这个</span></span><br></code></pre></td></tr></table></figure><ol start="13"><li><strong>修改pip安装配置</strong></li></ol><p class='note note-info'>  在测试中，pip相关安装可能会报错，这里提前修改下</p><p>修改对应的目录文件 <code>devstack/inc/python file 198 line</code></p><p>源代码 <code>$cmd_pip $upgrade</code></p><p>修改成 <code>$cmd_pip $upgrade --ignore-installed</code></p><ol start="14"><li><strong>修改权限</strong></li></ol><p>经过测试，之后安装的过程可能会出现如下权限错误的错误，所以这里再次修改权限</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082049771.png" alt="pip下载报错" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chown -R stack:stack /opt/stack<br>sudo chown stack:stack /opt/stack<br>sudo chown -R stack:stack /opt/stack/devstack<br><span class="hljs-meta">#</span><span class="bash"> sudo chmod -R 777 /opt/stack  <span class="hljs-comment"># 先用前三个命令应该足够了，不行再试试这个</span></span><br></code></pre></td></tr></table></figure><ol start="15"><li><strong>开始安装</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>FORCE=yes ./stack.sh<br></code></pre></td></tr></table></figure><p>可能因为网络的原因，中途会连接不上github，导致安装失败，这样就需要重新尝试，先清理下环境再安装，多尝试几次应该都会成功的，不过确保网络质量也比较重要。</p><p>如果是因为下载github上某个依赖包导致的失败，可以事先安装好对应的依赖，使用pip命令下载即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">./unstack.sh<br>./clean.sh<br>FORCE=yes ./stack.sh<br></code></pre></td></tr></table></figure><ol start="16"><li><strong>见证奇迹的时刻</strong></li></ol><p>当你看到如下信息的时候，恭喜你，完成安装~</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110081954141.(null)" alt="成功截图" /></p><ol start="17"><li><strong>openstack界面展示</strong></li></ol><p>具体如何使用openstack，这里就不再详细演示，openstack功能大家就自行地快乐玩耍吧~</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110081954271.(null)" alt="openstack界面展示" /></p><h1 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h1><p>到此为止，devstack的安装教程就到此结束了，如果安装上面的步骤成功了，恭喜你我的朋友！</p><div align='center'><img src='https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082121023.jpeg' width='30%' height='30%' > </div><p>当然如果出现了别的问题无法解决的话，可以评论留下你的问题，或者与我联系。</p><hr /><p>如果真的山穷水尽了的话，microstack 官网教程值得你的拥有~</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082124003.png" alt="" /></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://blog.csdn.net/hunjiancuo5340/article/details/85005995">https://blog.csdn.net/hunjiancuo5340/article/details/85005995</a></p><p><a href="https://blog.csdn.net/u013184378/article/details/84973629">https://blog.csdn.net/u013184378/article/details/84973629</a></p><p><a href="http://www.cnblogs.com/lianshuiwuyi/p/10955041.html">http://www.cnblogs.com/lianshuiwuyi/p/10955041.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>环境搭建系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devstack</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动漫名台词收录</title>
    <link href="/2021/09/30/2021-09-30%20%E5%8A%A8%E6%BC%AB%E5%90%8D%E5%8F%B0%E8%AF%8D%E6%94%B6%E5%BD%95/"/>
    <url>/2021/09/30/2021-09-30%20%E5%8A%A8%E6%BC%AB%E5%90%8D%E5%8F%B0%E8%AF%8D%E6%94%B6%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏王"><a class="markdownIt-Anchor" href="#游戏王"></a> 游戏王</h1><h2 id="凯撒亮"><a class="markdownIt-Anchor" href="#凯撒亮"></a> 凯撒亮</h2><p>因为之前也入坑过游戏王决斗链接国际服，也就组过月光、不知火、电子龙三套牌组，电子龙是我退坑前最后组的卡组，因此也有着特殊的感情。不久前听闻电子龙被彻底削废了，直接入土为安，心情也是五味杂陈，还能继续挣扎吗？</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202109301523396.jpg" alt="img" /></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202109301531454.jpg" alt="img" /></div></div></div><p><a href="https://www.bilibili.com/video/BV12b4y1C7wC">【日语每日一句】凯撒亮经典台词教学</a></p><p>Ko re ga, i ki no ku ru ta me no, o re no a ga ki da !</p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202109301537861.png" width="50%" height="50%" align="middle" ><p>你又是如何呢，你又是为了什么而奋战至今？只要为了达到理想的终点，就算是卑微的挣扎又如何，这就是我所选择的道路！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>动漫</tag>
      
      <tag>游戏王</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Fluid主题博客搭建（小白向）</title>
    <link href="/2021/09/28/2021-09-28%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/09/28/2021-09-28%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.fluid-dev.com/posts/fluid-write/">搭配 Fluid 如何优雅的写一篇文章</a></p><p><a href="https://www.cnblogs.com/mfrank/p/12829882.html">Hexo博客部署Github Pages</a></p><p><a href="https://blog.csdn.net/i_do_not_know_you/article/details/105594269">绑定域名的遇到坑</a></p><p><a href="https://evenweiss.github.io/2021-08-02-blog-building/#%E4%B8%80%E3%80%81Github-Pages-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%85%8D%E7%BD%AE">博客搭建教程</a></p><p>绑定阿里云的top域名，解析成功的问题是：访问速度变得巨慢，并且页面效果很差，图片几乎展示不出来；和vercel部署出来的效果一致（是不是存在什么共性？）；</p><p>当删除阿里云域名解析相关记录后，<a href="http://xn--2017zhangyuxuan-1u97bj59g.github.io">访问2017zhangyuxuan.github.io</a> 依然会跳转到注册的域名上kingofdark.top，然后报错HTTP 502</p><p><a href="https://github.com/qixa/hexo-theme-fluid-mod#%E8%AF%A6%E7%BB%86%E4%BF%AE%E6%94%B9%E4%BF%A1%E6%81%AF">进阶修改版</a></p><p><a href="https://www.julydate.com/post/60859300/#%E6%80%BB%E7%BB%93">CDN加速</a></p><p>心态崩了，弄了几天也没绑定上自己的域名，然后CDN加速也需要配置自己的域名，后来想想还是算了，毕竟博客还是内容最重要，像是页面的美观或者是网站加载速度都是其次了，下次一定。（也只能这样安慰自己了，流下了无能的泪水）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/25/hello-world/"/>
    <url>/2021/09/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="取消评论时显示浏览器内核与操作系统信息"><a class="markdownIt-Anchor" href="#取消评论时显示浏览器内核与操作系统信息"></a> 取消评论时显示浏览器内核与操作系统信息</h3><p>hexo-theme-fluid/source/css/main.styl 路径下添加 (不过好像只有本地预览有效，部署到Github pages上依然不生效；在Vercel部署的，同样也已经生效了)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.vmeta</span> &#123;<br>  <span class="hljs-attribute">display</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure><p>更好的做法是在服务端配置DISABLE_USERAGENT 环境变量为true；重新部署后得到新的server url，一定要记得把这个server url填写到_config.fluid.yml文件中，更新！！ 着了踩了个大坑！！<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="细心很重要">[2]</span></a></sup></p><h3 id="typora图床配置"><a class="markdownIt-Anchor" href="#typora图床配置"></a> Typora图床配置</h3><p><a href="https://zhuanlan.zhihu.com/p/365829157"><strong>Typora+PicGo+Github = Markdown编辑器+图床</strong></a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="牛啊">[1]</span></a></sup></p><p>parallel desktop上 ubuntu20.04 配置国内镜像源无法生效，百度用的改DNS的方法都不行，还是汇报Failed Fetch的错误，找不到对应的IP（这个坑以后再看看吧，或者有那个好心人帮忙看看）</p><p>难道说是还没有arm的镜像吗。。。</p><section class="footnotes"><h2>备注/参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>牛啊<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>细心很重要<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
