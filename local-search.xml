<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>日本自由行总结</title>
    <link href="/2024/10/04/2024-10/2024-10-04%20%E6%97%A5%E6%9C%AC%E8%87%AA%E7%94%B1%E8%A1%8C%E6%80%BB%E7%BB%93/"/>
    <url>/2024/10/04/2024-10/2024-10-04%20%E6%97%A5%E6%9C%AC%E8%87%AA%E7%94%B1%E8%A1%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有点惭愧了，旅游结束之后就没怎么整理，直接在家躺平开摆，原先计划的旅游出行MV、日本出行计划攻略、自我革新改头换面通通抛在脑后，结果就是一躺就躺到了上班，最后还是没能收拾好自己的心情，以一种半吊子的心态开启了人生的新篇章。</p><p>话虽如此，倒也不能真的全然放弃，多少还是“亡羊补牢”吧，趁着国庆十一高铁上的机会，再回来重新总结下这次的日本出行之旅，希望我还能回忆得起来吧（哭）。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202410041727884.png"></p><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><p>先谈谈必备物品一节吧。首先是收集app应运，文档里罗列的app基本够用了，出行主要靠谷歌地图，圣地巡礼的路线安排也是在谷歌地图上进行绘制的，当然也是站在了前人的肩膀上，然后做出了一些特化调整。说实话这个路线规划是真的挺费时费力的，因为我是差不多花了4~5天去做整个出行的计划安排，到安排圣地巡礼的时候，真的各种视频、文档资料需要参考，还不时地需要回顾下动漫，加深下记忆，感觉时间是完全不太够用。。。咳咳，好像有点扯远了，再说回app，对于住宿的话，我是选择了携程、去哪儿来提前进行预订，对于饮食参考了 tabelog 网站，但是有点遗憾的话，当时挑了好几家想去的店，结果因为需要提前预订、当天关门等各种原因，愣是一次没吃成，让人贻笑大方了。此外，原先还想着要多和日本人交流，下了个 voicetra 语音翻译软件，到头来还是没怎么用上，可能感觉还是用自己的工地日语太尬了，以我个人的经验来说，对于出行旅游交流的话，使用简单英语加一些动作手势基本够用了。</p><p>然后是关于信用卡的问题，个人建议出国旅行还是得备一张，虽然在日本使用信用卡的机会不多，印象里应该不超过五次，日常支付基本可以靠支付宝、微信、西瓜卡、现金解决了。一开始我也是准备办一张，但因为时间关系，最后出发前还是没能办上，幸好和我一同出行的小伙伴有，所以问题不是很大。</p><p>西瓜卡也是建议准备一张，iphone手机可以直接添加电子交通卡，不过我的另一位小伙伴好像运气不太好，到了日本才想起来，结果在日本操作出了点问题，连续充值了3000日元，还是没能开通交通卡，也只能含泪放弃使用现金。所以吸取这次教训，最好出行就准备好一张交通卡，不是iphone的话，也可以淘宝买一张实体卡。</p><p>对于出行前该准备多少现金的问题，可以参考我的经历，旅游时间9天8晚（实际游玩天数是7天），准备了30000日元，最后返程的时候基本都花完了，期间也没有取过现金。</p><p>日本上网的话，买 wift 流量卡还是挺方便的，不过我当时在淘宝上买的，选了个便宜的，结果实际用起来网速不太快，所以到旅游景点等人流密集场所就会有卡顿，有点小麻烦，所以建议可以买个品质高些的手机卡。</p><p>生活用品的话，充电宝必备，零钱包感觉也挺实用的，因为日本这边使用现金的话，零钱是找得比较多；转换插头的话，其实如果不是使用自带的吹风机等三孔插头，其实也不太需要；其余物品就随意了。</p><h1 id="出行-Remake"><a href="#出行-Remake" class="headerlink" title="出行 Remake"></a>出行 Remake</h1><p>Ok，接着再来聊聊整体的行程安排，总的来说，原先行程排得太满了（可以见<a href="https://kwaj2xdt3y.feishu.cn/wiki/VdMvwdOeDixyqPk0tBFc1K2XnGy">链接</a>），基本上天天3w步数打底，有一天更是直接干到4w以上，不用多说，脚是真的走得酸痛了，到后头几天，基本上都是到下午脚跟就已经麻了，虽然是还是努力坚持下来，但确实还是太累了，也难怪，谁让我这么贪心呢，总想着把所有地方都去一遍。但回过头来让我重新安排的话，应该不会再把时间排得这么满了，一个更轻松、张弛有度、可持续行走的日程安排会让旅途更加舒适愉快。</p><p>第一天，上午 海洋堂手办博物馆 + 大阪城&#x2F;通天阁，水上巴士的漫游看个人喜好吧，对坐船观赏城市风景不太感冒的话可以pass；下午和晚上选择梅田大厦或者心斋桥&#x2F;道顿堀，选择其中一个就行，这样时间上就不会太赶，会轻松不少。</p><p>第二天，上午可以玩圣玛利亚帆船游 + 水族馆，下午可以逛天王寺公园一带（比如没能去成的本坊庭园），通天阁可以pass了，没什么意思。然后晚上可以去阿倍野展望台，这也是没能去成的一个打卡点，主要其实也是欣赏城市夜景，如果不感冒的话，也可以就四处逛街或者休息。</p><p>第三天，因为要从大阪赶到京都，上午时间可能就不是很充裕了，原定的清水寺-&gt;三年坂-&gt;二年坂-&gt;八坂神社这条路线，可能就看个清水寺，三年坂、二年坂也就是商业街，看看人来人往也没啥。然后下午可以早点去伏见稻荷大社，喜欢爬山的话是有段路能往上爬的，据传可能要个2、3小时。然后晚上的话，就可以选择回来看八坂神社夜景，或是祈园一带逛街。</p><p>第四天，这一天差不多都是在圣地巡礼了，如果重新规划时间的话，应该会选择直接去宇治一带（或者说直接开始京吹的巡礼），因为这次巡礼的一些地点，亲身走过之后才知道路程耗时，导致这次真正到宇治的时候，时间已经很晚了，连著名的宇治抹茶也没能吃上，甚是遗憾，宇治的一些巡礼点也是匆匆而过。非二次元的朋友，也很推荐去宇治游玩，当地的风景氛围也是很不错的，当然京都的话也可以选择去奈良摸小鹿。</p><p>第五天，上午基本上就是要坐新干线到东京，下午的话可以考虑游玩浅草 -&gt; 镰仓 -&gt; 江之岛，晚上回东京，视时间和自身体力可以去逛，比如新宿歌舞伎厅、涩谷忠犬八公等。</p><p>第六天，如果是要圣地巡礼的话，上午就是下北泽路线（这次没能去上），下午就是新宿御苑（言叶之庭+君名）。不是的话，可以逛浅草寺、东京塔、银座、新宿等地方，新宿御苑也同样值得推荐，是一个很大的公园，植被众多，空气清新，很有大自然的味道。</p><p>第七天，对于阿宅来说，剩下的地点无需多言，那必然就是秋叶原了，泡上一天不成问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 遗憾的是我没能在旅游结束后就立刻记录下当时自己的心情与想法，而只能在近三个月后，拖着疲惫的身躯与腐朽的灵魂，写下这些没有生气的文字。我应该是想通过这次旅行跳出已有的条条框框，希冀寻找新的自我，亦或是圆儿时之梦，证明自己对二次元的向往与热爱，但从结果来看，似乎什么也没能改变。依旧是循规滔距，甚至是有些麻木不仁，在这条漆黑的小道上，漫无目的地走着。</p><p>好像写着写着，又变丧了，开始无病呻吟，这可不行，换个角度吧。通过这次旅行，我发现自己或许并不是真正意义上的阿宅，不热衷同人本，对手办和周边也不是很在意，或许是我只是个单纯看动漫的乐子人罢了，或许是年少时就已经建立起防线、认为这样花大钱是不值当的，或许是没有自己想象得那么热爱吧。即使如此，我想我还是会继续看番吧，还是会以“二刺猿”自居（就是算失格的），因为这已经成为了我人生的一部分，或许没有1&#x2F;5，但至少会有1&#x2F;10。如果往后没有大事件洗礼的话，我想我还是一如既往地追番看，依然会为帅气的打斗而热血沸腾，依然会为精彩纷呈的故事而大呼过瘾，依然会为青涩酸甜的恋爱故事而潸然泪下，希望这不是结束，而是新的开始。</p><p>动漫，再看十年，也不会腻。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202410041740640.png"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202410041735764.JPG"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>旅游</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游</tag>
      
      <tag>日本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈分享-往日魅影</title>
    <link href="/2024/05/26/2024-05/2024-05-26%20%E6%9D%82%E8%B0%88%E5%88%86%E4%BA%AB-%E5%BE%80%E6%97%A5%E9%AD%85%E5%BD%B1/"/>
    <url>/2024/05/26/2024-05/2024-05-26%20%E6%9D%82%E8%B0%88%E5%88%86%E4%BA%AB-%E5%BE%80%E6%97%A5%E9%AD%85%E5%BD%B1/</url>
    
    <content type="html"><![CDATA[<p>毕业论文的事情<del>似乎</del>终于要落下帷幕了，有过无限期的启动拖延、懒散度日，有过一周的初稿速成，有过一周的终稿雏形，也有一周的熬夜苦战直至答辩黎明，而到现在的论文终稿纸质版打印，距离终点只剩最后一公里。而我也恰好在等待论文打印的闲暇时刻，简单聊聊此时心中所想。</p><p>在完成毕业论文的这件事上，我想我的拖延症得到了无限地放大，我本来可以做得更好，本来可以有更充裕的时间去修改、去打磨、去精雕细琢，但我却一次次地消磨时间，一次次地犹豫踌躇，一次次地麻痹自己，逃避现实。其结果就是把自己逼上绝路，给自己无限地施压，只有到身后退无可退，已是悬崖边上之时，才能醒悟过来，然后拖着那疲惫的身躯，带着涣散的精神投入到写作之中。</p><p>以这样的状态去完成一件事情，这是七年前的我无法想象的，但三年前的我或许已经初见端倪。这一次或许赶上了，但下一次还会这么顺利吗，我还能做到吗，我还能争取到自己希望的那个结果吗？</p><p><em>命运不会眷顾傻瓜，机会只会给有准备的人。</em></p><p>我不太明白为什么会走到现在这个境地，不，也许我明白。是我丧失了热情，丧失了目标（或者说从未有过），丧失了对事物的求知与渴望，我变得对一切不在意，无所谓，或许我渴望着失败，渴望着一个巨大打击将我唤醒，但也渴望着能再变回单纯天然的自己。一半天使，一般恶魔，我既希望就此承受打击一蹶不振，就此沉沦，又希望自己得浴火重生，凤凰涅槃。所以我试图把自己逼到绝境，看自己究竟会如何抉择。</p><p>我有些明白为什么人是矛盾的了，但我相信事物的发展是螺旋上升的。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>租房经验分享</title>
    <link href="/2024/01/17/2024-01/2024-1-17%20%E7%A7%9F%E6%88%BF%E6%8C%87%E5%8D%97/"/>
    <url>/2024/01/17/2024-01/2024-1-17%20%E7%A7%9F%E6%88%BF%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近我又是在找房子租住，虽然只花了几天功夫就定下来了，但是个人感觉自己还是过于急促随意了，所以特此写个短文记录一下，以供参考。</p><h1 id="个人经验感悟"><a href="#个人经验感悟" class="headerlink" title="个人经验感悟"></a>个人经验感悟</h1><p>首先，找房子最好提前找，给自己留充足的时间去准备，不然太过时间紧张的话，就可能会因为焦虑而忽略了什么。</p><p>其次，尽可能地搜集房源信息，和多个中介聊、沟通，并且不要过早下决定。想我这次租房其实就是个反面例子，有些过于着急了，因为我本身并不是急着入住，只是希望大概年后入住，时间上是比较充裕的，但就是考虑到年后房子可能涨价或是又不好找了，所以有点担心，但其实大差不差的。还有就是虽然和两个中介聊了，他们也带我看了一间相同的房子，感觉也还可以接受，因为后者比前者给出更多的优惠，所以我当时就心动了，感觉继续找又得折腾就直接签了。其实这里有两个点可以说，一个是信息的收集还不够全面，仅仅是因为后一个中介给出的优惠力度更大就感觉不容错过了，但实际上可能可以砍得更多，当我去找第三个中介时，再进行一轮比价，是否可以拿到更多的优惠，或者说我再拖一拖，是不是也能期待更好的房源出现？其实这跟第二点密切相关，就是你是否愿意花更多的时间和精力来寻找潜在的、更便宜、更优质的房子，我个人感觉跑两趟多看看是比较适中的，但我自己本身可能是太懒了不远折腾，宁愿多花点冤枉钱省点力气，这也看个人吧。</p><p>最后，一定要<strong>实地考察</strong>，并结合我下文给出的注意事项去排查。</p><h1 id="租房注意事项"><a href="#租房注意事项" class="headerlink" title="租房注意事项"></a>租房注意事项</h1><p>一些我个人比较关注的点列在下方：</p><ol><li>1楼和顶楼慎重</li><li>热水、漏水问题，去看房子的话，每个水龙头都要打开试一下，看热水是不是来得快，是不是充足</li><li>基础设施：集中供暖、空调、墙皮漏不漏水、冰箱、厨房、厕所</li><li>隔音&#x2F;气味：敲一敲房子的墙壁；窗户的密闭性，有几层玻璃，越多越好</li><li>家居装修风格：窗帘要能遮光</li><li>公区的卫生：马桶的冲水能力，冲水时水量足够，回水时水位刚好</li><li>确定租期问题（如果是中介的话，房子是什么时候后到期）<ol><li>还有就是押金问题，如果提前走了，押金退多少等</li><li>问下能不能自己再直接转租给别人，这样可以不用违约金</li></ol></li><li>确认好房子的水费、电费情况，是不是还欠着</li><li>设备维修费用谁来出，比如马桶堵塞了，空调坏了，谁来负责？</li><li>要看房本和身份证</li><li>还要问下室友的工作，作息时间，是不是正常工作；以及室友爱不爱干净，看他洗不洗碗</li><li>需要考虑其他的费用：</li></ol><ul><li>网费</li><li>水电费</li><li>煤气费</li><li>维修费</li><li>暖气费</li></ul><ol start="13"><li>无线网 网络测试，多少带宽的</li></ol><hr><p>还有就是推荐下之前看到的一个视频：<a href="https://www.bilibili.com/video/BV19q4y167KU?spm_id_from=333.337.search-card.all.click">北京租房攻略，真实血泪经验！北漂五年经验分享！_哔哩哔哩_bilibili</a> </p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202401171150234.png" alt="租房细节"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202401171150165.png" alt="租房渠道"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好像也没啥特别好总结的，但对自身的一个感受就是，自己好像花钱不再那么拘谨了，明明是那样精打细算，能省则省，现在倒是觉得多花点冤枉钱省点力气也行，果然由俭入奢易，由奢入俭难，真得好好审视下自己了。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>生活指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>租房</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU Caches and Why You Care</title>
    <link href="/2023/11/29/2023-11/2023-11-29%20CPU%20Cache/"/>
    <url>/2023/11/29/2023-11/2023-11-29%20CPU%20Cache/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近阅读到几篇有关 CPU caches 和 false sharing 的文章，特别是 <em>CPU Caches and Why You Care</em> <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[CPU Caches and Why You Care](https://www.aristeia.com/TalkNotes/ACCU2011_CPUCaches.pdf)">[1]</span></a></sup> ，感觉收获颇丰，对 CPU 缓存有了进一步的了解，所以特此记录下来，下面也给出了对应的PPT链接和演讲视频链接，推荐阅读和观看。同时，又再次接触了Cache的关联映射，大学里学习机组时的记忆从脑海里开始浮现，但我好像已经把知识点都还给老师了，所以借此机会，重新回顾温习一番。</p><p><a href="https://www.aristeia.com/TalkNotes/ACCU2011_CPUCaches.pdf">PPT 链接</a> 、<a href="https://www.bilibili.com/video/BV1HM411A7L9/?spm_id_from=333.337.search-card.all.click&vd_source=caa8e70e79084aa9767fec2791f2ed1d">演进视频</a></p><h1 id="CPU-Caches-and-Why-You-Care"><a href="#CPU-Caches-and-Why-You-Care" class="headerlink" title="CPU Caches and Why You Care"></a>CPU Caches and Why You Care</h1><h2 id="经典问题引入"><a href="#经典问题引入" class="headerlink" title="经典问题引入"></a>经典问题引入</h2><h3 id="行遍历-or-列遍历"><a href="#行遍历-or-列遍历" class="headerlink" title="行遍历 or 列遍历"></a>行遍历 or 列遍历</h3><p>先来看如下代码（左图），函数功能就是对一个矩阵里的元素进行求和，但有两种不同的遍历方式，行遍历和列遍历，右图展示了在 GCC 和 MSVC 环境下行遍历（RW）和列遍历（CM）的遍历时间，可以看到列遍历是明显快于行遍历的，这也是我们平常在遍历二维数组时最常用的方式。那么背后的原因就在于 CPU Cache，因为 cache line 的存在，CPU 每次都会从内存读取一段连续的数据到缓存中，因此在进行列遍历时，下一个访问的数据已经在缓存中，而不需要去内存读取。</p><center><figure class="half">    <img   src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312121538535.png" width="45%"/> <img  src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312121539567.png" width="45%" />  <br>  <em>左: 代码，右: 性能表现 </em> </figure> </center><h3 id="两段-Loop-代码"><a href="#两段-Loop-代码" class="headerlink" title="两段 Loop 代码"></a>两段 Loop 代码</h3><p>再来看看下面这个代码示例<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Gallery of Processor Cache Effects](https://igoro.com/archive/gallery-of-processor-cache-effects/)">[2]</span></a></sup>，两个循环的差异就在于循环的步长不同，Loop 1步长为1，Loop 2步长为16，不难得到 Loop 2的工作量为 Loop 1 的 <strong>6%</strong> 左右，但是实际测试中发现，Loop 2 的耗时是 Loop 1 的 <strong>70%~80%</strong> 左右，这样的结果是反直觉的。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">// Loop 1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++) arr[i] *= <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// Loop 2</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i+=<span class="hljs-number">16</span>) arr[i] *= <span class="hljs-number">3</span>;<br><br></code></pre></td></tr></table></figure><p>事实上，上述两段代码的运行耗时主要不在于乘法计算，而在于对数组元素的读取，也就是和内存访问相关。因为 CPU Cache Line 的关系（后面会进一步介绍，这里简单来说，就是 CPU 访问内存不是一个字节为单位，而是一个 chunk 大小为单位，目前一般为 64 字节），而 Loop 2 的步长为 16 * 4（int字节数），恰好每次递增都会跳过一个 Cache Line，所以 Loop 2 和 Loop 1 在内存访问上的耗时是接近的。</p><h3 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h3><p>下面这段代码示例同样来自 <a href="https://igoro.com/archive/gallery-of-processor-cache-effects/">Gallery of Processor Cache Effects</a> ，尽管看上去两个循环做的工作量是一样的，但在上述文章中作者指出，Loop 2的执行速度要比 Loop 1 快了两倍，我在 quick_bench 上做了下类似的<a href="https://quick-bench.com/q/TT7vCjSxsn6fEWzl54ZuUCffpxI">测试</a>（需要关闭优化，不然编译器可能直接把整个循环都优化掉了），结果也表明 Loop 2 要比 Loop 1 快1.6倍左右。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> steps = <span class="hljs-number">256</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">// Loop 1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;steps; i++) &#123; a[<span class="hljs-number">0</span>]++; a[<span class="hljs-number">0</span>]++; &#125;<br><br><span class="hljs-comment">// Loop 2</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;steps; i++) &#123; a[<span class="hljs-number">0</span>]++; a[<span class="hljs-number">1</span>]++; &#125;<br></code></pre></td></tr></table></figure><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312101541151.png" alt="测试结果"></p><p>如何解释这一现象呢？</p><p>实际上对于 Loop 1来说，它的工作流如下图所示，两个 <code>a[0]++</code> 的操作是相互依赖的。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312101540640.png" alt="Loop 1 workflow"></p><p>而对于 Loop 2 来说，它的工作流如下图所示， <code>a[0]++</code> 与 <code>a[1]++</code>是可以并行的，而 L1 cache 也支持同时去访问不同的内存单元，做并行的优化。感觉这里其实跟指令流水的概念也很相近。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312101540535.png" alt="Loop 2 workflow"></p><h2 id="CPU-Caches"><a href="#CPU-Caches" class="headerlink" title="CPU Caches"></a>CPU Caches</h2><p>上一小节中，列举了几段代码例子，来说明 CPU Caches 的存在以及它的重要性，在该小节中，会进一步介绍 CPU Caches 的缓存结构以及 Cache 的相关知识。</p><h3 id="L1-L2-L3-缓存结构"><a href="#L1-L2-L3-缓存结构" class="headerlink" title="L1,L2,L3 缓存结构"></a>L1,L2,L3 缓存结构</h3><p>介绍 CPU 缓存结构前，先简单了解下计算机金字塔型的存储结构。现代计算机的体系结构，在性能、成本和制造工艺方面做出取舍，从而达到一个平衡。下图是计算机存储结构的示例图，可以看出，访问速度越快一般容量越小，相应的速度越快，成本也会提高。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312121603664.jpg" alt="计算机存储结构"></p><p>而由于CPU与内存之间存在较大的性能差距，因此引入了 CPU Cache。CPU Cache 通常分为大小不等的三级缓存，分别是 L1 Cache，L2 Cache，L3 Cache，其中 L1 Cache 通常分为数据缓存和指令缓存，即数据和指令时分开存储的；L1 Cache 和 L2 Cache 都是每个 CPU core 独有的，而 L3 Cache 是多个 CPU core 共享的，其层级关系如下图所示：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312121613374.png" alt="CPU Cache 层级关系（来自小林coding）"></p><hr><p>以 Intel Core i7-9xx 处理器为例，该 CPU 每个 core 有32KB的 L1 I-cache 和 32KB的 L1 D-cache，256KB 的 L2 cache，4 个 cores 共享一个 8MB 的 L3 cache。</p><center><figure class="half">    <img   src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312121614698.png" width="45%"/> <img  src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312121615435.png" width="45%" />  <br>  <em>左: 缓存大小，右: 缓存结构 </em> </figure> </center><h3 id="Cache-line"><a href="#Cache-line" class="headerlink" title="Cache line"></a>Cache line</h3><p>引入CPU cache之后，CPU访问某块地址时，会首先检查L1 Cache，如果不存在，则会检查L2 cache，然后是L3 Cache、内存。如果CPU直接命中cache，则不需要再去访问内存，如果没有命中cache，则需要找到之后会把内存中的数据映射到cache中，内存映射到到cache的传输的最小单位就是 <strong>cache line</strong>。现代CPU cache line大小一般是64或者128字节，也就是说就算CPU只读取一个字节，也会把这个字节所在的内存段里64字节全部映射到cache中。这主要是根据局部性原理，访问到一个地址时，这个地址附近的内容近期也很大概率被访问到。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[CPU cache line与多线程性能优化 - 知乎](https://zhuanlan.zhihu.com/p/374586744)">[3]</span></a></sup></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312121642784.png"></p><h3 id="Cache-Coherence"><a href="#Cache-Coherence" class="headerlink" title="Cache Coherence"></a>Cache Coherence</h3><p>现代 CPU 都是多核的，由于 L1&#x2F;L2 Cache 是多个核心各自独有的，那么会带来多核心的<strong>缓存一致性（Cache Coherence）</strong> 的问题，如果不能保证缓存一致性的问题，就可能造成结果错误<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[CPU 缓存一致性](https://www.xiaolincoding.com/os/1_hardware/cpu_mesi.html)">[4]</span></a></sup>。</p><p>有关CPU 缓存一致性的有关问题，<a href="https://www.xiaolincoding.com/os/1_hardware/cpu_mesi.html">小林coding - CPU 缓存一致性</a> 这篇文章解释得很详细了，大家可以直接移步阅读，这里不再做进一步展开。</p><h2 id="False-Sharing"><a href="#False-Sharing" class="headerlink" title="False Sharing"></a>False Sharing</h2><p>设想一下，两个不同的变量被两个线程（运行在不同的 core 上）使用，看起来这完全是可以并行的，因为两个线程之间用的是互相独立的数据。然后，如果这两个变量落在同一个 cache line 上的话，并且至少有一个线程进行写操作，那么就会存在 cache line 的竞争（Cache coherence 缓存一致性），这个现象被称作是 <strong>false sharing</strong>。</p><p>之所以称作是 false sharing，是因为尽管不同线程之间没有共享数据，但是无意中共享了 cache line。</p><hr><p>接下来用两段代码来进一步说明 false sharing。</p><p>下方的左图代码，其含义是为了实现对一个矩阵元素求和的功能，使用线程池来并发求和，对应线程数量大小为P，每个线程都会分配一定数量的行，各个线程都会把求和结果放在 <code>result</code> 数组中，最终进行一个求和。</p><p>右图则展示了线程数量与单线程执行效率对比关系，可以看到当线程数小于15时，虽然线程数增加了但程序的执行效率反而低于单线程，线程数在20-25区间也是有一个递减的趋势，且效率远低于预期。</p><center><figure class="half">    <img   src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312121700695.png" width="45%"/> <img  src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312121700461.png" width="45%" />  <br>  <em>左: 代码，右: 性能表现 </em> </figure> </center>导致上述现象的根因就是 false sharing：对于数组 `result[P]`，它的多个 int 数组元素都处在同一个 cache line 上，而在上述代码中，线程池里遍历矩阵元素求和时，都是在对`result[P]`中元素进行修改写入，从而导致多个线程之间对同一个 cache line 产生竞争关系，当一个线程在写入时，其他线程 cache 里的变量已经失效了，必须要重新从内存中读取，因此写线程也需要将写入cache 的值再写回内存。这样一来，由于缓存一致性的问题，导致原先能够并行的多个线程反而像是串行执行，再加上线程切换的开销，因此执行效率自然是大大下降。<p>知道根因后，也就自然想到对应的解决办法，如下左图代码所示，在每个线程中引入一个局部变量 <code>count</code>，在遍历矩阵时都先累加在该变量上，求和完之后再一次地赋值给 <code>result[P]</code>，因此每个线程的局部变量都在不同的线程栈上，是不会处于同一个 cache line 上，因此也就没有缓存一致性和 false sharing 的问题了。最后程序的性能表现如下右图所示，可以看到，达到了一个预期的线性增长的效果。</p><center><figure class="half">    <img   src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312121702995.png" width="45%"/> <img  src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312121702133.png" width="45%" />  <br>  <em>左: 改进代码，右: 性能表现 </em> </figure> </center><hr><p class='note note-primary'>   关于 False Sharing ，还可以再看看这篇文章 <a href="http://simplygenius.net/Article/FalseSharing">Concurrency Hazards: False Sharing</a>  <sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Concurrency Hazards: False Sharing](http://simplygenius.net/Article/FalseSharing)">[5]</span></a></sup>，其中也给出了一个详细具体的例子来解释 false sharing。</p><h2 id="总结与建议"><a href="#总结与建议" class="headerlink" title="总结与建议"></a>总结与建议</h2><p>最后也是翻译下PPT里的总结和建议。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>小就是快，快就是小，在硬件层面上没有 时间&#x2F;空间 的权衡；</p></li><li><p>关注 locality 局部性</p></li><li><p>可预测的访问模式，构建对缓存预取友好的程序</p></li></ul><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ul><li><p>对于<strong>数据</strong></p><ul><li><p>在实际中，尽可能使用数组遍历</p></li><li><p>充分利用 cache line，提高利用率</p><ul><li>当看到数据结构中有布尔值时，这可能是存在问题的，对于 64位的 cache line 可能就只使用了其中 1 位</li></ul></li><li><p>警惕 false sharing</p></li></ul></li><li><p>对于 <strong>代码&#x2F;指令</strong></p><ul><li><p>适合缓存的工作集：避免在异构序列上进行迭代调用虚函数</p><ul><li>例如从一个基类派生出三个子类 A,B,C，然后有程序了有一个基类指针容器，指向不同类型的子类，当遍历这个容器取调用虚函数 Process 时，第一个对象类型为A，假如此时A对应的Process函数指令不在缓存中，那么就从主存里读取到缓存，然后执行；接着第二个对象类型为B，同样又需要把B的Process函数指令从主存读取到缓存；接着第三个对象类型为C，也需要把C的Process函数指令读取到缓存中，当时如果此时缓存已经满了，那么就会发生替换，很可能就把A之前的缓存的指令替换了。那么以此类推，以A，B，C的顺序访问，那么就会一直发生从主存读取到缓存的操作。一个可行的解决思路就是，按对象类型排好序，先遍历所有 A 对象，再是B，最后是C。</li></ul></li><li><p>构造 “fast paths”，无分支序列：提前检查所有通常不常见的奇怪情况</p></li><li><p>谨慎使用内联函数</p><ul><li>好处在于可以减少分支（函数调用算是分支，可能会产生缓存miss），对编译器来说也便于产生其他类型的优化，来产生更小的代码</li><li>坏处在于缓存中可能会有多份相同代码指令的拷贝，会减小有效缓存的大小</li></ul></li><li><p>利用好一些工具 PGO 和 WPO</p><ul><li>PGO（profile guided optimization） 工具在<em>编译</em>过程中收集程序运行<em>时的</em>数据,然后利用这些数据对程序进行针对性的优化</li><li>WPO（whole program optimization）全局程序优化</li></ul></li></ul></li></ul><h1 id="机组知识回顾：Cache映射"><a href="#机组知识回顾：Cache映射" class="headerlink" title="机组知识回顾：Cache映射"></a>机组知识回顾：Cache映射</h1><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312131543359.png" alt="Cache映射图解"></p><p>上图来自B站视频 <a href="https://www.bilibili.com/video/BV1N8411y7UF/?spm_id_from=333.788&vd_source=caa8e70e79084aa9767fec2791f2ed1d">帮你把Cache映射梳理清楚! | 图解cache映射</a> <sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[帮你把Cache映射梳理清楚! | 图解cache映射](https://www.bilibili.com/video/BV1N8411y7UF/?spm_id_from=333.788&vd_source=caa8e70e79084aa9767fec2791f2ed1d)">[6]</span></a></sup>，感觉讲得比较清晰透彻，可以移步观看，这里再做简单地文字版介绍，提炼下关键点。</p><ul><li>引入 Cache 的原因主要为了减小 CPU 和 主存之间的性能差距，这在前面计算机的存储结构部分也有提及。</li><li>Cache 和 主存间的数据交换以 cache行（cache line &#x2F; cache 块）为单位，一个cache line里包含有多个地址（暂且用物理地址表示），而这里一个地址的长度（一个地址对应的数据大小，几个bits），如果是按字节编址，则一个地址代表一字节，如果按字编址，字的大小为4字节的话，则一个地址代表4字节。</li><li>Cache 中每个 cache 行还对应有标记项，包括有效位、脏位、tag （跟地址映射相关）。</li><li>Cache 和 主存之间有三种地址映射方式，且聚焦的是两边<strong>块号</strong>的对应关系（而不是一个地址到另一个地址）。</li><li>对于一个主存物理地址，可以划分成两部分来看，块号和块内地址，块内地址可通过一个块多大和按什么编址来确定<ul><li>全相联映射：多对多映射，主存中的任意一块都可以映射到 Cache 中的任意一行。因此物理地址中除了块内地址部分，其余位都作为 tag 放入 Cache 的标记项，查询 Cache 时需要遍历所有的 cache 行来确定是否在缓存中<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Cache相联映射 - 知乎](https://zhuanlan.zhihu.com/p/530598945)">[7]</span></a></sup><ul><li>优点：机制灵活，命中率高</li><li>缺点：比较电路难于设计和实现，只适合小容量的 Cache</li></ul></li><li>直接映射：一对一映射，主存的某一块一定映射到 Cache 中的某一行<ul><li>优点：映射方式简单，易实现</li><li>缺点：机制不灵活，Cache 命中率低（多个内存块会映射到 Cache 的同一行，容易发生冲突，替换）</li></ul></li><li>组相联映射：结合全相联映射和直接映射的方式，对 Cache 里的 cache line 进行分组，每组有 2<sup>r</sup> 个 cache line（r&#x3D;1,2,3 即2路，4路，8路），即主存中的每个 cache 块都会映射到 Cache 的固定的一个组中，但在组内又可以随机映射到其中一个 cache line。<ul><li>这样设计，增加了映射的灵活性，主存中的一块可以映射到Cache中的2<sup>r</sup> 块，提供命中率，而每次比较时也只需要进行2<sup>r</sup> 路比较，硬件开销小。</li></ul></li></ul></li></ul><p>以上算是泛泛性的概念介绍，更具体的例子可以再参考  <a href="https://zhuanlan.zhihu.com/p/530598945">Cache相联映射 - 知乎</a> 。</p><hr><p class='note note-primary'>  在学习 Cache 的时候又想到了 TLB ，就有些疑惑两者的工作顺序是怎样的，简单查阅了下资料，<a href="https://www.zhihu.com/question/451989743/answer/2802275354"> <u>TLB与Cache有什么区别</u></a> 知乎上这里的回答感觉还可以，不过 VIPT 这部分还是没太理解透，后续有机会再仔细研究下。</p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.aristeia.com/TalkNotes/ACCU2011_CPUCaches.pdf">CPU Caches and Why You Care</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://igoro.com/archive/gallery-of-processor-cache-effects/">Gallery of Processor Cache Effects</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/374586744">CPU cache line与多线程性能优化 - 知乎</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.xiaolincoding.com/os/1_hardware/cpu_mesi.html">CPU 缓存一致性</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="http://simplygenius.net/Article/FalseSharing">Concurrency Hazards: False Sharing</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1N8411y7UF/?spm_id_from=333.788&vd_source=caa8e70e79084aa9767fec2791f2ed1d">帮你把Cache映射梳理清楚! | 图解cache映射</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/530598945">Cache相联映射 - 知乎</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU</tag>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Function Objects 相关问题记录</title>
    <link href="/2023/11/27/2023-11/2023-11-27%20Function%20Objects%20%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/11/27/2023-11/2023-11-27%20Function%20Objects%20%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此前在学习简单线程池时用到了 <code>std::bind</code> ，所以也学习了相关内容，其中也遇到了一些问题，特此记录一下。原本是打算放在“线程池”那篇文章里作为一个小章节，后来想想这里遇到的问题与原文关系并不是很密切，所以还是单独拆分出来写个小文章。</p><h1 id="Function-Objects"><a href="#Function-Objects" class="headerlink" title="Function Objects"></a>Function Objects</h1><p>Function objects 的定义概念可以直接参考 <a href="https://en.cppreference.com/w/cpp/utility/functional%EF%BC%8C%E7%AE%80%E5%8D%95%E7%BF%BB%E8%AF%91%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8">https://en.cppreference.com/w/cpp/utility/functional，简单翻译一下，就是可以调用</a> operator() 的对象被视作是 function objects，而相关联的函数调用<code>INVOKE</code>文档上也给出了详细说明。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311271133288.png" alt="Function invoaction"></p><p>这里简单总结一下，就是函数调用操作可以视为 <code>INVOKE(f, t1, t2, ... , tN)</code>，可以总结为如下三种情况：</p><ul><li>如果 <code>f</code>是一个指向 <code>T</code> 类成员函数的指针，那么会根据 <code>t1</code> 的类型不同（类型为T或是T的派生类，对象引用，对象指针），采取对应的函数调用方式（<strong>注意，这里的指针也可以是智能指针</strong>）</li><li>如果 <code>f</code>是一个指向 <code>T</code> 类的成员变量，并且 <code>N</code> 为1，则等同于要去访问这个类的成员变量（也会根据<code>t1</code>类型做出适配的调用）</li><li>如果不是上述两种情况，则等同于 <code>f(t1, t2, ..., tN)</code>，进行一次函数调用，这里的 <code>f</code> 就是一个 FunctionObject</li></ul><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><p>然后在看 mem_fn , bind, function 相关实例代码时，对一些传参方式很疑惑，通过用不同的方式来传入对象、指针、引用，会有不同的输出表现，具体示例代码和输出结果如下所示，也可以直接看这个链接 <a href="https://compiler-explorer.com/z/n81o8bssP">https://compiler-explorer.com/z/n81o8bssP</a> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span><br>&#123;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span> num) : <span class="hljs-built_in">num_</span>(num) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_add</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>   </span>&#123; num_ += i;&#125;<br>    <span class="hljs-type">int</span> num_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <br><span class="hljs-function">Foo <span class="hljs-title">ff</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">auto</span> f1 = std::<span class="hljs-built_in">mem_fn</span>(&amp;Foo::print_add);<br>    <span class="hljs-built_in">f1</span>(ff, <span class="hljs-number">1</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;mem_fn pass ff, after exec, ff num : &quot;</span> &lt;&lt; ff.num_ &lt;&lt; endl;<br>    <span class="hljs-built_in">f1</span>(&amp;ff, <span class="hljs-number">1</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;mem_fn pass &amp;ff, after exec, ff num : &quot;</span> &lt;&lt; ff.num_ &lt;&lt; endl;<br><br><br>    <span class="hljs-keyword">auto</span> f2 = std::<span class="hljs-built_in">bind</span>(&amp;Foo::print_add, placeholders::_1, placeholders::_2);<br>    <span class="hljs-built_in">f2</span>(ff, <span class="hljs-number">1</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;bind use placeholder_1 to pass ff, after exec, ff num : &quot;</span> &lt;&lt; ff.num_ &lt;&lt; endl;<br><br>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; f3 = std::<span class="hljs-built_in">bind</span>(&amp;Foo::print_add, ff, placeholders::_1);<br>    <span class="hljs-built_in">f3</span>(<span class="hljs-number">1</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;bind pass ff, after exec, ff num : &quot;</span> &lt;&lt; ff.num_ &lt;&lt; endl;<br><br>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; f4 = std::<span class="hljs-built_in">bind</span>(&amp;Foo::print_add, &amp;ff, placeholders::_1);<br>    <span class="hljs-built_in">f4</span>(<span class="hljs-number">1</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;bind pass &amp;ff, after exec, ff num : &quot;</span> &lt;&lt; ff.num_ &lt;&lt; endl;<br><br>    <span class="hljs-keyword">auto</span> f5 = std::<span class="hljs-built_in">bind</span>(f1, placeholders::_1, placeholders::_2);<br>    <span class="hljs-built_in">f5</span>(ff, <span class="hljs-number">1</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;bind_mem_fn pass ff, after exec, ff num : &quot;</span> &lt;&lt; ff.num_ &lt;&lt; endl;<br><br>    <span class="hljs-keyword">auto</span> f6 = std::<span class="hljs-built_in">bind</span>(f1, placeholders::_1, placeholders::_2);<br>    <span class="hljs-built_in">f6</span>(&amp;ff, <span class="hljs-number">1</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;bind_mem_fn pass &amp;ff, after exec, ff num : &quot;</span> &lt;&lt; ff.num_ &lt;&lt; endl;<br><br><br>    std::function&lt;<span class="hljs-type">void</span>(Foo, <span class="hljs-type">int</span>)&gt; f7 = &amp;Foo::print_add;<br>    <span class="hljs-built_in">f7</span>(std::<span class="hljs-built_in">ref</span>(ff), <span class="hljs-number">1</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;function(Foo), pass ff, after exec, ff num : &quot;</span> &lt;&lt; ff.num_ &lt;&lt;endl;<br><br>    std::function&lt;<span class="hljs-type">void</span>(Foo*, <span class="hljs-type">int</span>)&gt; f8 = &amp;Foo::print_add;<br>    <span class="hljs-built_in">f8</span>(&amp;ff, <span class="hljs-number">1</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;function(Foo*), pass ff*, after exec, ff num : &quot;</span> &lt;&lt; ff.num_ &lt;&lt;endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran">mem_fn <span class="hljs-keyword">pass</span> ff, after exec, ff num : <span class="hljs-number">2</span><br>mem_fn <span class="hljs-keyword">pass</span> &amp;ff, after exec, ff num : <span class="hljs-number">3</span><br><span class="hljs-keyword">bind</span> <span class="hljs-keyword">use</span> placeholder_1 to <span class="hljs-keyword">pass</span> ff, after exec, ff num : <span class="hljs-number">4</span><br><span class="hljs-keyword">bind</span> <span class="hljs-keyword">pass</span> ff, after exec, ff num : <span class="hljs-number">4</span><br><span class="hljs-keyword">bind</span> <span class="hljs-keyword">pass</span> &amp;ff, after exec, ff num : <span class="hljs-number">5</span><br>bind_mem_fn <span class="hljs-keyword">pass</span> ff, after exec, ff num : <span class="hljs-number">6</span><br>bind_mem_fn <span class="hljs-keyword">pass</span> &amp;ff, after exec, ff num : <span class="hljs-number">7</span><br><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(Foo)</span></span>, <span class="hljs-keyword">pass</span> ff, after exec, ff num : <span class="hljs-number">7</span><br><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(Foo*)</span></span>, <span class="hljs-keyword">pass</span> ff*, after exec, ff num : <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><hr><p>那么根据输出结果不难发现如下几个现象：</p><ol><li>对于 mem_fn 也就是代码里的 f1 ，无论传入的是 ff 还是 &amp;ff ，执行后都是能正常修改 ff 对象中的 num_ 值。</li><li>对于 bind，如果提前绑定了 ff，则执行后并没有修改 ff 对象中的 num_ 值；而如果使用 placeholder 或者 传入 &amp;ff ，则也可以正常修改。</li><li>对于 function，如果指定第一个参数为 Foo，此时传入 ff，执行后也没有修改 ff 对象中的 num_ 值。</li></ol><p>所以我当时就挺困惑的，为什么会有上述的差异，对应的原理又是什么？后来也是查阅了一天，并最终在 StackOverflow 上提问后，得到了解答，具体可以看这个链接 <a href="https://stackoverflow.com/questions/77542768/mem-fn-bind-function-difference-when-passing-parameters/77542820?noredirect=1#comment136703728_77542820">StackOverflow 提问</a> 。</p><h1 id="分析思考"><a href="#分析思考" class="headerlink" title="分析思考"></a>分析思考</h1><p>简单来说，相似的传参方式却得到了不同的结果，如代码里的 <code>f1(ff,1)</code> 和 <code>f7(ff,1)</code>，这其实是由于传参时一个是 pass by reference，一个是 pass by value 导致的。下面会进一步地对上述三点进行分析。</p><ol><li>对于 <code>mem_fn</code> 的表现，也就是 <code>f1</code> 和 <code>f2</code>，他们传值方式都是 pass by reference，这一点可以在 <a href="https://en.cppreference.com/w/cpp/utility/functional/mem_fn">https://en.cppreference.com/w/cpp/utility/functional/mem_fn</a> 得到证实，可以看到 <code>operator()(Arg&amp;&amp;... args)</code>形参格式为 <code>Args&amp;&amp;</code> 引用格式，然后进行完美转发再执行函数调用，那么此时就又可以联想之前提到的 <code>INVOKE</code> 调用规则。因为是引用，所以传入<code>ff</code>对象后执行调用能够直接修改对象，传入<code>&amp;ff</code>调用也是修改 <code>ff</code> 对象本身。</li></ol><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311271133362.png" alt="Member function"></p><ol start="2"><li>对于 <code>std::bind</code>，返回一个 function object，对该 object 传入的参数都是拷贝或者移动，除非使用 <code>std::ref</code> 或者 <code>std::cref</code>表示传入引用，所以传入 <code>ff</code> 或者 <code>&amp;ff</code>时都是进行拷贝，在真正 <code>INVOKE</code>时 <code>f3</code> 不能修改<code>ff</code> 对象，<code>f4</code> 可以。当但使用 <code>placeholders</code> 时，可以看到对应说明，会将对应传入的参数转发，转变成 &amp;&amp; 引用类型，因此这是传入是个引用，所以 <code>f2</code> 的调用能够修改 <code>ff</code> 对象。</li></ol><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311271133403.png"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311271133452.png" alt="Notes"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311271133508.png" alt="placeholders"></p><hr><p>对于 std::bind 参数的拷贝，还值得注意的是，在 bind 的时候拷贝的是实参，在真正调用执行时才去拷贝形参，所以当拷贝指针的值时候需要特别注意对应的生命周期。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct A &quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct A from a&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct B &quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> A&amp; a)  &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct B from A&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(B b)</span> </span>&#123;<br>    cout &lt;&lt;<span class="hljs-string">&quot;do test&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ready to do bind&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">auto</span> f = std::<span class="hljs-built_in">bind</span>(test, a);<br>    cout &lt;&lt; <span class="hljs-string">&quot;ready to do test&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">f</span>();<br>&#125;<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-comment">// construct A </span><br><span class="hljs-comment">// ready to do bind</span><br><span class="hljs-comment">// construct A from a</span><br><span class="hljs-comment">// ready to do test</span><br><span class="hljs-comment">// construct B from A</span><br><span class="hljs-comment">// do test</span><br></code></pre></td></tr></table></figure><ol start="3"><li>对于 <code>std::function</code>，可以看到对应的 <code>operator()</code>接受参数的类型是 <code>Args...</code> 而不是 mem_fn 的 <code>Args&amp;&amp;...</code>，注意到这两者细微的差别了么？这里其实就隐含说明传入的参数都是拷贝传入的，所以 <code>f7</code> 执行后并不会影响 <code>ff</code> 对象。</li></ol><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311271133587.png" alt="std::function operator()"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此次遇到的问题，简单来说，就是对于某个结果现象不理解，或者说是不符合预期而产生疑惑，但其实从这个现象，再结合一下C++知识，不难想到一个是值传递一个是引用传递，但我当时就是没有找到对应的佐证，来说明为什么这里是值传递或是引用传递。后来也是仔细翻阅了 cppreference 上的说明，才看到证据，不过限于我个人能力，可能上述的分析也仅仅是我个人的推测，自身也没有很透彻地理解，所以如果哪里理解有误，还请联系我进行改正。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【骚操作】制作一个炫酷的Github个人主页</title>
    <link href="/2023/11/19/2023-11/2023-11-19%E3%80%90%E9%AA%9A%E6%93%8D%E4%BD%9C%E3%80%91%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%82%AB%E9%85%B7%E7%9A%84Github%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/"/>
    <url>/2023/11/19/2023-11/2023-11-19%E3%80%90%E9%AA%9A%E6%93%8D%E4%BD%9C%E3%80%91%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%82%AB%E9%85%B7%E7%9A%84Github%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>废话不多说，直接上图。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311201610533.png"></p><center>👆<em>图片来源：itgoyo 个人主页<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/itgoyo">[1]</span></a></sup></em></center><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311201612706.png"></p><center>👆<em>图片来源：二丫讲梵 个人主页<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/eryajf">[2]</span></a></sup></em></center><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311201618499.png"></p><center>👆<em>图片来源：Hein Thant 个人主页<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/IndieCoderMM">[3]</span></a></sup></em></center><hr><p>怎么样，看到这些风格各异的个人主页，是不是大为震撼，<del>够不够炫酷，够不够花哨</del>，如果你也想包装下自己，好好打扮下个人主页，那就请继续阅读下文实操部分。</p><h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><p>其实修改的原理很简单，就是创建一个与自己Github账号同名的一个仓库，然后添加一个<text>README.md</text>文件，在该文件中编辑填写自己的个人介绍，就像下面提示的那样。而markdown文件支持内嵌html，因此借助一些大佬提供的开源http服务，请求对应的资源，就可以排版设计出漂亮美观的个人主页。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311201638069.png" alt="创建同名仓库"></p><p>那么，上哪去找美观炫酷的模板呢？可以看看这个仓库 <a href="https://github.com/LHRUN/bubble">https://github.com/LHRUN/bubble</a><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Github Profile素材仓库](https://github.com/LHRUN/bubble)">[5]</span></a></sup>，这个仓库提供了一个素材库链接<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://bubble-awesome-profile.vercel.app/">[4]</span></a></sup>，里面包含各种组件，可以形象生动地展示你的Github数据，像是commit，stars，pr等。此外，上面这个仓库也收集了很多Github用户的个人主页，你也可以从中挑选自己中意的排版，然后参考对应的代码进行设计。更简单粗暴的方式，就是通过fork他&#x2F;她的仓库，然后将仓库名改为自己的Github名称，就可以拥有与之相同的个人主页。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>虽然炫酷花哨的个人主页，的确能令人耳目一新，但也别忘了Github社区的初衷，多多参与学习优质的开源项目，贡献自己的知识和方案，在各种思想交流碰撞中，成长为一名Geek。切忌因小失大，沉迷折腾些边角料的事，就像这次修改自己的个人主页，没有实质性的内容和出彩项目，没有实打实的数据支撑，包装得再如何美观，都只是流于表面罢了。</p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://github.com/itgoyo">https://github.com/itgoyo</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://github.com/eryajf">https://github.com/eryajf</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://github.com/IndieCoderMM">https://github.com/IndieCoderMM</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://bubble-awesome-profile.vercel.app/">https://bubble-awesome-profile.vercel.app/</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://github.com/LHRUN/bubble">Github Profile素材仓库</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>骚操作系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++简单线程池</title>
    <link href="/2023/11/17/2023-11/2023-11-17%20C++%E7%AE%80%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2023/11/17/2023-11/2023-11-17%20C++%E7%AE%80%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前对C++多线程这块一直不太熟悉，而恰好这段时间看到一段简单线程池实现的代码，所以想着不如趁此机会学习一下。本文会先介绍下线程池实现里用到的相关同步原语，如互斥锁和条件变量，再来简单分析其实现。</p><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>正如《Linux多线程服务端编程》一书中指出，“互斥器（mutex）恐怕是用得最多的同步原语，粗略地说，它保护了临界区，任何一个时刻最多只能由一个线程在此mutex划出的临界区内活动。单独使用mutex时，我们主要为了保护共享数据”。书中也提到了使用mutex时建议的四个原则：</p><ul><li>用RAII手法封装mutex的创建、销毁、加锁、解锁这四个操作。</li><li>只用非递归的mutex（即不可重入的mutex）。</li><li>不手工调用lock() 和 unlock() 函数，一切交给栈上的Guard对象的构造和析构函数负责。</li><li>在每次构造Guard对象的时候，思考一路上（调用栈上）已经持有的锁，防止因加锁顺序不同而导致死锁。</li></ul><p>这里仅对上述的第三点展开介绍实际用法，通常 <code>std::mutex</code> 都会结合 <code>std::lock_guard、std::scoped_lock、std::unique_lock</code> 来使用。</p><p>其中 <code>std::lock_guard</code> 的用法如下所示，基本上就是在构造的时候传入一个 mutex，在它的构造函数中会执行 <code>mutex.lock()</code> ，而在 <code>lock_guard</code> 析构函数中会执行 <code>mutex.unlock()</code> 从而实现了自动的加锁和解锁操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::mutex g_mutex;<br><br>&#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(g_mutex)</span></span>;<br><span class="hljs-comment">// 以下都是临界区</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::scoped_lock</code> 和 <code>std::lock_guard</code> 用法类似，主要区别在于 std::scoped_lock 支持同时为多个 mutex 进行上锁和解锁，基本用法如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::mutex m1, m2;<br><br>&#123;<br>std::<span class="hljs-built_in">scoped_lock</span>(m1,m2);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>std::unique_lock 相比 std::lock_guard 更多加的灵活，拥有更多的成员函数，如 <code>lock() , unlock() </code>等，也就是说 unique_lock 可以提前释放锁，而不必等到析构的时候再释放，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::mutex g_mutex;<br><br>&#123;<br>  <span class="hljs-function">std::unique_lock <span class="hljs-title">lk</span><span class="hljs-params">(g_mutex)</span></span>;<br>  <span class="hljs-comment">// 临界区</span><br>  ...<br>  <span class="hljs-comment">// 提前释放锁</span><br>  lk.<span class="hljs-built_in">unlock</span>();<br>  <span class="hljs-comment">// 做一些后续的处理</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><center><figure class="half">    <img   src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311301139801.png" width="45%"/> <img  src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311301139253.png" width="45%" />  <br>  <em>左: lock_guard，右: unique_lock </em> </figure> </center><h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p>condition_variable 条件变量是C++11中就有的class，通过使用 std::mutex 来实现同步原语，这里简单介绍下两个关键的成员函数<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[C++11条件变量condition_variable详解](https://zhuanlan.zhihu.com/p/599172163)">[1]</span></a></sup>。</p><h2 id="wait函数使用"><a href="#wait函数使用" class="headerlink" title="wait函数使用"></a>wait函数使用</h2><p>正如 cppreference 里描述的那样，condition_variable 的 wait 函数提供了两种函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span> <span class="hljs-params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;（<span class="hljs-number">1</span>）<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Predicate</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span> <span class="hljs-params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;（<span class="hljs-number">2</span>）<br></code></pre></td></tr></table></figure><ul><li><p>对于函数原型（1），执行 wait 函数，会直接解锁传入的互斥量并阻塞当前线程，直到其他的某个线程调用 notify_one 或者 notify_all 后，该线程被唤醒，<strong>会重新尝试获取互斥量</strong>，如果得不到线程就会阻塞在这里，直到获取到互斥量为止才会结束 wait，继续执行下面的代码。</p></li><li><p>对于函数原型（2），等同于如下的代码，该函数主要用于避免一些虚假唤醒（spurious awakenings）的情况，通过指定的判断条件决定是否继续等待。需要注意的事，<strong>在进入该循环前，必须要获取到互斥量，而执行完 wait 后，也需要重新获取到互斥量</strong>，即这里的互斥量会保护执行 stop_waiting() 。</p></li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">stop_waiting</span>())<br>&#123;<br>    <span class="hljs-built_in">wait</span>(lock);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>wait 函数的具体使用方法可以参考下面代码<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[condition_variable wait 示例代码](https://en.cppreference.com/w/cpp/thread/condition_variable/wait)">[2]</span></a></sup> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>std::condition_variable cv;<br>std::mutex cv_m;    <span class="hljs-comment">// This mutex is used for three purposes:</span><br>                    <span class="hljs-comment">// 1) to synchronize accesses to i</span><br>                    <span class="hljs-comment">// 2) to synchronize accesses to std::cerr</span><br>                    <span class="hljs-comment">// 3) for the condition variable cv</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">waits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cv_m)</span></span>;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; Waiting...\n&quot;</span>;<br>    cv.<span class="hljs-built_in">wait</span>(lk, []&#123; <span class="hljs-keyword">return</span> i == <span class="hljs-number">1</span>; &#125;);<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; ...finished waiting. i == 1\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signals</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cv_m)</span></span>;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Notifying...\n&quot;</span>;<br>    &#125;<br>    cv.<span class="hljs-built_in">notify_all</span>();<br><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br><br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cv_m)</span></span>;<br>        i = <span class="hljs-number">1</span>;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Notifying again...\n&quot;</span>;<br>    &#125;<br>    cv.<span class="hljs-built_in">notify_all</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(waits, <span class="hljs-number">1</span>)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(waits, <span class="hljs-number">2</span>)</span>, <span class="hljs-title">t3</span><span class="hljs-params">(waits, <span class="hljs-number">3</span>)</span>, <span class="hljs-title">t4</span><span class="hljs-params">(signals)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    t3.<span class="hljs-built_in">join</span>();<br>    t4.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>其中一组可能的输出为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">num:3 Waiting...<br>num:1 Waiting...<br>num:2 Waiting...<br>Notifying...<br>Notifying again...<br>num:3 ...finished waiting. i == 1<br>num:2 ...finished waiting. i == 1<br>num:1 ...finished waiting. i == 1<br></code></pre></td></tr></table></figure><p>简单分析一下上面的代码和输出结果：在 main 函数中创建了三个 waits 线程和一个 signals 线程，然后主线程等待所有线程执行完毕。由于 signals 线程会先 sleep 1 秒，所以先执行三个 waits 线程，而这三个线程执行的顺序是随机的，当其中一个线程先执行拿到锁后，执行输出 Waiting（输出结果里第一个执行的就是线程3），然后执行 wait ，由于不满足条件所以会释放锁并阻塞当前线程。紧接着，其他两个由于没有拿到互斥锁而被阻塞的线程，其中一个拿到了锁，也继续往下执行，重复类似的操作。最后三个线程都在等待被唤醒。</p><p>signals 线程睡眠完之后，继续往下执行，第一次执行 notify_all，唤醒了等待的三个线程，而每个线程唤醒也都会去尝试获取互斥锁，因此此时三个线程还是相当于以随机顺序串行执行，但是因为没有满足退出等待的条件（i &#x3D;&#x3D; 1），所以又会释放锁并进入等待。signals 线程将 i 赋值为1后，第二次执行 notify_all，此时waits 三个线程依次拿到锁，并判断结束条件成立后，继续往下执行输出，最终输出的顺序也是随机的。</p><h2 id="notify-one-notify-all"><a href="#notify-one-notify-all" class="headerlink" title="notify_one &amp; notify_all"></a>notify_one &amp; notify_all</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify_one</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify_all</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><p>两个 notify 的函数原型也都比较简单，其中 notify_one 是去唤醒当前条件变量等待队列里的一个线程，如果没有线程在等待，则函数不执行任何操作，如果等待的线程多于一个，则唤醒的线程是随机的。notify_all 则是去唤醒所有正在等待的线程。</p><p> 在 cppreference 指出，通知线程不需要持有与等待线程线程相同的互斥锁，如果持有的话，反而可能是一种性能劣化，因为被通知的线程因为无法获取到锁而再次阻塞，直到通知线程释放锁。因此，一些实现（特别是许多pthread实现）为识别这种情况，在 notify 调用中，会直接将等待线程从条件变量的等待队列中转移到互斥锁的等待队列里，从而避免了这种 “hurry up and wait” 情况。</p><h1 id="线程池实现"><a href="#线程池实现" class="headerlink" title="线程池实现"></a>线程池实现</h1><p>一个简单线程池的实现如下所示，这里针对每个成员函数作简要分析。</p><ul><li>首先是构造函数，就是在启动多个 worker 线程，执行 <code>Run</code> 这一循环函数。</li><li>析构函数，主要是去调用 <code>Stop</code> 函数，终止所有 worker 线程，进行资源回收。</li><li><code>AddTask</code> 函数，使用 <code>std::bind</code> 将传入的参数转化为 function object，加入到 <code>pending_tasks_</code> 队列中，并利用条件变量去唤醒一个空闲的 worker 线程去执行对应任务。（这里还有 Parameter Pack 相关知识点，后续有机会再展开讲讲。）</li><li><code>Stop</code> 函数，唤醒所有 worker 线程，等待所有线程处理完当前任务后退出线程，回收线程资源。</li><li><code>Run</code> 函数，worker 线程的运行的循环函数，通过条件变量的 <code>wait</code> 来判断当前是否有待处理的任务或者线程池是否终止，如果收到终止信号，则退出死循环，否则从任务队列中取出一个任务执行。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleThreadPool</span> <span class="hljs-keyword">final</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SimpleThreadPool</span>(<span class="hljs-type">size_t</span> num_threads) : <span class="hljs-built_in">num_threads_</span>(num_threads) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num_threads; ++i) &#123;<br>            workers_.<span class="hljs-built_in">emplace_back</span>(&amp;SimpleThreadPool::Run, <span class="hljs-keyword">this</span>, i);<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">SimpleThreadPool</span>() &#123; <span class="hljs-keyword">if</span>(!stop_) &#123; <span class="hljs-built_in">Stop</span>(); &#125; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Func, <span class="hljs-keyword">class</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">AddTask</span><span class="hljs-params">(Func &amp;&amp;func, Args &amp;&amp;... args)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> task = std::<span class="hljs-built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...);<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mutex_)</span></span>;<br>        pending_tasks_.<span class="hljs-built_in">push</span>(task);<br>        cv_.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span> </span>&#123;<br>        &#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mutex_)</span></span>;<br>            <span class="hljs-keyword">if</span> (stop_) &#123; <span class="hljs-keyword">return</span>; &#125;<br>            stop_ = <span class="hljs-literal">true</span>;<br>            cv_.<span class="hljs-built_in">notify_all</span>();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;w: workers_) &#123; w.<span class="hljs-built_in">join</span>(); &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">(<span class="hljs-type">size_t</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            std::function&lt;<span class="hljs-type">void</span>()&gt; task;<br>            &#123;<br>                <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mutex_)</span></span>;<br>                cv_.<span class="hljs-built_in">wait</span>(guard, [<span class="hljs-keyword">this</span>]() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;stop_ || !<span class="hljs-keyword">this</span>-&gt;pending_tasks_.<span class="hljs-built_in">empty</span>(); &#125;);<br>                <span class="hljs-keyword">if</span> (stop_) &#123; <span class="hljs-keyword">break</span>; &#125;<br>                task = std::<span class="hljs-built_in">move</span>(pending_tasks_.<span class="hljs-built_in">front</span>());<br>                pending_tasks_.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-built_in">task</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> num_threads_;<br>    <span class="hljs-keyword">mutable</span> std::mutex mutex_;<br>    <span class="hljs-keyword">mutable</span> std::condition_variable cv_;<br>    std::queue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; pending_tasks_;<br>    std::vector&lt;std::thread&gt; workers_;<br>    <span class="hljs-type">bool</span> stop_&#123;<span class="hljs-literal">false</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/599172163">C++11条件变量condition_variable详解</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">condition_variable wait 示例代码</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中国银行总行面试经历</title>
    <link href="/2023/11/16/2023-11/2023-11-16%20%E4%B8%AD%E5%9B%BD%E9%93%B6%E8%A1%8C%E6%80%BB%E8%A1%8C%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    <url>/2023/11/16/2023-11/2023-11-16%20%E4%B8%AD%E5%9B%BD%E9%93%B6%E8%A1%8C%E6%80%BB%E8%A1%8C%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>中国银行的面试应该会是我秋招里的最后一场面试吧，我的秋招大概，也许，会止步于此了，之后尘埃落定的话估计会再写一篇总结吧。而此次银行总行的面试形式也是第一次参与，像是无领导面试、英语面试等，所以也特此记录一下，为后来者提供参考。</p><h1 id="面试经历"><a href="#面试经历" class="headerlink" title="面试经历"></a>面试经历</h1><p> 此次我应聘的是信息科技管培生的岗位，具体流程的话，先是签到，然后抽签分组，先进行无领导小组面试，然后序号靠后的先进行英语面试，靠前的则是先进行结构化面试，然后再进行交换。</p><p>首先讲讲无领导小组面试，基本是每组6个人进行讨论，时间安排的话，会有7分钟看材料时间，然后是30分钟的自由讨论，并且最终需要一个白板汇报（汇报的时间也是算在30分钟里）。我们这组抽到的题目是设计一个自驾游APP，老实说，因为是第一次参加这种无领导面试，多少是紧张的，基本没什么思路，当别人已经在刷刷地开始动笔时，我在慢吞吞地看材料，想不出所以然来，到最后也只是将材料给出的三个用户痛点简单复述写了下。到正式开始讨论时，其他同学也是各显神通，纷纷踊跃发言，而我在其中显得有些不知所措，想要说些什么，却被人抢着话说。原先我真是想得太简单了，自以为是很有勇气、敢于发言的类型，但其实多少是有些狂妄自大了，真到了那个激烈讨论的场景下，没有足够的底气和自信，以及知识储备，是很难打破自己的心理障碍，来参与到这场思维的碰撞之中。到最后，我好像说过的话也没超过3句，老实说还是心态没有摆正，或者说在中途已经破防了，已经放弃了，已经想着”算了，算了，都这样了，就当重在参与了“。或许说错话并不可怕，但令人悲哀的是连发声的勇气都丧失了，令人痛心疾首的是，我甚至不愿坚持到最后，不愿去面对这场挑战和苦难，而是早早地丢盔卸甲，成了一名逃兵。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311161859672.webp"></p><p>接着我是再去英语面试，中行的英语面试形式也很新颖，采取了辩论的形式，我和同组的另一名成员一起和另外两名同学进行英语的辩论，具体时间安排是，5分钟的看辩题思考，5分钟的小组讨论，5分钟的自由辩论。我这边抽到的题目是 <em>The railway shoud charge less for non-seat tickets</em>. 一开始看题思考的时候，我还把railway理解成了地铁的意思，到后小组讨论的时候才明白过来，真是令人苦笑不得。然后自由辩论的过程的话，基本又是重现了无领导小组的情景，基本又是没插上一句话，全程看着 teammate 和对方展开论述交流。最后唯一的发言，也是磕磕绊绊。现在复盘来看，主要还是缺乏开口的勇气，因为没有听懂对方在说什么，从而导致无力开口，继而放弃发言，其实真的没什么，没听清楚的话就让对方再论述一遍，同时亮明自己的观点即可，最重要的还是自信，还是要敢于发言，不必去追求流利或语速，关键说清楚观点、关键字。</p><p>那么最后是结构化面试，就是给了一张纸，纸上会有三道题，每道题会有2~3分钟的作答时间，我的话，第一道是一句”习语“，大意是年轻人要直面苦难挑战，争做时代弄潮儿，需要谈谈自己的理解，以及未来如何在工作中践行；第二道的话是二选一作答，一个是实现一个函数，给定一个字符串，对其中的元音字母进行反转，另一个选择时讲讲在推荐系统中如何解决冷启动问题；第三道是针对于数字化医疗科技，有人认为有好有坏，来谈谈自己的理解。答完之后的话，面试也追问了一些问题，比如就有面试官问我为什么在无领导小组讨论期间基本没有说话，我也只能笑着如实回答。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次的面试又是一次对我的拷打，也体现出了我的种种不足，我可以有很多理由来掩盖这次失利，来逃避这次失败，来欺骗安慰自己没有关系，但问题终究是没有解决。原地踏步，不思进取，那又怎么在众人之中脱颖而出？</p>  <p class='note note-info' ><font size='5'>你反手无力，正手不精，脚步松散，反应迟钝，没一个动作像样，就你这样还想给我同台较量吗？做你的美梦！</font>  <br>    <font size='4' align='right'><i align="right">——《乒乓》</i></font></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202311161716081.png" alt="乒乓-孔文革"></p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋招浅谈</title>
    <link href="/2023/10/17/2023-10/%E7%A7%8B%E6%8B%9B%E6%B5%85%E8%B0%88/"/>
    <url>/2023/10/17/2023-10/%E7%A7%8B%E6%8B%9B%E6%B5%85%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">  没想到鸽了一年多，居然会是这样的方式，在这样的一个时间来更新博客，或许，真的是有些失败吧。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202310172029585.jpeg"></p><hr><p>更新的起因，还是因为今天下午华为的面试，最后在业务主管面挂掉了，在官网上查询到结果的那一刻莫名的电流涌过全身，嘴里喃喃着，“是吗，这样吗。。。”</p><p>“我还是失败了呢。”</p><p>就像是压垮骆驼的最后一根稻草，这一次的失利也让我百感交集，冲破了我的防线（虽然我也已经麻木了）。回头想想，主管挂人也并非毫无道理，首先一个是二面第一次的手撕题没写出来（虽然二面是过了），另一个是可能交流的时候，没有表达出迫切想要去的意愿，可能表现出来的还是那种找找机会的态度，另外的话，可能就是谈吐哪里不得体，或者哪个部分触及雷区了，或者暴露我本性无能了？或许吧，但无论如何，从结果上看，我跟华为的缘分似乎到此为止了，不，应该是彻底结束了，彻彻底底，绝无可能。</p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202310172207348.jpeg" alt ="不甘心" width="50%" height="50%" align="middle"/></center><p>是啊，从8月底回学校开始正式努力准备秋招，到现在10月中旬多，除了字节的转正争取到的意向，没有再拿到其他的意向或是offer了，再除去还在泡池子的快手和阿里云，其他所有的投递都失败了，失败得如此彻底。开始前手握有一个意向，快结束了也只有这一个，多少有些悲凉，不是么。想想开始时的意气奋发，对中小厂的置之不理，不愿投递，进行时的四处碰壁，各种拷打，后悔莫及时的匆忙投递，亡羊补牢，以及最后的一败涂地，竹篮打水一场空，多少有些讽刺，不是么？</p><p>想想自身的原因，第一，秋招准备得晚，8月底才开始准备，各类提前批也都没敢尝试投递，如果早点开始准备，结果会不会不一样，可是从来没有如果；第二，秋招期间还不够努力，只投入了80%的时间，没有投入100%，所以才会有这种不上不下的失落感，不甘心，“如果当初自己把那些娱乐时间都投入进去，结果会不会不一样”，可是从来没有如果；第三；秋招准备的策略还是有点问题，或者说执行力不够，明明早就计划要提前梳理完一遍八股相关知识，但迟迟没有按计划执行，倒是以各种面试、笔试占据时间为由而推脱，小林coding 的网站甚至是昨天才刚打开，如果能提前一个月复习一遍，结果会不会不一样，可是没有如果；第四，性格不够成熟，态度不够诚恳，面试的没有表达出强烈想去对方部门的意愿，显得有些随性，可能在对方看来我只是来碰个运气找找机会，能争取到最好，没有也无所谓的态度。<del>（字节保底带来的自负）</del></p><p>再想想可能的客观原因吧（让自己好受些），第一，地域劣势，身处软微，跑到本部或是市区要大费周折，特别折腾，所以不是意愿特别强烈的公司单位不想跑一趟，也因此错过了本部大量的宣讲会和招聘会，或许就错过了不少好的机遇；第二，两段实习经历都在字节，时间也特别长，不难让人联想你对字节的一个忠诚度，以及去别的公司的可能性，或许就是，成也字节，败也字节。</p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202310172156548.jpeg" width="50%" height="50%" align="middle"/></center></br><p>不过秋招还没正式结束，倒也不必如此悲观，继续备战，等待时机，不以物喜不以己悲。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202310172213561.jpeg"></p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++测试工具</title>
    <link href="/2022/07/30/2022-07/C++%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/07/30/2022-07/C++%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说来惭愧，断更了一个多月了，一方面的确是最近开始实习，时间变得紧张起来，另一方面也的确是自己偷懒了，松懈了不少。另外，比较难受的是，本来这篇博文已经在另一台电脑上写好了大概，准备上周就发的，但是因为被一些事情耽搁了，结果这周再去找的时候，结果发现原文找不到了，真的是老倒霉蛋了，所以只能硬着头皮重新写一篇 QAQ。</p><h1 id="gtest"><a href="#gtest" class="headerlink" title="gtest"></a>gtest</h1><p>那么首先来介绍GoogleTest（简称gtest），这是由google推出的C++测试框架，其功能之强大自然不必多说，接下来就简单介绍gtest的相关概念及其使用，更多的使用说明可以参考官方文档：<a href="https://google.github.io/googletest/primer.html">https://google.github.io/googletest/primer.html</a></p><p>首先介绍一些术语概念，分别是 <em>Test</em>, <em>Test Case</em> and <em>Test Suite</em> ，这几个单词在gtest框架中的含义 与在<a href="http://www.istqb.org/">ISTQB</a>（国际软件测试资质认证委员会）定义的含义有所不同，这里就介绍在gtest里的含义。因为历史原因，在gtest中， <em>Test</em> 认为是一个单元测试程序（指定输入，检测输出），而 <em>Test Cast</em> 被认为是一组相关的测试，现在，google开始用 <em>Test Suite</em> 来替换 <em>Test Case</em>。</p><p>此外，还有一些基本概念，例如在gtest中，使用断言（Assertion）判断一个条件成立与否，一个 Assertion 的结果可以是success, non-fatal failure, or fatal failure， 如果是fatal failure 则测试程序直接终止，而如果是non-fatal failure，则程序程序继续执行，只有当测试程序没有出现任何 failure 时，测试才算通过。一个 Test Suite可以包含多个 test，这些 test 可以共享一些对象和流程，可以放在 TestFixture class中。而一个测试程序可以包含多个 Test Suite。</p><p>刚刚提到了Assertion 断言，相关的API就是ASSERT_ * 和 EXPECT_ * ，如果ASSERT失败了则程序执行，而EXPECT失败了，则程序会继续执行下面的测试。可以使用TEST() 宏定义来创建一个简单的单元测试，同时gtest使用TestSuiteName来汇总test，所以具有相关性的test使用相同的TestSuiteName。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;...&#125;<br><br><span class="hljs-built_in">TEST</span>(TestSuiteName, TestName1) &#123;<br>  <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-built_in">func</span>(<span class="hljs-number">0</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-built_in">TEST</span>(TestSuiteName, TestName2) &#123;<br>  <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-built_in">func</span>(<span class="hljs-number">0</span>), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，<strong>TestSuiteName 和 TestName 最好不要使用下划线</strong>，因为在gtest源码中，会使用下划线将它们拼接成一个类名。这再简单介绍下gtest的实现吧，当我们使用TEST编写好一个test，该宏会将其展开为一个类，并声明一个TestBody函数，而TestBody的实现就是TEST里用户编写的逻辑。</p></blockquote><p>而当TestSuite中有公共流程时，就可以提取出来，避免重复编写，这就是TestFixture。TestFixture需要使用TEST_F来定义test，其中<code>SetUp</code>函数在会在每次TEST_F执行前初始化一次，<code>TearDown</code> 函数则是每次在执行完之后执行，释放资源。一个简单例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gtest/gtest.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FuncTest</span> : <span class="hljs-keyword">public</span> ::testing::Test &#123;<br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>     q1_.<span class="hljs-built_in">Enqueue</span>(<span class="hljs-number">1</span>);<br>     q2_.<span class="hljs-built_in">Enqueue</span>(<span class="hljs-number">2</span>);<br>     q2_.<span class="hljs-built_in">Enqueue</span>(<span class="hljs-number">3</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>  &#125;<br><br>  Queue&lt;<span class="hljs-type">int</span>&gt; q0_;<br>  Queue&lt;<span class="hljs-type">int</span>&gt; q1_;<br>  Queue&lt;<span class="hljs-type">int</span>&gt; q2_;<br>&#125;;<br><br><span class="hljs-built_in">TEST_F</span>(FuncTest, IsEmptyInitially) &#123;<br>  <span class="hljs-built_in">EXPECT_EQ</span>(q0_.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-built_in">TEST_F</span>(FuncTest, DequeueWorks) &#123;<br>  <span class="hljs-type">int</span>* n = q0_.<span class="hljs-built_in">Dequeue</span>();<br>  <span class="hljs-built_in">EXPECT_EQ</span>(n, <span class="hljs-literal">nullptr</span>);<br><br>  n = q1_.<span class="hljs-built_in">Dequeue</span>();<br>  <span class="hljs-built_in">ASSERT_NE</span>(n, <span class="hljs-literal">nullptr</span>);    <span class="hljs-comment">// 继续运行已无必要，失败时直接中断</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(*n, <span class="hljs-number">1</span>);         <span class="hljs-comment">// 继续运行暴露更多问题</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(q1_.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">delete</span> n;<br><br>  ....<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  ::testing::<span class="hljs-built_in">InitGoogleTest</span>(&amp;argc, argv);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">RUN_ALL_TESTS</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>整体流程：</p><ol><li><p>缓存gtest flags的状态；</p></li><li><p>为第一个test创建TestFixture对象；</p></li><li><p>gtest创建FuncTest对象（o1）；</p></li><li><p>o1.SetUp()；</p></li><li><p>基于o1，运行第一个test（IsEmptyInitially）；</p></li><li><p>o1.TearDown；</p></li><li><p>析构o1；</p></li><li><p>在gtest flags中存储状态；</p></li><li><p>重复上述操作，运行下一个test（DequeueWorks），一直到结束；</p></li></ol><p class='note note-info'>  还值得一提的是，如果需要访问private & protected 成员和函数，可以添加编译选项 -fon-access-control，如果使用cmake的话，可以添加 ADD_COMPILE_OPTIONS(-fno-access-control) </p><h1 id="gmock"><a href="#gmock" class="headerlink" title="gmock"></a>gmock</h1><p>gmock也是gtest测试框架中的重要组成部分，当我们测试一个模块的时候，可能涉及到和其他模块交互，此时可以将模块之间的接口mock，模拟交互过程，其作用类似白盒测试中的打桩的概念。（打桩是软件测试里单元测试的一种方法，单元测试涉及手工编写测试集、指定输入数据以及为缺少的函数提供桩函数。给桩函数提供返回值叫做打桩。）</p><p>关于gmock的使用也可以查阅官方文档：<a href="https://google.github.io/googletest/gmock_for_dummies.html">https://google.github.io/googletest/gmock_for_dummies.html</a></p><p>其基本使用方式为，当需要mock某一个类的成员方法（注意：需要声明为<strong>虚函数</strong>），定义一个派生类，然后继承需要mock的类，并声明<code>MOCK_METHOD</code> ，然后设置<code>EXPECT_CALL</code>指定其函数的返回行为。如下面的例子所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// origin file</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Origin</span> &#123;<br>    virutal ~<span class="hljs-built_in">Origin</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Do</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Do2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// --------------------------------------------------------------</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gmock/gmock.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mock</span>: <span class="hljs-keyword">public</span> Origin &#123;                       <span class="hljs-comment">// 派生</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">MOCK_METHOD</span>(<span class="hljs-type">int</span>, Do, (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y), (<span class="hljs-keyword">override</span>));<br>        <span class="hljs-built_in">MOCK_METHOD</span>(<span class="hljs-type">int</span>, Do2, (), (<span class="hljs-type">const</span>, <span class="hljs-keyword">override</span>));<br>&#125;;<br><br><span class="hljs-keyword">using</span> ::testing::Return;                          <span class="hljs-comment">// 引入依赖函数</span><br><span class="hljs-keyword">using</span> ::testing::_;                               <span class="hljs-comment">// 引入依赖函数</span><br><br><span class="hljs-built_in">TEST</span>(BarTest, DoesThis) &#123;<br>  MockFoo foo;                                    <span class="hljs-comment">// 构建mock对象</span><br><br>  <span class="hljs-built_in">ON_CALL</span>(foo, <span class="hljs-built_in">Do2</span>())                         <span class="hljs-comment">// 设置默认行为,不要求被调用</span><br>      .<span class="hljs-built_in">WillByDefault</span>(<span class="hljs-built_in">Return</span>(<span class="hljs-number">1</span>));<br><br>  <span class="hljs-built_in">EXPECT_CALL</span>(foo, <span class="hljs-built_in">Do2</span>(<span class="hljs-number">5</span>, _))                   <span class="hljs-comment">// 开始设置命中matcher(x=50)期望</span><br>      .<span class="hljs-built_in">Times</span>(<span class="hljs-number">3</span>)                                 <span class="hljs-comment">// 期望被调用的次数</span><br>      .<span class="hljs-built_in">WillOnce</span>(<span class="hljs-built_in">Return</span>(<span class="hljs-number">100</span>))                    <span class="hljs-comment">// 期望的action</span><br>      .<span class="hljs-built_in">WillRepeatedly</span>(<span class="hljs-built_in">Return</span>(<span class="hljs-number">90</span>));<br>  <br>  <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-built_in">MyProductionFunction</span>(&amp;foo), <span class="hljs-string">&quot;good&quot;</span>);<span class="hljs-comment">//调用使用mock对象的函数</span><br>                                                <span class="hljs-comment">//可以检测函数结果</span><br>&#125;                           <span class="hljs-comment">// mock对象析构，gmock检测是否满足全部exception</span><br><br>........<br></code></pre></td></tr></table></figure><blockquote><p>如果没有显示指定<code>Times</code></p><ul><li><code>WillOnce</code> &#x2F; <code>WillRepeatedly</code> 都没有在 EXPECT_CALL 中被调用，time &#x3D; 1</li><li>n 个 <code>WillOnce</code>，没有 <code>WillRepeatedly</code> (n &gt;&#x3D; 1)， time &#x3D; n</li><li>n 个 <code>WillOnce</code>， 1个<code>WillRepeatedly</code> (n &gt;&#x3D; 0)，time &#x3D; AtLeast(n)</li></ul></blockquote><h2 id="MOCK-METHOD"><a href="#MOCK-METHOD" class="headerlink" title="MOCK_METHOD"></a>MOCK_METHOD</h2><p>其基本结构为如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMock</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">MOCK_METHOD</span>(ReturnType, MethodName, (Args..), (Specs..));<br>&#125;<br></code></pre></td></tr></table></figure><p>ReturnTypeo为被mock函数的返回类型，MethodName为被mock的函数名，（Args…)为被mock函数的参数，可选参数（Specs…)为mock函数修饰参数，如override,const等。</p><h2 id="EXPECT-CALL"><a href="#EXPECT-CALL" class="headerlink" title="EXPECT_CALL"></a>EXPECT_CALL</h2><p>给mock对象的命中matchers的method设定expection，需要在调用mock对象前设置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">EXPECT_CALL</span>(mock_object, <span class="hljs-built_in">method</span>(matchers...))<br>    .<span class="hljs-built_in">With</span>(multi_argument_matcher)  <span class="hljs-comment">// Can be used at most once</span><br>    .<span class="hljs-built_in">Times</span>(cardinality)            <span class="hljs-comment">// Can be used at most once</span><br>    .<span class="hljs-built_in">InSequence</span>(sequences...)      <span class="hljs-comment">// Can be used any number of times</span><br>    .<span class="hljs-built_in">After</span>(expectations...)        <span class="hljs-comment">// Can be used any number of times</span><br>    .<span class="hljs-built_in">WillOnce</span>(action)              <span class="hljs-comment">// Can be used any number of times</span><br>    .<span class="hljs-built_in">WillRepeatedly</span>(action)        <span class="hljs-comment">// Can be used at most once</span><br>    .<span class="hljs-built_in">RetiresOnSaturation</span>();        <span class="hljs-comment">// Can be used at most once</span><br></code></pre></td></tr></table></figure><ul><li><p>matchers：单值matcher，_表示接受任意参数，内置的matcher宏详见<a href="https://google.github.io/googletest/reference/matchers.html">链接</a></p></li><li><p>multi_argument_matcher： <a href="https://google.github.io/googletest/reference/matchers.html#MultiArgMatchers">多参数matcher</a>，约束method的参数的形式（Lt, 第一个参数小于第二）</p></li><li><p>Time：AnyNumber、AtLeast、Between … 限定执行次数</p></li><li><p>InSequence：指定mock函数的调用顺序。</p></li><li><p>After：指定mock函数在特定函数后调用</p></li><li><p>WillOnce: mock函数被调用时的单次<a href="https://google.github.io/googletest/reference/actions.html">行为</a></p></li><li><p>WillRepeatedly: 所有后续的调用都命中的行为</p></li></ul><blockquote><p>EXPECT_CALL(mock, Func())</p><p>.WillOnce(Return(1))               &#x2F;&#x2F; 第一次返回1               </p><p>.WillRepeatedly(Return(2))     &#x2F;&#x2F; 后续都返回2</p></blockquote><ul><li>RetriesOnSaturation: 命中足够次数后忽略</li></ul><blockquote><p>EXPECT_CALL(mock, do()).Times(AnyNumber());</p><p>EXPECT_CALL(mock, do(9)).Time(2).RetriesOnSaturation();</p></blockquote><h2 id="处理未包裹的逗号"><a href="#处理未包裹的逗号" class="headerlink" title="处理未包裹的逗号"></a>处理未包裹的逗号</h2><p>gmock的时候，如果函数原型中包含”,”信息，则会编译失败：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockM</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">MOCK_METHOD</span>(std::pair&lt;<span class="hljs-type">bool</span>, <span class="hljs-type">int</span>&gt;, GetPair, ());<br>        <span class="hljs-built_in">MOCK_METHOD</span>(<span class="hljs-type">bool</span>, CheckMap, (std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;, <span class="hljs-type">bool</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>可选如下的解决方法：</p><ol><li>( ) 包裹</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">class MockM &#123;<br>    public:<br>        MOCK_METHOD((std::pair&lt;bool, int&gt;), GetPair, ());<br>        MOCK_METHOD(bool, CheckMap, ((std::map&lt;int, double&gt;), bool));<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>定义alias</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">class MockM &#123;<br>    public:<br>        using BoolAndInt = std::pair&lt;bool, int&gt;;<br>        MOCK_METHOD(BoolAndInt, GetPair, ());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有序调用"><a href="#有序调用" class="headerlink" title="有序调用"></a>有序调用</h2><p>代码中指定某些函数，按顺序执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">using ::testing::InSequence;<br><br>TEST(FooTest, test) &#123;<br>    &#123;<br>        InSequence seq;<br>        EXPECT_CALL(turtle, PenDown());<br>        EXPECT_CALL(turtle, Forward(100));<br>        EXPECT_CALL(turtle, PenUp());<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="轻量级开源测试工具"><a href="#轻量级开源测试工具" class="headerlink" title="轻量级开源测试工具"></a>轻量级开源测试工具</h1><p>因为GoogleTest依赖比较重，因此 <a href="https://mp.weixin.qq.com/s/-6HMlVLSRdd6ycr5fSqhKw">现代C++ Unit Test库</a> 这篇文章介绍几个轻量易用的单元测试库，doctest（对应于gtest），fakeit（对应于gmock，同时还能集成到gtest中），nanobench（benchmark库），这几个开源库只需要引入头文件即可使用，非常方便。文章里也都有简单的使用介绍，或者看看github上的文档即可，这里就不再赘述了（<del>实际上是不想再写第二遍了</del>）。不过简单使用之后，个人感觉和gtest和gmock差别不是很大，如果项目不大或者此前也没怎么用过C++测试工具的话，这两个工具可以尝试一下的，当然直接去学习gtest和gmock也不亏，就是需要点成本罢了。</p><p>不过这个nanobench库还是值得学习了解的，因为此前我对性能测试相关的工具了解不多，下面列了下其官方文档上给的例子，这里做个简单的翻译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANKERL_NANOBENCH_IMPLEMENT</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;nanobench.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> d = <span class="hljs-number">1.0</span>;<br>    ankerl::nanobench::<span class="hljs-built_in">Bench</span>().<span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;some double ops&quot;</span>, [&amp;] &#123;<br>        d += <span class="hljs-number">1.0</span> / d;<br>        <span class="hljs-keyword">if</span> (d &gt; <span class="hljs-number">5.0</span>) &#123;<br>            d -= <span class="hljs-number">5.0</span>;<br>        &#125;<br>        ankerl::nanobench::<span class="hljs-built_in">doNotOptimizeAway</span>(d);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="right">ns&#x2F;op</th><th align="right">op&#x2F;s</th><th align="right">err%</th><th align="right">ins&#x2F;op</th><th align="right">cyc&#x2F;op</th><th align="right">IPC</th><th align="right">bra&#x2F;op</th><th align="right">miss%</th><th align="right">total</th><th align="left">benchmark</th></tr></thead><tbody><tr><td align="right">7.52</td><td align="right">132,948,239.79</td><td align="right">1.1%</td><td align="right">6.65</td><td align="right">24.07</td><td align="right">0.276</td><td align="right">1.00</td><td align="right">8.9%</td><td align="right">0.00</td><td align="left"><code>some double ops</code></td></tr></tbody></table><p>其结果如上表所示，大概含义是上面执行的代码花费了7.52纳秒，因此大约每秒能执行133 millon 次，测量浮动率为1.1%，每次执行需要6.65条指令，24.07个CPU周期，因此IPC （指令&#x2F;时钟）为0.276。该代码中只有1个分支，分支预测失败概率为8.9%，最后的total为执行时间，这里显示0.00 表示只花费一些毫秒。</p><blockquote><p>需要注意的是，CPU的一些数据，如指令数，CPU周期，分支数与分支预测失败率只能在Linux获取，因为是通过perf events采集得到的。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后小结一下吧，在学校的时候，其实自己都没怎么关注过测试，随手写的一些项目代码，都是只要能正确实现功能就行，没有说要写什么测试代码来保证代码质量，但是到了实际生产工作中，单元测试就被重视起来了，</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>googletest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【操作系统】内存管理</title>
    <link href="/2022/06/11/2022-06/2022-06-11%20%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2022/06/11/2022-06/2022-06-11%20%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统是每个程序员都该钻研学习的知识，最近也是在复习回顾，所以趁此机会做个简单的记录和总结，而本文将主要介绍操作系统中内存管理相关的内容。</p><p class='note note-primary'>  <font size=3>      本文的一些图片和文字将引用参考北京大学陈向群老师的《操作系统高级课程》中的PPT课件，以及MIT 6.S081 课程相关内容。  </font></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202207091626839.png" alt="内存管理思维导图"></p><h1 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h1><p>首先引入一些重要概念&#x2F;前置知识点：</p><ul><li>程序以文件形式（可执行文件格式，如Linux上的ELF文件格式，window上的PE文件格式）保存在磁盘，程序装载到内存才可以运行</li><li>现代操作系统采用多道程序设计模型：即允许多个程序同时进入内存</li><li>每个进程都有自己独立的地址空间，体现了隔离性和安全性：一个进程在执行时不能访问另一个进程的地址空间，也不能去执行不适当的操作</li><li>局部性原理：程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域<ul><li><strong>时间局部性：</strong> 如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型例子，就是在程序中存在着大量的循环操作；</li><li><strong>空间局部性：</strong> 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定范围之内，这是因为指令通常是顺序存放、顺序执行的，数据一般是以向量、数组、表等形式簇聚存储的。</li></ul></li><li>存储体系：存储器主要有3个性能指标：速度、容量、每位价格（位价），一般来说速度快的存储器容量偏小，位价较贵；容量大的，速度慢，位价便宜。计算机中的存储体系如下图所示，越上层的存储器性能（速度）越好，但位价越贵。</li></ul><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206121617060.png" alt="" style="zoom:50%;" /></center><ul><li>程序执行前的准备过程<ul><li>在程序运行前，通常要经过编译、链接、装载、运行等过程，如下图所示。那就产生一个问题，就是什么时候将指令和数据绑定到内存地址&#x2F;物理地址？也就是下面要探讨的地址重定位。</li></ul></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206121646479.png" alt="程序执行前的准备过程"></p><ul><li><p>地址重定位：将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址的过程，其作用是保证CPU执行指令时可以正确地访问内存单元</p><ul><li>逻辑地址（相对地址，虚拟地址）：用户程序经过编译、汇编后形成目标代码，目标代码通常采用相对地址的形式，<strong>其首地址为0</strong>，其余指令中的地址都<strong>相对于首地址而编址</strong>。不能使用逻辑地址在内存中读取信息。</li><li>物理地址（绝对地址，实地址）：内存中存储单元的地址，可以直接寻址。</li></ul></li><li><p>地址重定位又可以分为静态重定位和动态重定位。</p><ul><li>在静态重定位中，地址转换发生在装载时：当程序装载到内存中时，<code>store</code>指令对应的地址已经转变成了物理地址</li><li>在动态重定位中，地址转换发生在运行时：当程序装载到内存中时，<code>store</code>指令对应的地址仍然是逻辑地址，当真正运行该条指令时，会通过硬件MMU（内存管理单元）将逻辑地址转换为物理地址</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206121653343.png" alt="静态重定位"></p></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206121653671.png" alt="动态重定位"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206121701693.png" alt="动态重定位实现——MMU"></p><hr><p>这也引出了内存管理的基本目标：</p><ul><li>给进程分配内存——地址空间</li><li>往内存加载内容——映射进程地址空间到物理内存</li><li>存储保护——地址越界、权限控制</li><li>管理共享的内存</li><li>最小化存储访问时间</li></ul><h1 id="内存管理方案"><a href="#内存管理方案" class="headerlink" title="内存管理方案"></a>内存管理方案</h1><h2 id="空闲物理内存管理"><a href="#空闲物理内存管理" class="headerlink" title="空闲物理内存管理"></a>空闲物理内存管理</h2><p><strong>数据结构</strong>：</p><ul><li>位图：每个分配单元对应于位图中的一位，0表示空闲，1表示占用（或者相反）</li><li>空闲区表、已分配区表：表中的每一项记录了空闲区（或已分配区）的起始地址、长度、标志</li><li>空闲块链表</li></ul><p><strong>内存分配算法</strong>：</p><ul><li>首次适配 (first fit) ：在空闲区表中找到第一个满足进程要求的空闲区</li><li>下次适配 (next fit) ：从上次找到的空闲区处接着查找</li><li>最佳适配 (best fit)：查找整个空闲区表，找到能够满足进程要求的最小空闲区</li><li>最差适配 (worst fit)：总是分配满足进程要求的最大空闲区</li></ul><hr><p>伙伴系统——Linux底层采用的内存管理方案</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206122210181.png" alt="伙伴系统内存分配方案"></p><p>下图是伙伴系统的一个例子：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206122211213.png" alt="伙伴系统示意图"></p><p>可以看到分配时，将可用区间不断分成两块，直到划分出能满足需求的最小块（满足2的幂次）；在回收时，只有当两个大小相同且相邻的内存块被释放后，可以进行回收合并，“伙伴系统”的含义也是由此而来。</p><h2 id="内存管理基本方案汇总"><a href="#内存管理基本方案汇总" class="headerlink" title="内存管理基本方案汇总"></a>内存管理基本方案汇总</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206122216655.png" alt="内存管理基本方案汇总"></p><h3 id="单一用户（连续区）"><a href="#单一用户（连续区）" class="headerlink" title="单一用户（连续区）"></a>单一用户（连续区）</h3><p>特点：一段时间内只有一个进程在内存。</p><p>简单，但是内存利用率低。</p><h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><p>把内存空闲分割成若干区域，成为分区。（每个分区的大小可以相同也可以不同）</p><p>分区的大小固定不变。</p><p>每个分区装一个且只能装一个进程。</p><p>存在的问题：有内部碎片，对内存的使用不充分，活动进程的最大数目是固定的。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206122222063.png" alt="固定分区示意图"></p><h3 id="可变分区"><a href="#可变分区" class="headerlink" title="可变分区"></a>可变分区</h3><p>根据进程的需要，把内存空闲空间分割出一个分区，分配给该进程。</p><p>剩余部分成为新的空闲区。</p><p>实现的数据结构：空闲区表，已分配表。</p><p>存在的问题：存在外碎片，导致内存利用率下降。</p><p>解决方案：可以采用紧凑技术。在内存中移动程序，将所有小的空闲区合并为较大的空闲区，但需要考虑系统开销和移动时机。</p><h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><p>设计思想：</p><ul><li>用户程序地址空间划分成大小相等的区域——页 page</li><li>物理内存空间按页大小划分大小相等的区域，成为内存块（物理页面，页框，页帧）page frame</li><li>内存分配规则：以页为单位机械能分配，并按进程需要的页数来分配；逻辑上相邻的页，物理上不一定相邻</li><li>典型的页面尺寸：4K 或 4M</li><li>逻辑地址：对于32位机器，页面大小为4K，其逻辑地址可分成页号（前20位）和页内偏移（后12位）。</li></ul><p>相关数据结构以及地址转换：</p><ul><li>页表<ul><li>页表项：记录了逻辑页号与页框号的对应关系</li><li>每个进程一个页表，存放在内存中</li><li>进程未执行时，页表的始址和页表长度放在<strong>进程控制块</strong>（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</li></ul></li><li>空闲内存管理</li><li>地址转换（硬件支持）：CPU取到逻辑地址，自动划分为页号和页内地址；用页号查页表，得到页框号，再与页内地址（页内偏移）拼接得到物理地址</li></ul><p>优缺点：</p><ul><li>优点<ul><li>虚存量大，适合多道程序运行，用户不必担心内存不够的调度操作。</li><li>内存利用率高，不常用的页面尽量不留在内存。</li><li>不要求作业连续存放，有效地解决了外碎片问题（但可能还是会有内碎片产生）。</li></ul></li><li>缺点<ul><li>地址变换机构复杂，为提供速度采用硬件实现，增加了机器成本</li><li>需要相应的硬件支持，来处理页面中断、缺页中断处理等，增加系统开销。</li></ul></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206122246280.png" alt="页式管理示意图"></p><h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><p>设计思想：</p><ul><li>用户程序地址空间：按程序自身的逻辑划分为若干个程序段，每个程序段都有一个段名</li><li>内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定</li><li>内存分配规则：以段为单位进行分配，每一个段在内存中占据连续空间，但各段之间可以不相邻</li><li>逻辑地址：分为段号和段内地址</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206122245047.png" alt="段式管理示意图"></p><p>相关数据结构及地址转换：</p><ul><li>段表<ul><li>记录了段号、段首地址和段长度之间的关系</li><li>每个进程一个段表，存放在内存</li></ul></li><li>物理内存管理：同可变分区</li><li>地址转换（硬件支持）<ul><li>CPU取到逻辑地址，用段号查段表，得到段的起始地址，再与段内偏移地址相加计算出物理地址</li></ul></li></ul><p>优缺点<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[【内存管理】页式&段式&段页式&优缺点](https://blog.csdn.net/weixin_44225940/article/details/105266677)">[1]</span></a></sup>：</p><ul><li>优点<ul><li>段式管理是不连续分配内存技术中的一种。其最大特点在于他按照用户观点，即按程序段、数据段等有明确逻辑含义的“段”，分配内存空间。克服了页式的、硬性的、非逻辑划分给保护和共享与支态伸缩带来的不自然性<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[段式存储管理](https://wenku.baidu.com/view/abc85e4fdeccda38376baf1ffc4ffe473268fd4a.html)">[2]</span></a></sup>。</li><li>可以分别编写和编译，可以针对不同类型的段采取不同的保护，可以按段为单位进行共享，包括通过动态链接进行代码共享。</li></ul></li><li>缺点：会产生外部碎片</li></ul><hr><p>这里再解释一个问题，为什么说页式存储的地址空间是一维的，而段式存储的地址空间是二维的？<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[为什么分页存储的地址空间是一维的，而分段存储的地址是二维的](https://blog.csdn.net/xiaotai1234/article/details/107427547)">[3]</span></a></sup></p><p>段号和页号的来历是不同的，段号是程序员自己定义的，每个段都是有特定含义的，因此不同段的大小不同，代表的意义也不相同，因此要想找到某个数据或指令，需要指定段号和位移两个变量。而页号是系统自动生成的，本身地址是线性连续的，当要访问特定地址时，只需要提供地址即可。系统会自动将地址划分为页号和页内偏移，而页号对于程序员来说是没有实际意义的，因此是一维的。</p><h3 id="段页式存储管理方案"><a href="#段页式存储管理方案" class="headerlink" title="段页式存储管理方案"></a>段页式存储管理方案</h3><p>产生背景</p><ul><li>结合页式段式优点，克服二者的缺点</li></ul><p>设计思想</p><ul><li>用户程序划分：按段式划分（对用户来讲，按段的逻辑关系进行划分；对系统来讲，按页划分每一段）</li><li>内存划分：按页式存储管理方案</li><li>内存分配：以页为单位进行分配</li></ul><p>数据结构及有关操作</p><ul><li>段表：记录了每一段的页表起始地址和页表长度</li><li>页表：记录了逻辑页号与内存块号的对应关系（每一段有一个，一个程序可能有多个页表）</li><li>空闲区管理以及分配回收：同页式管理</li></ul><p>地址转换</p><ul><li>通过段号查段表，获得该段的页表起始地址，再通过段内地址对应的页号查页表，获得对应的页帧号，拼接上页内地址，最终得到物理地址</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206132259088.png" alt="地址转换"></p><h1 id="内存扩充技术"><a href="#内存扩充技术" class="headerlink" title="内存扩充技术"></a>内存扩充技术</h1><p>当内存不足时如何管理？</p><ul><li>内存紧凑（例如：可变分区）</li><li>覆盖技术</li><li>交换技术</li><li>虚存技术</li></ul><p>上面技术的目标都是为了解决在较小的存储空间中运行较大程序时遇到的矛盾，本小节将重点介绍覆盖技术和交换技术，虚存技术会在下一节着重介绍。</p><h2 id="覆盖技术（Overlaying）"><a href="#覆盖技术（Overlaying）" class="headerlink" title="覆盖技术（Overlaying）"></a>覆盖技术（Overlaying）</h2><p>解决的问题：程序大小超过物理内存总和</p><p>定义描述：在程序执行过程中，程序的不同部分在内存中相互替代</p><ul><li>按照其自身的逻辑结构将那些不会同时执行的程序段共享同一块内存区域</li><li>要求程序个模块之间有明确的调用结构</li><li>程序员声明覆盖结构，操作系统完成自动覆盖</li><li>主要用在早期的操作系统</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206141624136.png" alt="覆盖技术示例"></p><p>如上图所示，程序段B和C能共用同一块内存区，D、E、F能共用同一块内存区（之所以能共用，是因为程序的逻辑保证这些程序段不会同时运行）。</p><p>覆盖技术的不足：</p><ul><li>增加编程困难<ul><li>需要程序员划分功能模块，并确定模块间的覆盖关系</li><li>增加了编程的复杂度</li></ul></li><li>增加执行时间<ul><li>从外存装入覆盖模块</li><li>时间换空间</li></ul></li></ul><h2 id="交换技术（Swapping）"><a href="#交换技术（Swapping）" class="headerlink" title="交换技术（Swapping）"></a>交换技术（Swapping）</h2><p>设计思想</p><ul><li>内存空间紧张时，系统间该内存中某些进程暂时移到外存，把外存中某些进程换进内存，占据前者所占用的区域（进程在内存与外存之间的动态调度）</li><li>最早用于小型分时系统（roll in roll out）</li></ul><p>讨论：实现时需要考虑的问题</p><ul><li>进程的什么部分需要交换到磁盘？<ul><li>运行时创建或修改的内容，也就是<strong>栈和堆</strong>。而代码段和数据段在磁盘本身就有来源，所以无需交换</li></ul></li><li>在磁盘的什么位置保存被换出的进程？<ul><li>交换区：一般系统会指定一块特殊的磁盘区域作为交换空间（swap space），包含连续的磁道，操作系统可以使用底层的磁盘读写操作对其高效访问</li></ul></li><li>何时需要发生交换？<ul><li>只要不用就换出（很少再用）；内存空间不够或有不够的危险时换出</li><li>与调度器结合使用</li></ul></li><li>如何选择被换出的进程？<ul><li>需要考虑进程的各种属性；不应该换出正处于等待I&#x2F;O状态的进程</li></ul></li><li>换出后再换入的进程是否回到原处？<ul><li>换出后又换入的进程不一定回到原处（采用动态重定位）</li></ul></li></ul><h1 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h1><h2 id="相关术语辨识"><a href="#相关术语辨识" class="headerlink" title="相关术语辨识"></a>相关术语辨识</h2><ul><li><p><strong>虚拟内存</strong></p><ul><li><p>把物理内存与磁盘结合起来使用，得到一个容量很大的“内存”，即虚存</p></li><li><p>程序引用内存所使用的的地址与内存物理地址是不同的， 可被自动转换成物理地址</p></li><li><p>虚存大小受计算机系统寻址机制和可用磁盘容量的限制</p></li></ul></li><li><p><strong>虚拟地址空间</strong></p><ul><li>分配给进程的虚拟内存</li></ul></li><li><p><strong>虚拟地址</strong></p><ul><li>虚拟内存中某一位置的地址，该位置可以被访问，仿佛它是内存的一部分</li></ul></li><li><p><strong>虚拟存储技术</strong></p><ul><li>当进程运行时，先将其一部分装入内存，另一部分暂时保存在磁盘；当要执行的指令或访问的数据不再内存时，由操作系统自动完成将它们从磁盘调入内存的工作</li></ul></li></ul><h2 id="虚拟页式存储管理"><a href="#虚拟页式存储管理" class="headerlink" title="虚拟页式存储管理"></a>虚拟页式存储管理</h2><p>基本思想</p><ul><li>装载程序时，不是装入全部页面，而是装入几个甚至零个页面</li><li>如果进程执行时需要的页面不在内存（Page Fault），则动态装入所需页面</li><li>需要时，将内存中暂时不用的一些页面交换到磁盘，以便获得更多的内存空间</li></ul><p>通常由两种方式</p><ul><li>请求调页（demand paging）：当需要的页面不在内存时，引发缺页错误，去装入所需页面</li><li>预先调页（prepaging）：利用局部性原理，将预计在不久之后便会被访问的页面预先调入内存。</li></ul><p>调页机制</p><ul><li>进程的虚拟地址空间与为例地址空间分离</li><li>调页系统的3个重要策略<ol><li>系统何时把页面载入内存——取页策略（fetch policy）</li><li>系统把页面放在何处——防止策略（placement policy）</li><li>执行放置操作时发生页框不足时，如何选择从内存里“删除”其他页框——置换策略（replacement policy）</li></ol></li></ul><hr><p>设计与实现时要解决的问题：</p><ul><li>页表表项的设计</li><li>如何处理页表巨大的问题？</li><li>地址重定位与块表（TLB)</li><li>一种最常见的Page Fault —— 缺页中断</li><li>驻留集管理</li><li>置换策略</li><li>清除策略</li><li>加载控制</li></ul><p>接下来将详细介绍以上各个问题。</p><h3 id="页表表项的设计"><a href="#页表表项的设计" class="headerlink" title="页表表项的设计"></a>页表表项的设计</h3><p>页表表项通常包含页框号、有效位、访问位、修改位、保护位等。</p><ul><li>页框号（内存块号、物理页面号、页帧号）</li><li>有效位（驻留位、中断位）：表示该页是在内存还是在磁盘（Valid、Present）</li><li>访问位：引用位（Referenced、Accessed）</li><li>修改位：查看此页是否在内存中被修改过（Dirty、Modified）</li><li>保护位：读&#x2F;写&#x2F;执行（Protection）</li></ul><p>下面两张图给出了i386(intel 32位机器)以及RISC-V的页表项设计。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142004594.png" alt="i386页目录项和页表项"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142028348.png" alt="RISC-V页表项"></p><p>对于RISC-V页表项布局的解释：</p><ul><li>V位决定了该页表项是否有效（V&#x3D;1时有效）</li><li>R、W、X位分别表示此页是否可以读取、写入和执行。如果这个三个位都是0，那么这个页表项是指向下一级页表的指针，否则它是页表树的一个叶节点（多级页表）</li><li>U位表示该页是否是用户页面（U&#x3D;0，则用户模式不能访问此页面）</li><li>G位表示这个映射是否对所有虚拟地址空闲有效，硬件可以用这个信息来提高地址转化的性能。</li><li>A位表示自上次A位被清除以来，该页面是否被访问过。</li><li>D位表示自从上次清除D位依赖，该页面是否被弄脏（例如被写入）</li><li>RSW 留给操作系统使用，它会被硬件忽略。</li><li>PPN 表示物理页号，这是物理地址的一部分。若这是一个页目录项，则PPN给出下一个页表的地址；若这是一个页表项，则PPN是转换后物理地址的一部分。</li></ul><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>多级页表的引入，是为了解决页表连续存放，导致占用过多的问题，因为虽然一个进程的虚拟地址空间很大，但是实际占用的空间很小，所以页表会很稀疏（即大部分页表项都是无效的）。如果采用一级页表，则一个进程有 2^19 页（计算过程如图所示，2G &#x2F; 4K），即需要有2^19个页表项，那么光是页表项的存储就需要512页（即2MB），而进程本身实际大小或许都没这么大。</p><p>所以引入多级页表，通过索引的思想，让一个进程的页表的各页不用再内存中连续存放，也不用给所有页表项都分配内存，只需要为实际使用到的虚拟地址建立页表项映射即可。</p><ul><li>因为如果一级页表中的一个 PTE 为空，那么相应的二级页表就根本不会存在。这是一种巨大的内存节约。</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142040370.png" alt="多级页表的引入"></p><p>下图给出了二级页表的结构，以及地址映射的过程。这里虚拟地址是32位的，每个页表项占4个字节（页大小为4K，因此每页都有1K个页表项）。进行地址映射时，前10位作为页目录偏移，查找页目录（一级页表，由全局页目录寄存器记录其物理地址）上的页表项，得到下一级页表的物理地址，再根据后10位作为页表偏移，查找二级页表上的页表项，得到对应数据&#x2F;代码所在的页号，再拼接末尾12位的页内偏移，得到最终的物理地址。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142052121.png" alt="二级页表结构以及地址映射"></p><h3 id="快表（TLB）"><a href="#快表（TLB）" class="headerlink" title="快表（TLB）"></a>快表（TLB）</h3><p>在引入二级页表或者多级页表后，就需要两次或两次以上的内存访问。而CPU的指令处理速度与内存指令的访问速度差异大，因此CPU的速度得不到充分利用。</p><p>为了加快地址映射速度，以改善系统性能，就引入了快表（也体现了程序访问的局部性原理）。</p><p>快表英文名TLB——Translation Look-aside Buffers，实际上一个相联存储器，其特点是按内容进行并行查找。快表保存正在运行进程的页表的子集（部分表项）。</p><p>其工作原理就是采用联想映射技术按内容同时查找，当要转换的虚拟地址在TLB中有记录&#x2F;命中时，则TLB可以直接返回对应的物理地址，而不再需要根据页表进行转换。而没有命中时，则再去查找页表。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142126713.png" alt="TLB的使用"></p><p>当TLB命中返回对应数据&#x2F;代码的物理地址时，还需要再去访问内存，为了进一步减少内存访问，又有了高速缓存Cache，缓存了部分内存中的数据，当命中缓存时，可以直接得到数据而无需访问内存。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142128181.png" alt="TLB与高速缓存"></p><h3 id="缺页异常处理"><a href="#缺页异常处理" class="headerlink" title="缺页异常处理"></a>缺页异常处理</h3><p>在地址映射过程中，硬件检查页表时发现所要访问的页不再内存，则产生该异常——缺页异常。</p><p>操作系统执行缺页异常处理程序：获得磁盘地址（在PCB中记录），启动磁盘IO，将该页调入内存</p><ul><li>如果内存中有空闲页框，则分配一页，将新调入的页装入内存，并修改页表中相应页表项的驻留位&#x2F;有效位，以及相应的页框号</li><li>若内存中没有空闲页框，则需要置换某一页；若该页在内存期间被修改过，则要将其写会磁盘</li></ul><h3 id="驻留集管理"><a href="#驻留集管理" class="headerlink" title="驻留集管理"></a>驻留集管理</h3><p>驻留集大小：即给每个进程分配多少页框。显然，当驻留集越大时，出现缺页异常的概率越小。</p><p>可以采取不同的分配策略：</p><ul><li>固定分配策略<ul><li>进程创建时就确定驻留集大小。可以根据进程类型（交互、批处理、应用类）或者基于程序员或管理员的需要来确定。</li></ul></li><li>可变分配策略<ul><li>根据缺页率评估局部性表现。当缺页率高时增加页框数，当缺页率低时减少页框数。</li></ul></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="置换策略"><a href="#置换策略" class="headerlink" title="置换策略"></a>置换策略</h4><p>根据置换范围（计划置换页面的集合是局限在产生缺页中断的进程，还是所有进程的页框），又可分为：</p><ul><li>局部置换策略：仅在产生本次缺页的进程的驻留集中选择</li><li>全局置换策略：将内存中所有位锁定的页框都作为置换的候选</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142148829.png" alt="局部置换与全局置换"></p><p>置换策略：决定置换当前内存中的哪一个页框。</p><p>所有策略的目标都是为了置换最近最不可能访问的页。</p><ul><li>根据局部性原理，最近的访问历史和最近将要访问的模式间存在相关性，因此大多数策略都<strong>基于过去的行为来预测将来的行为</strong>。</li><li>同时要注意，置换策略设计得约精致、越复杂，实现的软硬件开销就越大。</li><li>置换时的约束条件：不能置换被锁定的页框。<ul><li>给每个页框增加一个锁定位，通过设置锁定位，不让操作系统将进程使用的页面换出内存，避免产生由交换过程带来的不确定的延迟。</li><li>例如操作系统核心代码、关键数据结构、I&#x2F;O缓冲区（正在IO的内存页面）</li></ul></li></ul><h4 id="各种置换算法"><a href="#各种置换算法" class="headerlink" title="各种置换算法"></a>各种置换算法</h4><p>理想（最佳、最优）置换算法（OPT）</p><ul><li>设计思想：置换以后不再需要的或最远的将来才会用到的页面</li><li>实现很难，因为无法预测未来的使用情况</li></ul><hr><p>先进先出页面置换算法（FIFO）</p><ul><li>设计思想：选择内存中驻留时间最长的页并置换</li><li>实现：页面链表法</li><li>FIFO算法会出现Belady现象，即当分配给进程的物理页面数增加时，缺页次数反而增加</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142239620.png" alt="Belady现象"></p><hr><p>第二次机会置换算法（SCR，Second Chance)</p><ul><li><p>设计思想：按照先进先出算法选择某一页面，检查其访问位R，如果为0（表明近期未访问），则置换该页；如果为1，则给第二次机会，并将访问位置0</p></li><li><p>时钟算法（Clock），是SCR的一种实现</p></li></ul><hr><p>最近未使用算法（NRU，Not Recently Used）</p><ul><li>设计思想：选择在最近一段时间内未使用的一页并置换</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142208452.png" alt="最近未使用算法NRU实现"></p><hr><p>最近最久未使用算法（LRU，Least Recently Used）</p><ul><li>选择最后一次访问时间距离当前时间最长的一页并置换，即置换未使用时间最长的一页</li><li>性能上接近OPT</li><li>实现：使用时间戳或维护一个访问页的栈，但是开销大</li></ul><hr><p>最不经常使用算法（NFU，Not Frequently Used）</p><ul><li>设计思想：选择访问次数最少的页面置换</li><li>实现：<ul><li>软件计数器，一页一个，初值为0</li><li>每次时钟中断时，计数器加R</li><li>发生缺页中断时，选择计数器最小的一页置换</li></ul></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142234739.png" alt="老化算法——NFU的优化实现"></p><p>NFU老化算法是软件模拟，NFU老化算法的计数器只有有限位数n，因此置换信息仅限于n个时钟滴答内</p><hr><p><strong>工作集模型</strong><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[内存管理](https://www.icode9.com/content-3-1164794.html)">[4]</span></a></sup></p><ul><li>基本思想：根据程序的局部性原理，一般情况下，进程在一段时间内总是集中访问一些页面，这些页面称为<strong>活跃页面</strong>，如果分配给一个进程的页框太少了，使得该进程所需的活跃页面不能全部装入内存，则进程在运行过程中将频繁发生中断</li><li>如果能为进程提供与活跃页面数相等的页框数，则可减少缺页中断次数</li><li>活页页面的集合就是工作集。工作集随着时间可能会发生变化，但在一定时间内是比较稳定的</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142246321.png" alt="工作集与驻留集"></p><p><strong>工作集算法</strong></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142248373.png" alt="工作集算法基本思路"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142248943.png" alt="工作集算法图示"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142248383.png" alt="工作集算法实现"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142249041.png" alt="多种页面置换算法小结"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142251883.png" alt="影响缺页次数的因素"></p><h3 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h3><p>这里的清除策略主要是指，定期地回收页面，以保证系统始终有一定数量的空闲页框。具体内容描述可参考下图。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206142300700.png" alt="清除策略"></p><h3 id="加载控制"><a href="#加载控制" class="headerlink" title="加载控制"></a>加载控制</h3><p>系统并发度：驻留在内存中的进程数目。</p><p>通过调节并发进程数对系统负载进行控制。</p><p><strong>当系统并发度过高时，会导致进程切换频繁，而CPU利用率下降。</strong></p><p>解决方案：进程挂起，即释放一部分进程所占有的页面，把它们交换到磁盘上</p><h1 id="地址转换练习"><a href="#地址转换练习" class="headerlink" title="地址转换练习"></a>地址转换练习</h1><p>最后为了巩固地址转换的过程，来做道练习题吧。如下图所示，求给出的虚拟地址对应的PDE和PTE的物理地址，假设采用的是二级页表，左边表格是TLB的数据，右边表格是某个物理地址上对应数据。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206152243902.jpg" alt="地址转换练习题"></p><p>再此之前，再介绍一下TLB快表的查询方式。如下图所示，给定了一个14位的虚拟地址，前8位为VPN（虚拟地址页号），后6位为地址偏移。VPN又被划分为 TLBT（TLB Tag）和 TLBI（TLB Index），因为这里表格显示的是4行，即TLB是四路相连，所以Index需要两位。在查TLB的时候，现根据TLBI 去查对应的行数，再根据TLBT 值比对 该行中的Tag中。如果存在对应的Tag值，并且Valid有效，则表明命中TLB，可以直接返回对应的PPN（物理页框号）</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206152259858.jpg" alt="TLB快表查询"></p><hr><p>下图演示了虚拟地址0x9fd28c10的地址映射过程，另外两个地址的映射过程也是类似的。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206160938113.png" alt="地址映射过程"></p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/weixin_44225940/article/details/105266677">【内存管理】页式&amp;段式&amp;段页式&amp;优缺点</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://wenku.baidu.com/view/abc85e4fdeccda38376baf1ffc4ffe473268fd4a.html">段式存储管理</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/xiaotai1234/article/details/107427547">为什么分页存储的地址空间是一维的，而分段存储的地址是二维的</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.icode9.com/content-3-1164794.html">内存管理</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS算法与一次踩坑记录</title>
    <link href="/2022/06/03/2022-06/2022-06-03%20BFS%E7%AE%97%E6%B3%95%E4%B8%8E%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/06/03/2022-06/2022-06-03%20BFS%E7%AE%97%E6%B3%95%E4%B8%8E%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在练习BFS算法，在leecode上刷到这样一道题 <a href="https://leetcode.cn/problems/open-the-lock/">752. 打开转盘锁 - 力扣（LeetCode）</a>，其实题目本身的解法思路还是很清晰的，但是没有注重好细节，导致踩了个坑，在debug排查时更是遇到了出乎意料的错误，所以写下这篇文章吸取教训。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目大意就是给定固定长度为4的字符串”0000”，每次只能改变其中一个字符，并且一次只能加1或者减1（比如 ‘0’ -&gt;’9’ 或 ‘9’-&gt;’0’），并且给出一个字符串数组 <code>deadends</code>，改变之后的字符串不能再</p><p><code>deadends</code>数组中，问最少需要多少次改变能变成目标字符串<code>target</code>。</p><p>解题思路的话就是BFS搜索，把每个字符串看做一个节点&#x2F;状态，每次改变之后变成一个新的节点&#x2F;状态，而从一个状态转变为另一个状态，有 4 * 2 个选择（4位置，2种变法），然后判断该状态是否为最终目标状态，使用BFS搜索就可以求得最少次数的转变。下面给出具体实现代码。</p><h2 id="普通BFS搜索版本1"><a href="#普通BFS搜索版本1" class="headerlink" title="普通BFS搜索版本1"></a>普通BFS搜索版本1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;<br>    unordered_set&lt;string&gt; s;<br>    <span class="hljs-keyword">for</span> (string&amp; str : deadends) &#123;<br>        s.<span class="hljs-built_in">insert</span>(str);<br>    &#125;<br>    string start = <span class="hljs-string">&quot;0000&quot;</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(start) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    queue&lt;string&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    s.<span class="hljs-built_in">insert</span>(start);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            start = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (start == target) &#123;<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++) &#123;<br>                string next = start;<br>                next[j] = (start[j] - <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(next) == <span class="hljs-number">0</span>) &#123;<br>                    s.<span class="hljs-built_in">insert</span>(next);<br>                    q.<span class="hljs-built_in">push</span>(next);<br>                &#125;<br>                next[j] = (start[j] - <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">9</span>) % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(next) == <span class="hljs-number">0</span>) &#123;<br>                    s.<span class="hljs-built_in">insert</span>(next);<br>                    q.<span class="hljs-built_in">push</span>(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        ans++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="普通BFS搜索版本2"><a href="#普通BFS搜索版本2" class="headerlink" title="普通BFS搜索版本2"></a>普通BFS搜索版本2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;<br>    unordered_set&lt;string&gt; s;<br>    <span class="hljs-keyword">for</span> (string&amp; str : deadends) &#123;<br>        s.<span class="hljs-built_in">insert</span>(str);<br>    &#125;<br>    string start = <span class="hljs-string">&quot;0000&quot;</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(start) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    queue&lt;string&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            start = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (start == target) &#123;<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(start) &gt; <span class="hljs-number">0</span> ) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            s.<span class="hljs-built_in">insert</span>(start);<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++) &#123;<br>                string next = start;<br>                next[j] = (start[j] - <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(next) == <span class="hljs-number">0</span>) &#123;<br>                    q.<span class="hljs-built_in">push</span>(next);<br>                &#125;<br>                next[j] = (start[j] - <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">9</span>) % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(next) == <span class="hljs-number">0</span>) &#123;<br>                    q.<span class="hljs-built_in">push</span>(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        ans++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BFS搜索实现比较"><a href="#BFS搜索实现比较" class="headerlink" title="BFS搜索实现比较"></a>BFS搜索实现比较</h2><center class="third">    <img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGY4N2UwYWZkNGZiNjU5ODFjYzE2YjRhMTI1ZmU4NWRfZkExdjlBWm5ISE9ST25EZHd1UEc0enI1c0hwZkRSbjdfVG9rZW46Ym94Y25YVDFLcjVCNFVRVmoxbElZZDc0am1oXzE2NTQyNjEwMTc6MTY1NDI2NDYxN19WNA" width=300>    <img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=N2U2YWZiNmQ2OTFhNjhhYTg0MmNmNjlmN2VkNjljYThfcXF1VkhyOW5NTDNyd1ZRVTNDV3E5aUh4VDRURE1BRGtfVG9rZW46Ym94Y25YOVMyQXZrZ1Q3YmFCcDJycVNkQWRnXzE2NTQyNjEwMTc6MTY1NDI2NDYxN19WNA" width=300></center><p>下面来分析下上述两个版本实现的区别。左图是版本1的写法，右图是版本2的写法，可以观察到两者的区别在于 s 集合（也就是已访问节点的集合）插入的位置或者说时机不同。（对于版本1来说，还需要在进入队列循环前把起始节点加入到访问集合中）</p><p>左图的做法是放入队列的同时就插入集合，认为该节点已访问，所以在外层循环真正取出的时候不用再进行判断和插入；而右图的做法是当节点从队列中取出的时候，才认为该节点被访问再进行插入，那么此时插入集合前判断该节点此前以是否已经访问的 if 语句就是必须的。因为把节点加入队列的时候没有进行判断去重，那么在同一层level 上，是会存在两个节点的状态相同的情况，比如(0000-&gt;1000-&gt;2000-&gt;3000-&gt;4000-&gt;5000 ， 与 0000-&gt;9000-&gt;8000-&gt;7000-&gt;6000-&gt;5000 这两条路径的长度都是5，所以最终节点会在同一层上，也都会被加入到队列中。<strong>如果从队列中取出的时候不进行判断是否已经访问，那么就会去重复搜索这两个相同节点的路径，导致耗时指数增加，而这部分搜索本该是需要被剪枝的。</strong></p><p>而我当时就是没有想清楚这里的逻辑，一头栽进这个坑里，也才有了这篇文章（doge）。</p><h2 id="双向BFS优化"><a href="#双向BFS优化" class="headerlink" title="双向BFS优化"></a>双向BFS优化</h2><p>这里再提一下BFS还有一个高级的优化方法：双向BFS。参考 <a href="https://labuladong.gitee.io/algo/1/7/">BFS 算法解题套路框架 :: labuladong的算法小抄</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[BFS 算法解题套路框架 :: labuladong的算法小抄](https://labuladong.gitee.io/algo/1/7/)">[1]</span></a></sup>。</p><p>传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。</p><p>从时间复杂度分析的话，虽然双向BFS会有一定的优化，但和普通BFS一样，其最坏复杂度都是 <code>O(N)</code>。并且双向 BFS 也有局限，那就是你必须要知道最终的节点位置或者说最终的状态是怎样的。</p><p>下面给出了使用双向BFS的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 双向BFS</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;<br>    unordered_set&lt;string&gt; visited;<br>    <span class="hljs-keyword">for</span> (string&amp; str : deadends) &#123;<br>        visited.<span class="hljs-built_in">insert</span>(str);<br>    &#125;<br>    unordered_set&lt;string&gt; start;<br>    unordered_set&lt;string&gt; end;<br>    start.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;0000&quot;</span>);<br>    end.<span class="hljs-built_in">insert</span>(target);<br>    <span class="hljs-keyword">if</span> (visited.<span class="hljs-built_in">count</span>(<span class="hljs-string">&quot;0000&quot;</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (!start.<span class="hljs-built_in">empty</span>() &amp;&amp; !end.<span class="hljs-built_in">empty</span>()) &#123;<br>        unordered_set&lt;string&gt; next_level;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> string&amp; str : start) &#123;<br>            <span class="hljs-keyword">if</span> (end.<span class="hljs-built_in">count</span>(str) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (visited.<span class="hljs-built_in">count</span>(str) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            visited.<span class="hljs-built_in">insert</span>(str);<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++) &#123;<br>                string next = str;<br>                next[j] = (str[j] - <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (visited.<span class="hljs-built_in">count</span>(next) == <span class="hljs-number">0</span>) &#123;<br>                    next_level.<span class="hljs-built_in">insert</span>(next);<br>                &#125;<br>                next[j] = (str[j] - <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">9</span>) % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (visited.<span class="hljs-built_in">count</span>(next) == <span class="hljs-number">0</span>) &#123;<br>                    next_level.<span class="hljs-built_in">insert</span>(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        ans++;<br>        start = end;<br>        end = next_level;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><p>接下来再具体谈谈我踩的坑吧，上文提到了两个普通BFS搜索实现的区别，而我当时采用的就是版本2的写法，并且没有写判断是否已访问的逻辑，因此造成结果不符合预期。所以我使用CLion进行debug排查，但是在debug过程，遇到了下面这个离奇的现象。</p><p><img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=YzE1MWRmMjQ5NTZhOTJkZWU2ZGVlYThlZjc4ZWE4YzBfV1JBZ2ZMTm1wMUpwUkp4cGo2OGhBT1ZNeWgzdWhBQ1RfVG9rZW46Ym94Y25MN2hnM0Y2ZWpXQUh3OVppc1p4WEZnXzE2NTQyNjEwMTc6MTY1NDI2NDYxN19WNA"></p><p><img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=YWFjMzJmMjBkMzc5YTc0NGM4NWJlZDkyYWRkMTBiZTZfbld0bEdSbGhZTWtBZFJkZUJ6dVRUV0c5NkxWanJ3WFVfVG9rZW46Ym94Y25FclhJS21jZXFQUG1uTEF0QnZvUnllXzE2NTQyNjEwMTc6MTY1NDI2NDYxN19WNA"></p><p>可以看到，在debug模式下，明明队列<code>q</code>里已经没有元素了，显示的<code>q.size</code>也为0， 但是赋值得到的 <code>size</code> 却不为0。当时真的是百思不得其解，整个人有点小懵，然后加各种打点去看，但发现明明队列里就是有值，可显示的却是0。因为我当时还是认为程序逻辑没有错，认为这里队列就应该是空，所以一直认为是不是其他哪里有问题。</p><p>直到后来无计可施了，我才开始重新梳理逻辑，确定逻辑上这里的队列是否有值，然后就发现是代码逻辑本身有问题。这样一来，问题就明朗许多了，开始考虑是不是编译器或者调试工具的问题。</p><p>后来发现的确是编译器显示的问题，在CLion里，当队列里的元素个数超过255时，只会显示255或者为0，在vscode里进行测试时也同样有这个问题。不过vscode好像是会一直保持size&#x3D;255。</p><p><img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=M2NhZTIxZDJhZjY4MTNjNDFmZTE4NDQ3ZGUyYTA2ZDRfS0JoUHZ6M3lqY1poaUVzNnMzOWhsaFVPQzg1Qm9lRGNfVG9rZW46Ym94Y25BMVV2S3NUREM1eFJKNml5M3FmUUNmXzE2NTQyNjEwMTc6MTY1NDI2NDYxN19WNA" alt="CLion调试1"></p><p><img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2UzZTU3NDdmNTIxYTg2OWRmZjhkYjMyYzgzYTI3YzhfUXJWU2xRSENPU0tzQXRuakRJWTVqWFlUNFdhZEp5cVlfVG9rZW46Ym94Y25jbWJOeHY5NDNsSVRNRFI3N3hHdFlmXzE2NTQyNjEwMTc6MTY1NDI2NDYxN19WNA" alt="CLion调试2"></p><p><img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=YjA3ZGMzYjE4YzcwY2Y1MTI0YzJiZTJiMDFmZDA3NmJfRXNGQ0J5d0JmNmt3cGRBWXhQUjMyUlVqRjR1a0o1TVNfVG9rZW46Ym94Y25xaVJuQlRsRnpVWmdLVktZV21JalNjXzE2NTQyNjEwMTc6MTY1NDI2NDYxN19WNA" alt="CLion调试3"></p><p><img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=OTIyMjgyMWFlZGYzOWVmNmE1MDhmYmFjYmY5MGUxMzlfSVZjV2lHOG1wcVNCUHlXM2xFVHBwemFuY3BYUkRDcVVfVG9rZW46Ym94Y245N0prQktxRVQ4QURRUDh4ajRaZDRmXzE2NTQyNjEwMTc6MTY1NDI2NDYxN19WNA" alt="VsCode调试1"></p><p><img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjY5YjMxODQ1MzAwOTQ1M2M4MzljNDFlMmNmOTU5NTVfQVRKZXNJcEVueTRrYWkyRzd6M3hOaTFZYjhpV0xaaUZfVG9rZW46Ym94Y25NSUJhbjVBRTdybHVGUTBKV2R1NEdlXzE2NTQyNjEwMTc6MTY1NDI2NDYxN19WNA" alt="VsCode调试2"></p><p>之后又在CLion上测试了vector，list，set，deque，stack，map，发现只有deque、queue、stack会出现显示的size和真实size不一致的情况，不难猜想根源在于deque，因为queue和stack底层默认采用deque实现。那么为什么会出现这样的情况呢？程序逻辑是正常的，那么只可能是IDE显示或者调试工具的问题了，或许是因为deque底层数据结构比较复杂，当元素数量大起来之后，调试工具难以追踪导致显示不一致吧。</p><p>在stackoverflow上也找到一个类似的问题，跟猜想大体一致：<a href="https://stackoverflow.com/questions/53972627/deque-not-growing-larger-than-255-elements">https://stackoverflow.com/questions/53972627/deque-not-growing-larger-than-255-elements</a> <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://stackoverflow.com/questions/53972627/deque-not-growing-larger-than-255-elements">[2]</span></a></sup></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，这次踩坑的教训就是，一定要先仔细、慎重地思考好代码逻辑，认为实在看不出问题来了再去debug调试（好像说了句废话。。。），大意就是不要太依靠调试工具，或者说先把一些基本逻辑理清，确定一些前提条件后再去排查问题，会更有效率，就比如这次如果我能理清逻辑的话，能确定队列大小的size不为0，那就能更快地进行排查测试，而不是在哪里纠结，往错误的方向上思考了。</p><p>正所谓方向错了，所做的努力都是徒劳。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206032117306.jpeg" alt="草上飞2"></p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://labuladong.gitee.io/algo/1/7/">BFS 算法解题套路框架 :: labuladong的算法小抄</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://stackoverflow.com/questions/53972627/deque-not-growing-larger-than-255-elements">https://stackoverflow.com/questions/53972627/deque-not-growing-larger-than-255-elements</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFS</tag>
      
      <tag>CLion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【STL源码分析】序列式容器之list</title>
    <link href="/2022/05/22/2022-05/2022-05-22%20%E3%80%90STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%E4%B9%8Blist/"/>
    <url>/2022/05/22/2022-05/2022-05-22%20%E3%80%90STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%E4%B9%8Blist/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要内容参考：<a href="https://mp.weixin.qq.com/s/NcrnwsB2gjq9h7W2hIZ6PQ">2 万字+20 图带你手撕 STL 序列式容器源码</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[2 万字+20 图带你手撕 STL 序列式容器源码](https://mp.weixin.qq.com/s/NcrnwsB2gjq9h7W2hIZ6PQ)">[1]</span></a></sup>，原文内容非常详尽充实，建议大家阅读学习。而本文则是摘录总结关键部分，重点分析list的数据结构和关键函数实现。</p><h1 id="list数据结构"><a href="#list数据结构" class="headerlink" title="list数据结构"></a>list数据结构</h1><p>首先简单概括一下，SGI STL里list的实现是一个双向链表，并定义了专属的list迭代器，来对访问list中的节点，而list_iterator其实就是list_node进行了一些封装。</p><p>下面给出list实现相关的类图：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205241555886.jpeg" alt="类图"></p><p>list双向链表实现大致如下图所示，list含有一个_List_node 指针，代表着一个空节点（end函数返回该位置的迭代器），其next指向链表中实际的第一个节点（begin 对应的位置）。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205241555207.png" alt="list双向链表"></p><h1 id="list关键函数实现"><a href="#list关键函数实现" class="headerlink" title="list关键函数实现"></a>list关键函数实现</h1><ul><li><code>begin</code> ：返回第一个节点的迭代器。</li><li><code>end</code>：返回空元素节点的迭代器。</li><li><code>insert</code>： 将某一个元素插入到链表的一个位置上，有多组重载，具体实现来说就是调整相关指针的值。</li><li><code>push_back</code>：调用insert，在end( ) 位置上插入元素。</li><li><code>push_front</code>：调用insert，在begin( ) 位置上插入元素。</li><li><code>erase</code> ：删除节点，主要也是调整相关节点指针的值，然后回收节点内存和节点元素值的内存。</li><li><code>pop_back</code>：调用erase，删除end( ) 前一个位置上的元素。</li><li><code>pop_front</code>：调用erase，删除begin( ) 位置上的元素。</li><li><code>transfer(position, first, last)</code> ：参数类型都是list迭代器，函数作用是将[first, last) 上的元素<strong>移动</strong>到 position 位置前。</li><li><code>splice</code>：有多个重载，拼接元素或者是链表，实现上是去调用 transfer 函数。</li><li><code>merge</code> ： 将传入的 list 链表 x 与原链表按从小到大合并到原链表中(前提是两个链表都是已经从小到大排序了)。merge的实现也是去调用 transfer 函数。</li><li><code>reverse</code> ： 实现将链表翻转的功能，实现上简单来说就是将每个节点的 prev 与 next 值互换</li><li><code>operator=</code> 赋值操作： 需要考虑两个链表的实际大小不一样时的情况。如果原链表大 ，复制完后要删除掉原链表多余的元素；如果原链表小 ，复制完后要还要将x链表的剩余元素以插入的方式插入到原链表中。</li><li><code>resize </code><strong>：</strong> 重新修改 list 的大小，传入一个 new_size，如果链表旧长度大于 new_size 的大小, 那就删除后面多余的节点，否则插入新节点。</li><li><code>clear</code><strong>：</strong> 清除所有节点：遍历每一个节点，销毁(析构并释放)一个节点。</li><li><code>remove</code> ： 清除指定值的元素：遍历每一个节点，找到就移除。</li><li><code>unique</code> ： 清除数值相同的连续元素，注意只有“<strong>连续而相同的元素</strong>”，才会被移除剩一个。遍历每一个节点，如果在此区间段有相同的元素就移除之。</li></ul><hr><p>下面重点介绍下list根据自身数据结构特点，实现的sort成员函数。</p><ul><li><strong>sort 函数：</strong> list 容器自身实现一个排序（升序），<strong>其基本算法思想跟归并排序非常类似</strong>，并借助<code>merge</code>函数来排序。简单来说，使用一个链表数组来存储排序节点，每个下标为 i 的链表存储 2^i 的节点，每次从原链表中取出一个节点进行排序，并且排序节点的个数按 2^i 指数递增，最终将数组中的所有链表进行<code>merge</code>合并，从而实现原链表的排序。</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205241555270.png" alt="sort函数源码"></p><p>举一个简单的实现过程来帮助理解，例如对于链表 元素 { 7, 6, 5, 4, 3, 2, 1 }，排序过程大致描述如下：</p><ol><li>第1次排序 (7)</li><li>第2次排序 (6)</li><li>第3次排序 (7)、(6) 合并排序成 (6、7)</li><li>第4次排序 (5)</li><li>第5次排序 (4)</li><li>第6次排序 (5)、(4) 合并排序成 (4、5)</li><li>第7次排序（6、7）、(4、5）合并排序成 （4, 5, 6, 7）</li><li>第8次排序 (3)</li><li>第9次排序 (2)</li><li>第10次排序 (3)、(2) 合并排序成 (2, 3)</li><li>第11次排序 (1)</li><li>最后合并所有链表，即 (1) 、（2,3) 、（4, 5, 6, 7) 依次合并</li><li>第12次排序 (1) 、（2,3) 合并排序成 (1, 2, 3)</li><li>第13次排序 (1, 2, 3) 、(4, 5, 6, 7) 合并排序成 (1, 2, 3, 4, 5, 6, 7) </li><li>完成排序，结束。</li></ol><p> 下图是排序过程实现的图解，参考了 <a href="https://blog.csdn.net/qq_31720329/article/details/85535787">C++ STL LIST SORT 排序算法图解_zp0int的博客</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[C++ STL LIST SORT 排序算法图解_zp0int的博客](https://blog.csdn.net/qq_31720329/article/details/85535787)">[2]</span></a></sup>。</p><ul><li>注意其中的list、carry、counter[i] 都是双向链表，其实都包含有一个dummy节点（也就是end() 位置节点），但是为了方便，这里只画出了实际包含的节点值。</li><li>图里所说的while循环指的是第一层 while 循环，每次循环都是从list中取出一个节点，carry 作为中间过渡，所以每次循环结束后list节点数减一，carry 为空</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205241556288.svg" alt="sort函数整体实现过程"></p><p>上图描述了整体的执行过程，下图则具体描述第四次while循环里的执行过程，关注carry 和 counter链表的交互。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205241559080.jpeg" alt="第四次while循环具体过程"></p><p>在leecode上也有一道算法题 <a href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a> ，恰好就是要对一条链表实现排序，除了自顶向下的归并排序，大家也可以尝试使用上述的这种类归并排序算法进行实现，下面是我的实现，仅供参考。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125; <br>        ListNode* carry = <span class="hljs-literal">nullptr</span>;<br>        ListNode* counter[<span class="hljs-number">16</span>];      <span class="hljs-comment">// 因为题目说明节点数小于50000个，所以用16条链表足够</span><br>        <span class="hljs-type">int</span> fill = <span class="hljs-number">0</span>;               <span class="hljs-comment">// 下一个填充链表的下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">16</span>;i++) &#123;<br>            counter[i] = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-comment">// 拿出一个元素</span><br>            carry = head;<br>            head = head-&gt;next;<br>            carry-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            <br>            <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 当前排序链表下标</span><br>            <span class="hljs-keyword">while</span> (cur &lt; fill &amp;&amp; counter[cur] != <span class="hljs-literal">nullptr</span> ) &#123;<br>                counter[cur] = <span class="hljs-built_in">merge</span>(counter[cur], carry);<br>                carry = <span class="hljs-literal">nullptr</span>;            <br>                std::<span class="hljs-built_in">swap</span>(carry, counter[cur++]);<br>            &#125;<br>            std::<span class="hljs-built_in">swap</span>(carry,counter[cur]);<br>            <span class="hljs-keyword">if</span> (cur == fill) &#123;<br>                fill++;<br>            &#125;<br>        <br>        &#125;<br><br>        <span class="hljs-comment">// 最后将所有链表元素合并</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;fill;i++) &#123;<br>            counter[i] = <span class="hljs-built_in">merge</span>(counter[i<span class="hljs-number">-1</span>],counter[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> counter[fill<span class="hljs-number">-1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两条链表，并返回合并后的链表头结点</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode head;<br>        ListNode* cur = &amp;head;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">nullptr</span> &amp;&amp; l2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>                cur-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">nullptr</span>) &#123;<br>            cur-&gt;next = l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">nullptr</span>) &#123;<br>            cur -&gt;next = l1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最终简单总结一下，list 是一种双向链表。每个结点都包含一个数据域、一个前驱指针 prev 和一个后驱指针 next。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[2 万字+20 图带你手撕 STL 序列式容器源码](https://mp.weixin.qq.com/s/NcrnwsB2gjq9h7W2hIZ6PQ)">[1]</span></a></sup></p><p>由于其链表特性，实现同样的操作，相对于 STL 中的通用算法， list 的成员函数通常有更高的效率，内部仅需做一些指针的操作，因此尽可能选择 list 成员函数。</p><p><strong>优点</strong></p><ul><li><p>在内部方便进行插入删除操作。</p></li><li><p>可在两端进行push和pop操作。</p></li></ul><p><strong>缺点</strong></p><ul><li><p>不支持随机访问，即不支持下标操作[ ] 和 .at()。</p></li><li><p>相对于 vector 占用额外内存多（额外指针的开销）。</p></li></ul><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/NcrnwsB2gjq9h7W2hIZ6PQ">2 万字+20 图带你手撕 STL 序列式容器源码</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/qq_31720329/article/details/85535787">C++ STL LIST SORT 排序算法图解_zp0int的博客</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Again</title>
    <link href="/2022/05/17/2022-05/2022-05-17%20Again/"/>
    <url>/2022/05/17/2022-05/2022-05-17%20Again/</url>
    
    <content type="html"><![CDATA[<p class='note note-primary'>  <font size="3">    “要将我这种人导回正途，恐怕得先请人全面否定我一遍才行，必须把我逼到无处可逃、无法自保的地步，再将我折磨得体无完肤。”                         ——摘录来自《三日间的幸福》，三秋缒  </font></p><p>起初只是到了周五晚，手痒痒了，想打几把联盟，但恰逢舍友不再宿舍，就算不熄灯也不会影响别人，所以又任性打到了凌晨1点，此时又没了睡意，就又熬夜看手机，陷入了不想睡觉的境地，明明告诉自己这个点要睡了，但却控制不住自己，想着看完这一集就睡，然后又是一集又一集。</p><p>而熬夜带来的后果则是作息的混乱，自信的受挫，而欲望也与此同时趁虚而入，”反正是周末，就算再打几把也没关系吧，今天周六就再打一天吧，明天再好好学习“，就这样败给了自己的欲望，等回过神来，又是一天过去了，又到了夜深人静的时候，又一次地上床看手机到凌晨3、4点，然后又是带着疲惫和愧疚，迎来下一天。</p><p>Again and again.</p><p>直到周二才终于回过神来，因为有一个汇报DDL必须要下午进行了，这促使着我必须去教室做PPT，而当我漫不经心地完成后，又陷入了迷茫的困境，或许是因为有太多累计的事情要做吧，一时间反而不知道该去什么了，或者说没有动力去做了。而与此同时，邪念又在我的脑海浮现，”反正完成了一个DDL，不如再去玩几把吧“，这令我不寒而栗，但教室的氛围还是制止了我，把我拉了回来。可我还是不知所措，然后又刷起了B站，看漫画的解说视频打发时间，后来有看到推荐的一部小说《三日间的幸福》，抱着或许能从中获取点精神力量的念头，从网上找到电子书资源看了起来。</p><p>好巧不巧，看完大概2个小时，刚好离汇报还有一个吃饭的时间。而这本书也的确给了我些许鼓舞，或许目前的心境使然，楠木和宫城的爱情固然令人动容，但我更多想到的是对时间的 体会。本该为无价之宝的时间&#x2F;寿命，却被以惨淡的价格标注，而这正是因为自己的不珍惜，不幸福，不努力改变所致，但对真正心灰意冷、对一切失去热情、找不到生活的意义的人来说，恐怕也无法意识到这一点，或者说就算意识到了，心也早已麻木了罢。</p><p>或许我的境遇和主角有些类似，也曾自命不凡，但也遭到现实的打击（其实是自己一手造成的），认清了自己的平凡和弱小，也染上了致命的陋习。或许是在实习独居的那段时候染上的吧，因为没有了外在的约束，所以恣意妄为，三番五次地熬夜，然后拖着疲惫不堪的身体去实习上班。而这恶习也在读研期间继续折磨着我，消磨我的意志，我能一星期每天学习9小时，也能连续3天每天打上12个小时的游戏，甚至期间熬夜。没有人想到我会变成这幅模样，因为我自己也没想过自己会变得如此，渐渐成为自己厌恶的模样。</p><p>但更令人气愤的是，我却只能事后懊悔，然后带着耻辱和不甘重新出发，就像从前那样，奋斗，堕落，然后又继续奋斗。或许人就是这样一种复杂的生物吧，或者说我更希望能这么去解释，承认自己的无能和弱小，然后养足精神，再次向生活发出挑战吧！就像从前那样，”不过是从头再来“，”现在行动也为时不晚“，”船到桥头自然直“，”我也知道这么祈求很无耻，但我还是希望自己可以有重头再来的机会“。。。</p><p>Again !</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【设计模式】职责链与命令模式</title>
    <link href="/2022/05/09/2022-05/2022-05-09%20%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E8%81%8C%E8%B4%A3%E9%93%BE%E4%B8%8E%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/05/09/2022-05/2022-05-09%20%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E8%81%8C%E8%B4%A3%E9%93%BE%E4%B8%8E%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Chain-of-Responsibility（职责链）——对象行为模式"><a href="#Chain-of-Responsibility（职责链）——对象行为模式" class="headerlink" title="Chain of Responsibility（职责链）——对象行为模式"></a>Chain of Responsibility（职责链）——对象行为模式</h1><h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>让多个对象都有机会处理请求，从而避免请求发送者与接收者耦合在一起。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><h2 id="2-动机"><a href="#2-动机" class="headerlink" title="2. 动机"></a>2. 动机</h2><blockquote><p>参考：<a href="https://blog.csdn.net/qq_38636211/article/details/97762272">责任链(Chain of Responsibility)模式_饭团小神的博客-CSDN博客_责任链</a></p></blockquote><p>从第一个对象开始，链中收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者。提交请求的对象并不明确知道哪一个对象将会处理它——我们说该读请求有一个隐式的接受者（implicit receiver）。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[责任链(Chain of Responsibility)模式_饭团小神的博客-CSDN博客_责任链](https://blog.csdn.net/qq_38636211/article/details/97762272)">[1]</span></a></sup></p><p>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><h2 id="3-适用性"><a href="#3-适用性" class="headerlink" title="3. 适用性"></a>3. 适用性</h2><p>在以下条件下使用 Chain of Responsibility 模式：</p><ul><li><p>有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。</p></li><li><p>你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</p></li><li><p>可处理一个请求的对象集合应该被动态指定。</p></li></ul><h2 id="4-结构"><a href="#4-结构" class="headerlink" title="4. 结构"></a>4. 结构</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205092127248.jpeg" alt="结构图"></p><p>一个典型的对象结果可能如下图所示：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205092127543.jpeg"></p><h2 id="5-参与者"><a href="#5-参与者" class="headerlink" title="5. 参与者"></a>5. 参与者</h2><ul><li>Handler<ul><li>定义一个处理请求的接口</li><li>当作为所有ConcreteHandler的接口时，需要设置后续链的接口，当作为责任链最后的结尾可以不用设置后续接口</li></ul></li><li>ConcreteHandler<ul><li>处理它所负责的请求。</li><li>可访问它的后继者</li><li>如果可处理该请求，就处理这个请求，否则将该请求转发给它的后继者。</li></ul></li><li>Client<ul><li>向链上的具体处理者(ConcreteHandler)对象提交请求。</li></ul></li></ul><h2 id="6-协作"><a href="#6-协作" class="headerlink" title="6. 协作"></a>6. 协作</h2><p>当客户提交一个请求时，请求沿链传递直至有一个ConcreteHandler对象负责处理它</p><h2 id="7-效果"><a href="#7-效果" class="headerlink" title="7. 效果"></a>7. 效果</h2><ul><li>优点：<ul><li><strong>降低耦合度</strong>。该模式使得一个对象无需知道是其他哪一个对象的其请求。对象仅需知道该请求会被“正确”地处理。接受者和发送者都没有对方的明确的信息，且链中的对象不需知道链的结构。结果是，责任链可以简化对象的相互连接。它们仅需保持一个指向其后继者的引用，而不需要保持它所有的候选接受者的引用。</li><li><strong>增强了给对象指派责任(Responsibility)的灵活性</strong>。当在对象中分配职责时，职责链给你更多的灵活性，你可以通过在运行时刻对该链进行动态的增加或者修改来增加或者改变处理一个请求的那些职责。你可以将这种机制与静态的特例化处理对象的继承机制结合起来使用。</li></ul></li><li>缺点：<ul><li><strong>不保证被接受。</strong> 既然一个请求没有明确的接受者，那么就不能保证它一定会被处理——该请求可能一直在链对的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理。</li></ul></li></ul><h2 id="8-实现"><a href="#8-实现" class="headerlink" title="8. 实现"></a>8. 实现</h2><p>在职责链模式中要考虑的实现问题：</p><ul><li><p><strong>实现后继者链</strong>。有两种方法可以实现后继者链。</p><ul><li>a) 定义新的链接(通常在Handler中定义，也可由ConcreteHandlers来定义)。</li><li>b) 使用已有的链接。</li></ul></li><li><p><strong>连接后继者。</strong> 如果没有已有的引用可定义一个链，那么你必须自己引入它们。这种情况下Handler不仅定义该请求的接口，通常也维护后继链接(可以通过构造器实现)。</p></li><li><p><strong>表示请求</strong>。可以有不同的方法表示请求。最简单的形式，请求是一个硬编码的(Hard-coded)操作调用。这种形式方便而且安全。但你只能转发Handler类定义的固定的一组请求。另一种选择是使用一个处理函数，这个函数通常以一个请求码(如一个整型常数或者一个字符串)为参数。这种方法支持请求数目不限。唯一的要求是发送方和接受方在请求如何编码问题上达成一致。</p></li></ul><h2 id="9-示例代码"><a href="#9-示例代码" class="headerlink" title="9. 示例代码"></a>9. 示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// ChainResponsibility.h</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/5/8.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BEHAVIORALPATTERNDESIGN_CHAINRESPONSIBILITY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEHAVIORALPATTERNDESIGN_CHAINRESPONSIBILITY_H</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 参考这个例子：https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html</span><br><span class="hljs-comment"> * 模拟场景：把打印的消息作为请求，把消息传递给Logger，各个Logger判断该消息级别是否符合自身要求，</span><br><span class="hljs-comment"> * 如果符合则进行处理打印，否则交给下一级（更高级）的Logger</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_chain_responsibility</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">MESSAGE_LEVEL</span> &#123;<br>    INFO,<br>    DEBUG,<br>    WARNING,<br>    ERROR,<br>&#125;;<br><br><span class="hljs-comment">// 抽象日志，相当于是 Handler类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractLogger</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    AbstractLogger* next_logger;<br>    MESSAGE_LEVEL level;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_next_logger</span><span class="hljs-params">(AbstractLogger* logger)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (logger != <span class="hljs-literal">nullptr</span>)<br>            next_logger = logger;<br>    &#125;<br>    <span class="hljs-built_in">AbstractLogger</span>(MESSAGE_LEVEL level, AbstractLogger* logger): <span class="hljs-built_in">level</span>(level), <span class="hljs-built_in">next_logger</span>(logger) &#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print_message</span><span class="hljs-params">(MESSAGE_LEVEL info_level, string message)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level &gt;= info_level) &#123;<br>            cout &lt;&lt; message &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next_logger != <span class="hljs-literal">nullptr</span>)&#123;<br>            next_logger-&gt;<span class="hljs-built_in">print_message</span>(info_level,message);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InfoLogger</span> : <span class="hljs-keyword">public</span> AbstractLogger &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">InfoLogger</span>(MESSAGE_LEVEL level, AbstractLogger* logger): <span class="hljs-built_in">AbstractLogger</span>(level, logger) &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print_message</span><span class="hljs-params">(MESSAGE_LEVEL info_level, string message)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level &gt;= info_level) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;InfoLogger 输出消息颜色为黑色，消息：&quot;</span> &lt;&lt; message &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next_logger != <span class="hljs-literal">nullptr</span>) &#123;<br>            next_logger-&gt;<span class="hljs-built_in">print_message</span>(info_level,message);<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugLogger</span>: <span class="hljs-keyword">public</span> AbstractLogger &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DebugLogger</span>(MESSAGE_LEVEL level, AbstractLogger* logger): <span class="hljs-built_in">AbstractLogger</span>(level, logger) &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print_message</span><span class="hljs-params">(MESSAGE_LEVEL info_level, string message)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level &gt;= info_level) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;DebugLogger 输出消息颜色为灰色，消息：&quot;</span> &lt;&lt; message &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next_logger != <span class="hljs-literal">nullptr</span>)&#123;<br>            next_logger-&gt;<span class="hljs-built_in">print_message</span>(info_level,message);<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WarningLogger</span> : <span class="hljs-keyword">public</span> AbstractLogger &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">WarningLogger</span>(MESSAGE_LEVEL level, AbstractLogger* logger): <span class="hljs-built_in">AbstractLogger</span>(level, logger) &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print_message</span><span class="hljs-params">(MESSAGE_LEVEL info_level, string message)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level &gt;= info_level) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;WarningLogger 输出消息颜色为黄色，消息：&quot;</span> &lt;&lt; message &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next_logger != <span class="hljs-literal">nullptr</span>)&#123;<br>            next_logger-&gt;<span class="hljs-built_in">print_message</span>(info_level,message);<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorLogger</span> : <span class="hljs-keyword">public</span> AbstractLogger &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ErrorLogger</span>(MESSAGE_LEVEL level, AbstractLogger* logger): <span class="hljs-built_in">AbstractLogger</span>(level, logger) &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print_message</span><span class="hljs-params">(MESSAGE_LEVEL info_level, string message)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level &gt;= info_level) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;ErrorLogger 输出消息颜色为红色，消息：&quot;</span> &lt;&lt; message &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next_logger != <span class="hljs-literal">nullptr</span>)&#123;<br>            next_logger-&gt;<span class="hljs-built_in">print_message</span>(info_level,message);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//BEHAVIORALPATTERNDESIGN_CHAINRESPONSIBILITY_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// ChainResponsibility.cpp</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/5/8.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ChainResponsibility.h&quot;</span></span><br><span class="hljs-function">AbstractLogger* <span class="hljs-title">get_logger</span><span class="hljs-params">()</span> </span>&#123;<br>    AbstractLogger* info_logger = <span class="hljs-keyword">new</span> <span class="hljs-built_in">InfoLogger</span>(MESSAGE_LEVEL::INFO, <span class="hljs-literal">nullptr</span>);<br>    AbstractLogger* debug_logger = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DebugLogger</span>(MESSAGE_LEVEL::DEBUG, <span class="hljs-literal">nullptr</span>);<br>    AbstractLogger* warning_logger = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WarningLogger</span>(MESSAGE_LEVEL::WARNING, <span class="hljs-literal">nullptr</span>);<br>    AbstractLogger* error_logger = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ErrorLogger</span>(MESSAGE_LEVEL::ERROR, <span class="hljs-literal">nullptr</span>);<br>    info_logger-&gt;<span class="hljs-built_in">set_next_logger</span>(debug_logger);<br>    debug_logger-&gt;<span class="hljs-built_in">set_next_logger</span>(warning_logger);<br>    warning_logger-&gt;<span class="hljs-built_in">set_next_logger</span>(error_logger);<br>    <span class="hljs-keyword">return</span> info_logger;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_chain_responsibility</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————开始测试 Chain of Responsibiliy 模式——————&quot;</span> &lt;&lt; endl;<br><br>    AbstractLogger* logger = <span class="hljs-built_in">get_logger</span>();<br>    logger-&gt;<span class="hljs-built_in">print_message</span>(MESSAGE_LEVEL::DEBUG, <span class="hljs-string">&quot;调试当前数据&quot;</span>);<br>    logger-&gt;<span class="hljs-built_in">print_message</span>(MESSAGE_LEVEL::INFO, <span class="hljs-string">&quot;输出一条普通信息&quot;</span>);<br>    logger-&gt;<span class="hljs-built_in">print_message</span>(MESSAGE_LEVEL::ERROR, <span class="hljs-string">&quot;运行时报错！&quot;</span>);<br>    logger-&gt;<span class="hljs-built_in">print_message</span>(MESSAGE_LEVEL::WARNING, <span class="hljs-string">&quot;有一个变量没有赋初值！&quot;</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;——————结束测试 Chain of Responsibiliy 模式——————&quot;</span> &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-相关模式"><a href="#10-相关模式" class="headerlink" title="10. 相关模式"></a>10. 相关模式</h2><p><strong>Composite</strong>模式： 责任链模式长与Composite模式一起使用。这种情况下，一个构件的父构件可作为它的后续。</p><h1 id="Command（命令）——对象行为型模式"><a href="#Command（命令）——对象行为型模式" class="headerlink" title="Command（命令）——对象行为型模式"></a>Command（命令）——对象行为型模式</h1><h2 id="1-意图-1"><a href="#1-意图-1" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2. 别名"></a>2. 别名</h2><p>动作（action），事物（transaction）</p><h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3. 动机"></a>3. 动机</h2><p>有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接受者的任何信息。</p><p>命令模式通过将请求本身变成一个对象来使工具箱的对象可向未指定的应用对象提出请求。这个对象可被存储并向其他的对象一样被传递。这一模式的关键是一个抽象的Command类或者接口，它定义了一个执行操作的接口。 其最简单的形式是一个抽象的Execute操作。 具体的Command实现将真正的接受者(Receiver)作为其一个实例变量(使用委托的方式)。并实现Execute操作，指定接受者采取的动作。而接受者有执行该请求所需的具体信息。</p><h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4. 适用性"></a>4. 适用性</h2><p>当你有如下需求的时候，可以使用Command模式：</p><ul><li>需要抽象出待执行的动作以参数化某对象。你可用过程语言中的回调(callback)函数表达式这种参数化机制。所谓的回调函数是指某函数先在某处注册，而它将在稍后某个需要的时候被调用。Command模式时回调机制的一个面向对象的代替品。</li><li>在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。</li><li>支持取消操作 Command的Execute操作，可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command接口必须添加一个Unexecute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这个列表并分别调用undo和execute来实现重数不限的“撤销”和“执行”。</li><li>支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍 在Command接口中添加中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。</li><li>用来构建在原语操作上的高层操作构造一个系统。这样一种的结构在支持**事务(transaction)**的信息系统中很常见。</li></ul><h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5. 结构"></a>5. 结构</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205092130408.jpeg" alt="结构图"></p><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6. 参与者"></a>6. 参与者</h2><ul><li>Command<ul><li>声明执行操作的接口</li></ul></li><li>ConcreteCommand<ul><li>将一个接受者对象绑定于一个动作</li><li>调用接受者相应的操作，以执行Execute</li></ul></li><li>Client<ul><li>创建一个具体命令对象并设定它的接收者</li></ul></li><li>Invoker<ul><li>要求该命令执行这个请求</li></ul></li><li>Reveiver<ul><li>知道如何实施和执行一个请求相关的操作。任何类都可能作为一个接受者</li></ul></li></ul><h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7. 协作"></a>7. 协作</h2><ul><li>Client创建一个ConcreteCommand对象并制定它的Receiver对象</li><li>某Invoker对象存储该ConcreteCommand对象。</li><li>该Invoker通过调用Command对象的execute操作来提交一个请求。若该命令是可撤销的。ConcreteCommand就在执行Execute操作之前存储当前状态以用于取消该命令。</li><li>ConcreteCommand对象对调用它的Receiver的一些操作以执行该请求</li></ul><p>下图是展示了这些对象之间的交互的序列图。它说明了Command是如何将调用者和接受者(以及它执行的请求)解耦的：<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[命令(Command)模式](https://blog.csdn.net/qq_38636211/article/details/97755767?spm=1001.2014.3001.5502)">[2]</span></a></sup></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205092130258.png" alt="图片来源：https://blog.csdn.net/qq_38636211/article/details/97755767?spm=1001.2014.3001.5502"></p><h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8. 效果"></a>8. 效果</h2><p>Command模式有以下的优点和缺点：</p><p><strong>优点</strong>：</p><ul><li>Command模式将调用操作的对象与知道如何实现该操作的对象解耦。</li><li>ConcreteCommand是头等的对象。它们可像其他的对象一样被操纵和扩展</li><li>你可以将多个命令封装成一个复合的命令。一般来说，复合命令是Composite模式的一个实例。</li><li>增加新的ConcreteCommand很容易，因为这个无需改变已有的类。</li></ul><p><strong>缺点</strong>：</p><ul><li>类的数目大大增加 完成一个目标需要大量的类和对象协同合作。应用程序开发人员需要小心正确地开发这些类。</li><li>提升了实现和维护的工作量 每个单独的命令都是一个ConcreteCommand类，它增加了实现和维护的类的数量。</li></ul><h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9. 实现"></a>9. 实现</h2><p>实现Command模式需要考虑一下问题：</p><ul><li><strong>一个命令对象应该达到何种的智能程度。</strong> 命令对象的能力可大可小。一个极端是它仅确定一个接受者和执行该请求的动作。另一极端是它自己实现了所有功能。</li><li>**支持取消(undo)和重做(redo)**。如果Command提供方法逆转(reverse)它们操作的执行(例如LightOnCommand的undo())，就可以支持取消和重做(两次撤销就相当于重做啊! 仅仅只存储一次操作时)功能。为达到这个目的ConcreteCommand类可能需要存储额外的状态信息。</li><li><strong>避免取消操作过程中的错误累积</strong>。</li><li><strong>使用C++模板。</strong> 对于不能撤销和不需要参数的命令，可使用C++模板来实现，这样可以避免为每一种动作和接收者都创建一个Command子类。</li></ul><h2 id="10-示例代码"><a href="#10-示例代码" class="headerlink" title="10. 示例代码"></a>10. 示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Command.h</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/5/8.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BEHAVIORALPATTERNDESIGN_COMMAND_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEHAVIORALPATTERNDESIGN_COMMAND_H</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_command</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 参考：http://c.biancheng.net/view/1380.html</span><br><span class="hljs-comment"> * 模拟场景：一个餐馆可以对提供多个功能（抽象成命令），而这些功能/命令具体由特别的人物负责，</span><br><span class="hljs-comment"> * 例如饭菜由厨师负责，收拾由服务员负责，收银由收银员负责</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 厨师，相当于 Receiver 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chief</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;大厨正在烧菜...&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;菜烧好了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 服务员，相当于 Receiver 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Waiter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clean_table</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;服务员正在清理桌面...&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;桌面理好了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">serve_meal</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;服务员正在上菜...&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-comment">// 收银员，相当于 Receiver 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cashier</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkout</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;收银员结账&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 服务，相当于抽象出来的 Command类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Service</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">serve</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 提供餐食，这是一个组合命令，厨师做菜，然后服务员端菜</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProvideMeal</span> : <span class="hljs-keyword">public</span> Service &#123;<br><span class="hljs-keyword">private</span>:<br>    Chief *chief;<br>    Waiter *waiter;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ProvideMeal</span>(Chief *chief, Waiter *waiter) : <span class="hljs-built_in">chief</span>(chief), <span class="hljs-built_in">waiter</span>(waiter) &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">serve</span><span class="hljs-params">()</span> </span>&#123;<br>        chief-&gt;<span class="hljs-built_in">cook</span>();<br>        waiter-&gt;<span class="hljs-built_in">serve_meal</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 收拾碗筷</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CleanUp</span> : <span class="hljs-keyword">public</span> Service &#123;<br><span class="hljs-keyword">private</span>:<br>    Waiter *waiter;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CleanUp</span>(Waiter *waiter) : <span class="hljs-built_in">waiter</span>(waiter) &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">serve</span><span class="hljs-params">()</span> </span>&#123;<br>        waiter-&gt;<span class="hljs-built_in">clean_table</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 收银</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cashiering</span> : <span class="hljs-keyword">public</span> Service &#123;<br><span class="hljs-keyword">private</span>:<br>    Cashier *cashier;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cashiering</span>(Cashier *cashier) : <span class="hljs-built_in">cashier</span>(cashier) &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">serve</span><span class="hljs-params">()</span> </span>&#123;<br>        cashier-&gt;<span class="hljs-built_in">checkout</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 餐馆，相当于 Invoker类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Restaurant</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Service *meal;<br>    Service *clean;<br>    Service *cash;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Restaurant</span>(Service *meal, Service *clean, Service *cash) : <span class="hljs-built_in">meal</span>(meal), <span class="hljs-built_in">clean</span>(clean), <span class="hljs-built_in">cash</span>(cash) &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">serve_client</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;食客进入餐馆...&quot;</span> &lt;&lt; endl;<br>        meal-&gt;<span class="hljs-built_in">serve</span>();<br><br><br>        cout &lt;&lt; <span class="hljs-string">&quot;\n食客用食完毕...&quot;</span> &lt;&lt; endl;<br>        cash-&gt;<span class="hljs-built_in">serve</span>();<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;\n食客离开餐馆...&quot;</span> &lt;&lt; endl;<br>        clean-&gt;<span class="hljs-built_in">serve</span>();<br>    &#125;<br><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//BEHAVIORALPATTERNDESIGN_COMMAND_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Command.cpp</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/5/8.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Command.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_command</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————开始测试 Command  命令模式——————&quot;</span> &lt;&lt; endl;<br><br>    Service *meal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ProvideMeal</span>(<span class="hljs-keyword">new</span> Chief, <span class="hljs-keyword">new</span> Waiter);<br>    Service *clean = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CleanUp</span>(<span class="hljs-keyword">new</span> Waiter);<br>    Service *cash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cashiering</span>(<span class="hljs-keyword">new</span> Cashier);<br><br>    <span class="hljs-function">Restaurant <span class="hljs-title">restaurant</span><span class="hljs-params">(meal, clean, cash)</span></span>;<br>    restaurant.<span class="hljs-built_in">serve_client</span>();<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;——————开始测试 Command 命令模式——————&quot;</span> &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-相关模式"><a href="#11-相关模式" class="headerlink" title="11. 相关模式"></a>11. 相关模式</h2><ul><li><p><strong>Composite</strong>(组合)模式： 可以使用组合模式来实现宏命令</p></li><li><p><strong>Memento</strong>(备忘录)模式： 可用来保持某个状态，命令用这一状态来取消它的效果。</p></li><li><p><strong>Proxytype</strong>(原型)模式： 在被放入历史列表前必须被拷贝的命令可以起到一种原型的作用</p></li></ul><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/qq_38636211/article/details/97762272">责任链(Chain of Responsibility)模式_饭团小神的博客-CSDN博客_责任链</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/qq_38636211/article/details/97755767?spm=1001.2014.3001.5502">命令(Command)模式</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【面试智力题】100匹马中找出最快的4匹</title>
    <link href="/2022/05/07/2022-05/2022-05-07%20%E3%80%90%E9%9D%A2%E8%AF%95%E6%99%BA%E5%8A%9B%E9%A2%98%E3%80%91/"/>
    <url>/2022/05/07/2022-05/2022-05-07%20%E3%80%90%E9%9D%A2%E8%AF%95%E6%99%BA%E5%8A%9B%E9%A2%98%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前腾讯面试的时候，出了一道智力题，跟赛马相关的，大意就是总共100匹马，共有4条赛道，请问最少比赛几次就能选出最快的4匹马，假设比赛不能计时，只能比较快慢。</p><p>这不巧了吗，正好最近我在看赛马娘2，对赛马也是略知一二，这题，拿下！</p><p>咳咳，不好意思，好像植入了一段广告（doge）。不过残酷的现实是，当时完全没有好的思路，就想着依次选出最快的马，然后被最快的马淘汰的再比较，选出第二快的马，实际写起来的时候思路就乱糟糟的，可能也是因为面试紧张的原因吧。但现在回过神来，冷静思考分析后，感觉还是可以跟大家分享一下我的思路。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>网上类似的参考文章有：</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/189771676">100匹马，4个赛道，找出跑最快的4匹马。</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/351556354">64匹马，8个赛道，找出最快的4匹马，要比赛多少轮？（延伸到一般情况）</a></p></li></ul><p>都提供了不错的思路，然后我也是自己再尝试计算了一下，最后算出来最少需要36轮，可能也不是最准确的，下面就介绍一下我的思路。</p><ol><li><p>首先100匹马，分成25组，<strong>比赛25次</strong>，比较出每组的1234名。（组号表示为1、2、3 … 25 ， 1-1 表示第1组的第1名）</p></li><li><p>选出每组的第一名，那么总共有25匹马，分成7组，前6组都是4匹马，最后一组只有一匹马（组号表示为 A、B、C、D、E、F、G， 用字母表示，A-1 表示第A组的第1名，G组只有一匹马就是25-1）；<strong>前6组比赛6次</strong>，又选出每组1234名</p></li><li><p>A-1、B-1、C-1、D-1 比赛一次，然后拿这一次的第1名和 E-1、F-1、G-1进行比赛，此时就能<strong>选出最快的一匹马</strong>，<strong>至此共比赛了 25+6+2 &#x3D; 33次</strong></p></li><li><p>为了方便理解，不妨设上一步比赛中，最快的是A-1（其实选A-1、B-1、C-1、D-1、E-1、F-1都是一样的，可以替换。而如果最快的是G-1 ，会具有特殊性，需要再比较的马的数量更少（因为G-1之前只跟3匹马比赛过），所以要计算最少的比赛次数不能选G-1。</p><ul><li>进一步假设，不妨认为上一步中两次比赛的排名为 A-1、B-1、C-1、D-1 和 A-1、E-1、F-1、G-1，因为调换顺序也不影响下面的计算</li></ul></li><li><p>因为A-1是最快的马，而现在要选出第2快的马，那么第2快的马就有可能出现在被A-1淘汰的马中。不妨进一步将设，A组比赛的结果为  1-1 、2-1、3-1、4-1 ，即 A-1 为 1-1，以此类推 B-1为5-1 。那么第2快的马可能的集合为 { 1-2 、2-1&#x2F;A-2、B-1、E-1  }  ，此时<strong>只要再比赛1次</strong>，<strong>就能选出第2快的马</strong>。</p></li><li><p>在上一步的比赛结果中，如果1-2是第一名，那么只要拿第二名和1-3比赛就能选出第3快的马，而如果2-1、B-1、E-1 是第一名，都是再拿出2匹马和第二名比较（例如，选2-1，则要比较 3-1&#x2F;A-3和2-2；选B-1即 5-1，则要比较 6-1&#x2F;B-2 和 5-2），所以<strong>只要再比赛1次</strong>，<strong>就能选出第3快的马</strong>。</p></li><li><p>同理，在上一次比赛结果的基础上，最多再选出2匹马和上次比赛的第二名</p><p>比赛1次，就能选出第4快的马。</p><ul><li>例如上次比赛结果为 { 6-1&#x2F;B-2、5-2、17-1&#x2F;E-1 } ，那么只要从 { 6-2、7-1&#x2F;B-3、5-2 } 里再比一次即可。</li></ul></li><li><p>最终，最少需要的比赛次数为 25+6+2+1+1+1 &#x3D; 36 次</p></li></ol><hr><p>下图演示了其中一种可能的比赛情况：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205072105132.png" alt="一种可能比赛情况"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>最后小结一下，遇到这种智力题，也不要过于慌张吧，有什么思路就表达出来，虽然不一定准确， 但表达的时候要注意思思路清晰，不要因为感觉这个思路不对或者自己做不出来，就自暴自弃，在心底告诉自己这次不行了，面试嘛，要笑着面~</p><p>最后的最后，感兴趣的朋友去看看赛马娘2吧~</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205072114453.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智力题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【设计模式】外观模式与代理模式</title>
    <link href="/2022/04/30/2022-04/2022-04-30%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/30/2022-04/2022-04-30%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Facade（外观）——对象结构模式"><a href="#Facade（外观）——对象结构模式" class="headerlink" title="Facade（外观）——对象结构模式"></a>Facade（外观）——对象结构模式</h1><h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><h2 id="2-动机"><a href="#2-动机" class="headerlink" title="2. 动机"></a>2. 动机</h2><p>将一个系统划分成若干个子系统有利于降低系统的复杂性。一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小。达到该目标的途经之一就是引入一个外观（Facade）对象，他为子系统中较为一般的设施提供了一个单一而简单的界面。</p><h2 id="3-适用性"><a href="#3-适用性" class="headerlink" title="3. 适用性"></a>3. 适用性</h2><p>以下情况使用Facade模式：</p><ul><li>当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂，大多数模式使用时都会产生更多更小的类。这使得子系统具有可复用性，也更容易对子系统进行定制，但也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多可定制性的用户可以越过Facade层。</li><li>客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户及其他的子系统分离，可以提高子系统的独立性和可移植性。</li><li>当你需要构建一个层次结构的系统时，使用Facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，可以让它们仅通过Facade进行通信，从而简化了它们之间的依赖关系。</li></ul><h2 id="4-结构"><a href="#4-结构" class="headerlink" title="4. 结构"></a>4. 结构</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204301544750.jpeg" alt="结构图"></p><h2 id="5-参与者"><a href="#5-参与者" class="headerlink" title="5. 参与者"></a>5. 参与者</h2><ul><li>Facade<ul><li>知道哪些子系统类负责处理请求</li><li>将客户的请求代理给适当的子系统对象</li></ul></li><li>Subsystem Class<ul><li>实现子系统的功能</li><li>处理由Facade对象指派的任务</li><li>没有Facade的任何相关信息，即没有指向Facade的指针</li></ul></li></ul><h2 id="6-协作"><a href="#6-协作" class="headerlink" title="6. 协作"></a>6. 协作</h2><ul><li>客户程序通过发送请求给Facade的方式与子系统通信，Facade将这些消息转发给适当的子系统对象。尽管是子系统中的有关对象在做实际工作，但Facade模式本身也必须将它的接口转换成子系统的接口。</li><li>使用Facade的客户程序不需要直接访问子系统对象。</li></ul><h2 id="7-效果"><a href="#7-效果" class="headerlink" title="7. 效果"></a>7. 效果</h2><p>Facade模式有下面的一些有点：</p><ul><li>它对客户屏蔽子系统组件，因而减少了客户处理的对象数目并使得子系统使用起来更加方便</li><li>它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的。松耦合关系使得子系统的组件变化不会影响到它的客户。Facade模式有助于建立层次结构系统，也有助于对对象之间的依赖关系分层。Facade模式可以消除复杂的循环依赖关系。在大型软件系统中降低编译依赖性至关重要。</li><li>如果应用需要，它并不限制他们使用子系统类，因此你可以在系统易用性和通用性之间加以选择。</li></ul><h2 id="8-示例代码"><a href="#8-示例代码" class="headerlink" title="8. 示例代码"></a>8. 示例代码</h2><p>测试模拟场景，Client 通过 Painter 这个 Facade，来绘制图形，根据需求改变大小和填充颜色，隐藏具体实现细节包括 图形Shape，颜色Color，线条边框Line。类图如下所示，为了简化实现，所以考虑各子系统之间的依赖关系。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204301544778.jpeg" alt="类图"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Facade.h</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/30.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STRUCTURALPATTERNDESIGN_FACADE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRUCTURALPATTERNDESIGN_FACADE_H</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 模拟场景，Client 通过 Painter 这个 Facade，来绘制图形，根据需求改变大小和填充颜色</span><br><span class="hljs-comment"> * 隐藏具体实现细节包括 图形Shape，颜色Color，线条边框Line</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">namespace</span> facade &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_facade</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Shape</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">0</span>) : <span class="hljs-built_in">size</span>(size) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_size</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>-&gt;size = size;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw_shape</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> size;<br>    &#125;;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw_shape</span><span class="hljs-params">()</span> </span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;绘制一个长方形，size为&quot;</span> &lt;&lt; size &lt;&lt; endl;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw_shape</span><span class="hljs-params">()</span> </span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;绘制一个圆形，size为&quot;</span> &lt;&lt; size &lt;&lt; endl;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fill_color</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    &#125;;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Red</span> : <span class="hljs-keyword">public</span> Color &#123;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fill_color</span><span class="hljs-params">()</span> </span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;填充红色&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blue</span> : <span class="hljs-keyword">public</span> Color &#123;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fill_color</span><span class="hljs-params">()</span> </span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;填充蓝色&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw_line</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    &#125;;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SolidLine</span> : <span class="hljs-keyword">public</span> Line &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw_line</span><span class="hljs-params">()</span> </span>&#123;<br>           cout &lt;&lt; <span class="hljs-string">&quot;绘制实线边框&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">DottedLine</span> : <span class="hljs-keyword">public</span> Line &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw_line</span><span class="hljs-params">()</span> </span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;绘制虚线边框&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Painter</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeType</span> &#123;<br>            Rectangle,<br>            Circle<br>        &#125;;<br>        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ColorType</span>&#123;<br>            Red,<br>            Blue<br>        &#125;;<br>        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">LineType</span> &#123;<br>            SolidLine,<br>            DottedLine<br>        &#125;;<br><br>        <span class="hljs-built_in">Painter</span>() &#123;<br>            shape_map[Rectangle] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">class</span> Rectangle;<br>            shape_map[Circle] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">class</span> Circle;<br>            color_map[Red] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">class</span> Red;<br>            color_map[Blue] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">class</span> Blue;<br>            line_map[SolidLine] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">class</span> SolidLine;<br>            line_map[DottedLine] =  <span class="hljs-keyword">new</span> <span class="hljs-keyword">class</span> DottedLine;<br>        &#125;<br>        ~<span class="hljs-built_in">Painter</span>() &#123;<br>            <span class="hljs-keyword">delete</span> shape_map[Rectangle];<br>            <span class="hljs-keyword">delete</span> shape_map[Circle];<br>            <span class="hljs-keyword">delete</span> color_map[Red];<br>            <span class="hljs-keyword">delete</span> color_map[Blue];<br>            <span class="hljs-keyword">delete</span> line_map[SolidLine];<br>            <span class="hljs-keyword">delete</span> line_map[DottedLine];<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeType shape_type, <span class="hljs-type">int</span> size, ColorType color_type, LineType line_type)</span> </span>&#123;<br>            shape_map[shape_type]-&gt;<span class="hljs-built_in">set_size</span>(size);<br>            shape_map[shape_type]-&gt;<span class="hljs-built_in">draw_shape</span>();<br>            color_map[color_type]-&gt;<span class="hljs-built_in">fill_color</span>();<br>            line_map[line_type]-&gt;<span class="hljs-built_in">draw_line</span>();<br>        &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        unordered_map&lt;ShapeType, Shape*&gt; shape_map;<br>        unordered_map&lt;ColorType, Color*&gt; color_map;<br>        unordered_map&lt;LineType, Line*&gt;  line_map;<br>    &#125;;<br><br>&#125; <span class="hljs-comment">// namespace facade</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//STRUCTURALPATTERNDESIGN_FACADE_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Facade.cpp</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/30.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Facade.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> facade &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_facade</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;——————————开始测试外观/门面模式——————————&quot;</span> &lt;&lt; endl;<br><br>        Painter p;<br>        p.<span class="hljs-built_in">draw</span>(Painter::Rectangle, <span class="hljs-number">2</span>, Painter::Red, Painter::SolidLine);<br>        p.<span class="hljs-built_in">draw</span>(Painter::Circle, <span class="hljs-number">3</span>, Painter::Blue, Painter::DottedLine);<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;——————————开始测试外观/门面模式——————————&quot;</span> &lt;&lt; endl;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-相关模式"><a href="#9-相关模式" class="headerlink" title="9. 相关模式"></a>9. 相关模式</h2><p>Abstract Factory 模式可以与Facade模式一起使用以提供一个接口，这一接口可用来以一种子系统独立的方式创建子系统对象。Abstract Factory也可以代替Facade模式隐藏那些与平台相关的类。</p><p>Mediator模式与Facade模式的相似之处是，它抽象了一些已有类的功能。然而，Mediator目的是对同事之间的任意通讯进行抽象，通常集中不属于任何单个对象的功能。Mediator的同事对象知道中介者并与它通信，而不是直接与其他同类对象通信。相对而言，Facade模式仅对子系统对象的接口进行抽象，从而使它们更容易使用；它并定义不功能，子系统也不知道facade的存在</p><p>一般来说，仅需要一个Facade对象，因此Facade对象通常属于Singleton对象。</p><h1 id="Proxy（代理）——对象结构模型"><a href="#Proxy（代理）——对象结构模型" class="headerlink" title="Proxy（代理）——对象结构模型"></a>Proxy（代理）——对象结构模型</h1><h2 id="1-意图-1"><a href="#1-意图-1" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>为其他对象提供一种代理以控制对这个对象的访问。</p><h2 id="2-动机-1"><a href="#2-动机-1" class="headerlink" title="2. 动机"></a>2. 动机</h2><p>对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行创建和初始化。</p><p>我们考虑一个可以在文档中嵌入图形对象的文档编辑器。有些图形对象的创建开销很大。但是打开文档必须很迅速，因此我们打开文档时应该避免一次性创建所有开销很大的对象。因为并非所有这些对象在文档中都同时可见，所以也没有必要同时创建这些对象。</p><p>这一限制条件意味着，对于每一个开销很大的对象，应该根据需要进行创建，当一个图形变为可见时会产生这样的需要。但是在文档中我们用什么来替代这个图像呢？我们又如何才能隐藏根据需要创建图像这一事实，从而不会使得编辑器的实现复杂化呢？例如，这种优化不应该影响绘制和格式化的代码。</p><p>问题的解决方案是使用另一个对象，即图像Proxy，替代那个真正的图像。Proxy可以代替一个图形对象，并且在需要时负责实例化这个图像对象。</p><p>只有当文档编辑器激活图像代理的Draw操作以显示这个图像的时候，图像Proxy才创建真正的图像。Proxy直接将随后的请求转发给这个图像对象。因此在创建这个图像以后，它必须有一个指向这个图像的引用。</p><h2 id="3-适用性-1"><a href="#3-适用性-1" class="headerlink" title="3. 适用性"></a>3. 适用性</h2><p>在需要比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一些可以使用Proxy模式的常见情况：</p><ul><li>远程代理（Remote Proxy）：为一个对象在不同的地址空间提供局部代表。</li><li>虚代理（Virtual Proxy）：根据需要创建开销很大的对象。在动机一节描述的ImageProxy就是这样一种代理的例子。</li><li>保护代理（Protection Proxy）：控制原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。</li><li>智能指针（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作，它的典型用途包括：<ul><li>对指向实际对象的引用技术，这样当对象没有引用时，可以自动释放它。</li><li>当第一次引用一个持久对象时，将它装入内存。</li><li>在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。</li></ul></li></ul><h2 id="4-结构-1"><a href="#4-结构-1" class="headerlink" title="4. 结构"></a>4. 结构</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204301546944.jpeg" alt="结构图"></p><p>下图则是运行时一种可能的代理结构的对象图。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204301546154.jpeg" alt="运行时对象图"></p><h2 id="5-参与者-1"><a href="#5-参与者-1" class="headerlink" title="5. 参与者"></a>5. 参与者</h2><ul><li>Proxy：<ul><li>保存一个引用使得代理可以访问实体。若RealSubject和Subject的接口相同，Proxy会引用Subject。</li><li>提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体</li><li>控制对实体的存取，并可能负责创建和删除它。</li><li>—— 其他功能依赖于代理的类型：<ul><li>Remote Proxy负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求</li><li>Virtual Proxy可以缓存实体的附加信息，以便延迟对它的访问。</li><li>Protection Proxy检查调用者是否具有实现一个请求所必需的访问权限。</li></ul></li></ul></li><li>Subject<ul><li>定义RealSubject 和 Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy</li></ul></li><li>RealSubject<ul><li>定义Proxy所代表的实体</li></ul></li></ul><h2 id="6-协作-1"><a href="#6-协作-1" class="headerlink" title="6. 协作"></a>6. 协作</h2><p>代理根据其种类，在适当的时候向RealSubject转发请求。</p><h2 id="7-效果-1"><a href="#7-效果-1" class="headerlink" title="7. 效果"></a>7. 效果</h2><p>Proxy模式在访问对象时引入一定程度的间接性。根据代理的类型，附加的间接性有多种用途：</p><ul><li>Remote Proxy可以隐藏一个对象存在于不同地址空间的事实上。</li><li>Virtual Proxy 可以进行最优化，例如根据要求创建对象。</li><li>Protection Proxy 和 Smart Reference 都允许在访问对象时有一些附加的内务处理。</li></ul><p>Proxy模式还可以对用户隐藏另一种被称为copy-on-write的优化方式， 该优化与根据需要创建对象有关。</p><h2 id="8-实现"><a href="#8-实现" class="headerlink" title="8. 实现"></a>8. 实现</h2><p>对于C++ 来说，可以重载C++ 中的存取运算符。 C++支持重载运算符 -&gt; 。重载这一运算法使你可以在撤销一个对象的引用时，执行一些附加的操作。这一点可以用于实现某些种类的代理，代理的作用就像是一个指针。</p><p>Proxy并不是总是需要知道实体的类型。若Proxy类能够完全通过一个抽象接口处理它的实体，则无须为每一个RealSubject类都生成一个Proxy类，Proxy类可以统一处理所有的RealSubject类。但是如果Proxy要实例化RealSubject（例如在虚代理中），那么他们必须要知道具体的类。</p><h2 id="9-示例代码"><a href="#9-示例代码" class="headerlink" title="9. 示例代码"></a>9. 示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Proxxy.h</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/30.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STRUCTURALPATTERNDESIGN_PROXXY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRUCTURALPATTERNDESIGN_PROXXY_H</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 模拟实现 Virtual Proxy</span><br><span class="hljs-comment"> * 我们考虑一个可以在文档中嵌入图形对象的文档编辑器。有些图形对象的创建开销很大。</span><br><span class="hljs-comment"> * 但是打开文档必须很迅速，因此我们打开文档时应该避免一次性创建所有开销很大的对象。</span><br><span class="hljs-comment"> * 因为并非所有这些对象在文档中都同时可见，所以也没有必要同时创建这些对象。</span><br><span class="hljs-comment"> * 只有当文档编辑器激活图像代理的Draw操作以显示这个图像的时候，图像Proxy才创建真正的图像。</span><br><span class="hljs-comment"> * Proxy直接将随后的请求转发给这个图像对象。因此在创建这个图像以后，它必须有一个指向这个图像的引用。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_proxy</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 图形显示相关接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graphic</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Image</span> : <span class="hljs-keyword">public</span> Graphic&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Image</span> (string file_name) &#123;<br>        <span class="hljs-comment">// 从磁盘加载文件</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;从磁盘加载文件：&quot;</span> &lt;&lt; file_name &lt;&lt; endl;<br>        data = <span class="hljs-string">&quot;^_^&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;绘制图片&quot;</span> &lt;&lt; data &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 图片的数据表示</span><br>    string data;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageProxy</span> : <span class="hljs-keyword">public</span> Graphic&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ImageProxy</span>(string file_name) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;file_name = file_name;<br>        image = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">get_image</span>()-&gt;<span class="hljs-built_in">draw</span>();<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function">Image* <span class="hljs-title">get_image</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (image == <span class="hljs-literal">nullptr</span>) &#123;<br>            image = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(file_name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    Image* image;<br>    string file_name;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextDocumnet</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Graphic* graphic)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;graphic = graphic;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 当浏览到图片当前所在页</span><br>        graphic-&gt;<span class="hljs-built_in">draw</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    Graphic* graphic;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//STRUCTURALPATTERNDESIGN_PROXXY_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Proxxy.cpp</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/30.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Proxy.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_proxy</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————开始测试代理模式——————————&quot;</span> &lt;&lt; endl;<br><br>    TextDocumnet doc;<br>    doc.<span class="hljs-built_in">insert</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ImageProxy</span>(<span class="hljs-string">&quot;an image&quot;</span>));<br>    <span class="hljs-comment">// doc 显示了一些别的东西</span><br>    <span class="hljs-comment">// doc 需要加载图片时</span><br>    doc.<span class="hljs-built_in">show</span>();<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————结束测试代理模式——————————&quot;</span> &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-相关模式"><a href="#10-相关模式" class="headerlink" title="10. 相关模式"></a>10. 相关模式</h2><p>Adapter：适配器为它所适配的对象提供了一个不同的接口。相反，代理提供了与它的实体相同的接口。然而，用于访问保护的代理可能会拒绝执行实体会执行的操作。因此，它的接口实际上可能只是实体接口的一个子集。</p><p>Decorator：尽管装饰的实现部分与代理相似，但装饰的目的不一样。装饰为对象添加一个或多个功能，而代理则控制对对象的访问。</p><p>代理的实现和装饰的实现类似，但在相似的程度上有所差别。Protection Proxy的实现可能与装饰的实现差不多。另外，Remote Proxy不包含对实体的直接引用，而只是一个间接引用，如“主机ID，主机上的局部地址”。Virtual Proxy开始的时候使用一个间接引用，例如一个文件名，但最终将获取并使用一个直接引用。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【STL源码分析】序列式容器之vector</title>
    <link href="/2022/04/26/2022-04/2022-04-26%20%E3%80%90STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/"/>
    <url>/2022/04/26/2022-04/2022-04-26%20%E3%80%90STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要内容参考：<a href="https://mp.weixin.qq.com/s/NcrnwsB2gjq9h7W2hIZ6PQ">2 万字+20 图带你手撕 STL 序列式容器源码</a>，原文内容非常详尽充实，建议大家阅读学习。而本文则是摘录总结关键部分，重点关注动态扩容的机制，以便日后快速回忆其实现逻辑。</p><h1 id="vector基本数据结构"><a href="#vector基本数据结构" class="headerlink" title="vector基本数据结构"></a>vector基本数据结构</h1><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204261522995.png" alt="vector 定义"></p><p>通过源码可以看到，vector代表着用户数据的一段空间，里面有三个重要的成员指针，分别指向所用空间的头部，所用空间的尾部，以及可用空间的尾部。并且，vector所用的迭代器就是普通指针。</p><h1 id="vector关键方法源码分析"><a href="#vector关键方法源码分析" class="headerlink" title="vector关键方法源码分析"></a>vector关键方法源码分析</h1><p>接下来对vector中一些关键方法进行源码分析。</p><h2 id="reserve"><a href="#reserve" class="headerlink" title="reserve"></a>reserve</h2><p><code>reserve</code>方法用于调整vector可用空间的大小，如果输入参数（要改变的大小）大于当前可用空间的容量，那么就会重新分配空间，再把原来的数据拷贝到新的空间上。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204261522613.png" alt="reserve源码"></p><h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p><code>resize</code>方法是改变vector已使用空间的大小，如果输入的参数小于当前的size，就会清除多余的元素（调用<code>erase</code>方法）；否则，就执行 insert 插入方法，而对 insert 来说，如果当前可用空间为0，那么就会执行扩容，也就是分配申请新的空间，把原来的数据拷贝到新的空间上，再执行插入操作。</p><p>因此对比 <code>reserve</code> 和 <code>resize</code> 方法，<code>reserve</code> 只可能改变vector可用空间的大小(capacity)，不会改变使用空间的大小(size)；而<code>resize</code>方法既可能改变使用空间的大小(size)，也可能改变可用空间的大小(capacity)。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204261523596.png" alt="resize源码"></p><h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h2><p><code>push_back</code> 将元素插入到vector的尾部，当vector目前还有可用空间时，就在对应的位置上执行元素的构造函数；如果没有可用空间，则调用<code>_M_insert_aux</code> 插入方法，在该方法里会执行动态扩容。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204261525188.png" alt="push_back源码"></p><p><code>_M_insert_aux</code> 方法源码如下所示，除了<code>push_back</code> 可能会调用，<code>insert</code> 方法也可能会调用，所以首先还是会先判断当前是否还有可用空间。</p><p>如果当前没有可用空间，就会申请分配新的空间大小，值得注意的是，<strong>如果原来的size为0，则新申请的空间大小为1，否则就会申请2倍原来的size</strong>。</p><p>然后执行拷贝移动，将先拷贝<code>_M_start</code>到<code>__position</code>位置的元素，然后再<code>__position</code>位置上赋值插入元素，最后再拷贝<code>__position</code>到<code>_M_finish</code>位置的元素。</p><p>说明一点，其中调用的<code>uninitialized_copy</code>函数的前缀uninitialized含义是对应迭代器的位置还没有初始化，需要调用相应构造函数。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204261526804.png" alt="_M_insert_aux 源码"></p><h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2><p><code>erase</code>函数用于清除某个位置上或者某一段区间上的元素，主要实现逻辑就是用后段元素覆盖删除区间内的元素。主要调用了 <code>copy(first, last, result)</code> 函数，其大致作用是把 [first,last) 数据拷贝到result（起始位置），从前往后拷贝。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204261526218.png" alt="erase源码"></p><p><code>erase</code>函数图解如下，可以帮助更好地理解。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204261527816.png" alt="erase函数图解"></p><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>insert函数有多个重载，这里重点分析其中一个，<code>void insert (iterator __pos, size_type __n, const _Tp&amp; __x)</code>，函数作用为从 pos 位置开始，插入 n 个元素，元素初值为 x，真正实现逻辑在<code>_M_fill_insert</code>函数中，源码如下所示。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204261528232.png" alt="insert源码"></p><p>通过源码，不难发现 vector 的插入多个元素，大体上可以分为3种情况：</p><ol><li>如果<strong>备用空间足够</strong>且插入点之后的现有元素个数 <strong>多于</strong> 新增元素个数；</li><li>如果<strong>备用空间足够</strong>且插入点之后的现有元素个数 <strong>少于</strong> 新增元素个数；</li><li>如果<strong>备用空间不够</strong>。</li></ol><p>下面就用三张图来描述这三种情况的执行逻辑：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204261529054.jpeg" alt="情况1 图解"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204261529421.jpeg" alt="情况2 图解"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204261530582.jpeg" alt="情况3 图解"></p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>在谈论vector时，经常会听到一个名词，就是所谓的<strong>迭代器失效问题</strong>。通过上述图解和分析我们就明白了，所谓的迭代器失效问题是由于元素空间重新配置导致之前的迭代器访问的元素不在了，总结来说有两种情况：</p><ul><li><p>由于插入元素，使得容器元素整体迁移导致存放原容器元素的空间不再有效，从而使得指向原空间的迭代器失效。</p><ul><li>这里元素迁移，既可能是指容器内元素的次序移动，也可能是由于指向了新的分配空间</li></ul></li><li><p>由于删除元素，使得某些元素次序发生变化导致原本指向某元素的迭代器不再指向期望指向的元素。</p></li></ul><hr><p>之前也谈到一些关键的函数，这里再记录说明一下：</p><ul><li><p><code>copy(first, last, result)</code>：将[first, last) 之间的元素拷贝到 [result , result + (last-first))位置</p><ul><li>该全局 <code>copy</code> 函数，底层会去调用 <code>memmove</code> ，而 <code>memmove</code>用于拷贝字节，如果目标区域和源区域有重叠的话，<code>memmove</code>能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。<ul><li>如果存在重叠区域的话，从实现角度来说，如果 first 在 result 之前，那么就从后往前拷贝，如果 first 在 result 之后，那么从前往后拷贝</li></ul></li><li>也就是说，即使 result 迭代器位置处于 first 和 last 之间，也能够正常实现功能，不会出现想象中迭代器值被覆盖的问题。</li></ul></li><li><p><code>uninitialized_copy(first, last, result)</code>：具体作用是将 [first,last)内的元素拷贝到[result , result + (last-first)) ，<strong>从前往后拷贝</strong></p></li><li><p><code>copy_backward(first, last, result)</code>：将 [first,last)内的元素拷贝到 [result , result + (last-first)) ，<strong>从后往前拷贝</strong></p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此 vector 容器就分析得差不多了，提醒需要注意的是：vector 的成员函数都不做边界检查 (但at方法会抛异常)，使用者要自己确保迭代器和索引值的合法性。</p><p>最后再总结下 vector 的优缺点：</p><ul><li><p><strong>优点</strong></p><ul><li><p>在内存中是分配一块连续的内存空间进行存储，可以像数组一样操作，并且支持动态扩容。</p></li><li><p>元素的随机访问方便，支持[ ]下标访问和 vector.at() 操作。</p></li><li><p>节省空间（对比其他容器使用空间而言）。</p></li></ul></li><li><p><strong>缺点</strong></p><ul><li>由于其顺序存储的特性，vector 插入删除操作的时间复杂度是 O(n)。</li><li>只能在末端进行 pop 和 push。</li><li>当动态长度超过默认分配大小后，要整体重新分配、拷贝和释放空间，开销较大。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【STL源码分析】迭代器</title>
    <link href="/2022/04/25/2022-04/2022-04-25%20%E3%80%90STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2022/04/25/2022-04/2022-04-25%20%E3%80%90STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在巩固C++基础时，学习了侯捷老师的《STL泛型编程》这一视频课程，当时也是边看边记录，但是记录得也比较松散，看完之后大概也就是有点印象，到现在基本上又想不起太多了。然后在网上看到了STL源码分析的相关文章，阅读学习之后大为收益。</p><p><strong>本文主要内容参考</strong>：<a href="https://mp.weixin.qq.com/s/srgj9KnxQrru_hMv-IVpWw">手撕 STL 迭代器源码与 traits 编程技法</a>，因为原文内容很充实，一些图画得很精妙，所以为了避免重复造轮子，也会直接引用其中的一些图片、文字，如果有造成侵权，请及时告知。</p><p>本文将摘录总结其中关键的知识点，以便日后复习时，可以帮助自己快速找到要点。而如果此前没有学习了解过STL组件的话，建议阅读学习原文。</p><h1 id="迭代器的作用描述"><a href="#迭代器的作用描述" class="headerlink" title="迭代器的作用描述"></a>迭代器的作用描述</h1><p>在设计模式中，关于 iterator 的描述如下：<strong>一种能够顺序访问容器中每个元素的方法，使用该方法不能暴露容器内部的表达方式。而类型萃取技术就是为了要解决和 iterator 有关的问题。</strong></p><p>那么在STL相关组件中，迭代器就是容器和算法之间的桥梁，算法通过迭代器来访问操作容器中的数据，如下图所示。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204251621412.png" alt="迭代器与容器和算法的交互"></p><h1 id="迭代器的设计实现思路"><a href="#迭代器的设计实现思路" class="headerlink" title="迭代器的设计实现思路"></a>迭代器的设计实现思路</h1><p>STL中的迭代器类似一种智能指针，拥有一般指针的特性——能够对其进行 <code>*</code>和 <code>-&gt;</code>操作。其设计思路如下图所示。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204251622504.png" alt="迭代器设计思路"></p><p>因为迭代器需要获取所指元素对应的类型，所以首先想到使用<strong>模板参数自动推导</strong>的方法。但是模板参数推导只能推导参数类型，无法推导函数的返回值类型。</p><p>所以想到用<strong>内嵌型别</strong>的方法，也就是在迭代器类（class）里面定义所指的元素类型（使用typedef），那么在需要的时候直接使用即可。</p><p>但是存在的一个<strong>隐晦的问题</strong>：实际上并不是所有的迭代器都是 <code>class type</code> ，原生指针也是一种迭代器，由于原生指针不是 <code>class type</code> ，所以没法为它定义内嵌型别。然后就有了<strong>模板偏特化</strong>的解决思路，具体实现上就是引入中间一层<strong>类型萃取traits</strong>，由该类模板来获取迭代器的元素类型，源码相关定义如下所示。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204251625530.png" alt="iterator_traits源码"></p><p class='note note-info'>如果不引入类型萃取traits的话，那么为了支持原生指针，每个跟迭代器有关的模板函数都需要实现对原生指针的模板偏特化，为了节省这一代码开销，所以需要引入中间层iterator_traits来获取迭代器元素类型。</p><p>最后总结一下，在STL中获取迭代器元素类型的过程如下图所示：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204251623075.png" alt="迭代器获取元素类型"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204251623099.png" alt="iterator_traits实现原理"></p><h1 id="迭代器里定义的类型"><a href="#迭代器里定义的类型" class="headerlink" title="迭代器里定义的类型"></a>迭代器里定义的类型</h1><p>一般迭代器里会定义五种类型：</p><ul><li><code>value_type</code>：迭代器所指对象的类型，原生指针也是一种迭代器，对于原生指针 int*，int 即为指针所指对象的类型，也就是所谓的 value_type 。</li><li><code>difference_type</code>：用来表示两个迭代器之间的距离，对于原生指针，STL 以 C++ 内建的 ptrdiff_t （是 long 类型的别名）作为原生指针的 difference_type。</li><li><code>reference_type</code>：是指迭代器所指对象的类型的引用，reference_type 一般用在迭代器的 * 运算符重载上，如果 value_type 是 T，那么对应的 reference_type 就是 T&amp;；如果 value_type 是 const T，那么对应的reference_type 就是 const T&amp;。</li><li><code>pointer_type</code>：就是相应的指针类型，对于指针来说，最常用的功能就是 operator* 和 operator-&gt; 两个运算符。</li><li><code>iterator_category</code>：的作用是标识迭代器的移动特性和可以对迭代器执行的操作，从 iterator_category 上，可将迭代器分为 Input Iterator、Output Iterator、Forward Iterator、Bidirectional Iterator、Random Access Iterator 五类，这样分可以尽可能地提高效率。</li></ul><p>下图是源码中定义的 <code>iterator</code>：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204251628089.png" alt="iterator源码定义"></p><h1 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h1><p>刚刚在迭代器的<code>iterator_category</code> 中也谈到了迭代器的分类，主要有五种：</p><ul><li><p><code>Input Iterator</code>：此迭代器不允许修改所指的对象，是<strong>只读</strong>的。支持 &#x3D;&#x3D;、!&#x3D;、++、* 、-&gt; 等操作。（*、-&gt; 返回类型具有const修饰）</p></li><li><p><code>Output Iterator</code>：允许算法在这种迭代器所形成的区间上进行<strong>只写</strong>操作。支持 ++、* 等操作。</p></li><li><p><code>Forward Iterator</code>：允许算法在这种迭代器所形成的区间上进行读写操作，但只能<strong>单向移动</strong>，每次只能移动一步。支持 Input Iterator 和 Output Iterator 的所有操作。</p></li><li><p><code>Bidirectional Iterator</code>：允许算法在这种迭代器所形成的区间上进行读写操作，可<strong>双向移动</strong>，每次只能移动一步。支持 Forward Iterator 的所有操作，并另外支持 – 操作。</p></li><li><p><code>Random Access Iterator</code>：包含指针的所有操作，可进行<strong>随机访问</strong>，随意移动指定的步数。支持前面四种 Iterator 的所有操作，并另外支持 [n] 操作符等操作。</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>根据参考文章：<a href="https://mp.weixin.qq.com/s/srgj9KnxQrru_hMv-IVpWw">手撕 STL 迭代器源码与 traits 编程技法</a>，梳理了STL组件中的迭代器关键知识点，最后再整理一下STL六大组件的交互关系：</p><p>container（容器） 通过 allocator（分配器） 取得数据储存空间，algorithm（算法）通过 iterator（迭代器）存取 container（容器） 内容，functor（仿函数） 可以协助 algorithm（算法） 完成不同的策略变化，adapter（适配器） 可以修饰或套接 functor（仿函数）。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【设计模式】适配器模式和桥接模式</title>
    <link href="/2022/04/24/2022-04/2022-04-24%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/24/2022-04/2022-04-24%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Adapter（适配器）——类对象结构型模式"><a href="#Adapter（适配器）——类对象结构型模式" class="headerlink" title="Adapter（适配器）——类对象结构型模式"></a>Adapter（适配器）——类对象结构型模式</h1><h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2. 别名"></a>2. 别名</h2><p>包装器(wrapper)</p><h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3. 动机"></a>3. 动机</h2><ul><li><p>有时，为复用而设计的工具箱类不能够被复用的原因仅仅是因为它的接口与专业应用领域所需要的接口不匹配（名称不一样，参数不一样等等）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Head First设计模式\]身边的设计模式--适配器模式](https://www.likecs.com/show-305350077.html)">[1]</span></a></sup></p></li><li><p>我们可以改变工具箱类使它兼容专业领域中的类的接口，但前提是必须有这个工具箱的源代码，然而 即使我们得到了这些源代码，修改工具箱也是没有什么意义的，因为不应该仅仅为了实现一个应用，工具箱就不得不采用一些与特定领域相关的接口。</p></li><li><p>我们可以不用上面的方法，而定义一个适配器类，由他来适配工具箱接口和专业应用的接口。我们可以用两种方法做这件事：</p><ul><li>继承专业应用类的接口和工具箱类的实现。这种方法对应Adapter模式的类版本（多继承）</li><li>将工具箱类的实现作为适配器类的组成部分，并且使用工具箱的接口实现适配器类。这种方法对应Adapter模式的对象版本。</li></ul></li></ul><h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4. 适用性"></a>4. 适用性</h2><p>以下情况使用Adapter模式：</p><ul><li>如果你想使用一个已经存在的类，而它的接口不符合你的需求</li><li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</li><li>（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配他们的接口。对象适配器可以适配它的父类接口。</li></ul><h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5. 结构"></a>5. 结构</h2><p>类适配器使用多重继承对一个接口与另一个接口进行匹配，如下图所示。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204241433783.jpeg" alt="类适配器示意图"></p><p>对象匹配器依赖于对象组合，如下图所示。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204241433025.jpeg" alt="对象适配器示意图"></p><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6. 参与者"></a>6. 参与者</h2><ul><li>Target<ul><li>定义Client使用的与特定领域相关的接口</li></ul></li><li>Client<ul><li>与符合Target接口的对象协同</li></ul></li><li>Adaptee<ul><li>定义一个已经存在的接口，与这个接口需要适配</li></ul></li><li>Adapter<ul><li>对Adaptee的接口与Target接口进行适配</li></ul></li></ul><h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7. 协作"></a>7. 协作</h2><p>Client在Adapter实例上调用一些操作。接着适配器调用Adaptee的操作实现这个请求。</p><h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8. 效果"></a>8. 效果</h2><p>类适配器和对象适配器有不同的权衡。类适配的权衡为：</p><ul><li>用一个具体的Adapter类对Adaptee和Target进行匹配。结果是当我们想要匹配一个类以及所有它的子类时，类Adapter将不能胜任工作。</li><li>使得Adapter可以重新定义Adaptee的部分行为，因为Adapter是Adaptee的一个子类。</li><li>仅仅引入一个对象，并不需要额外的指针以间接得到Adaptee。</li></ul><p>对象适配器的权衡为：</p><ul><li>允许一个Adater与多个Adaptee（即Adaptee本身以及它的所有子类（如果有子类的话）同时工作。Adapter也可以一次给所有的Adaptee添加功能。</li><li>使得重定义Adaptee的行为比较困难。这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。</li></ul><h2 id="9-示例代码"><a href="#9-示例代码" class="headerlink" title="9. 示例代码"></a>9. 示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Adapter.h</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/24.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CREATIONPATTERNDESIGN_ADAPTER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATIONPATTERNDESIGN_ADAPTER_H</span><br><br><span class="hljs-comment">// 使用现实生活的接口转接器的例子，来展示使用Adapter模式</span><br><span class="hljs-comment">// mac 上只有 typec接口，而外设键盘是USB接口，通过转换器将 USB接口转换为 typec接口输出</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_adapter</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// USB接口输出</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USB</span>  &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output_usb_data</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;USB接口 输出数据 ... &quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Typec 接口输出</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Typec</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">output_typec_data</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Typec接口 输出数据 ... &quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 接口转接器，将USB输出转换为 Typec输出</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> : <span class="hljs-keyword">public</span> Typec &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Adapter</span>(USB *usb) : <span class="hljs-built_in">usb</span>(usb) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">output_typec_data</span><span class="hljs-params">()</span> </span>&#123;<br>        usb-&gt;<span class="hljs-built_in">output_usb_data</span>();<br>        <span class="hljs-comment">// 进行转换处理工作</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;正在解析 usb 输出数据，进行转换...&quot;</span> &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;Typec接口 输出数据 ... &quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    USB* usb;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mac</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">input_typec</span><span class="hljs-params">(Typec * typec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (typec != <span class="hljs-literal">nullptr</span>) &#123;<br>            interface = typec;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Mac 开始工作...&quot;</span> &lt;&lt; endl;<br>        interface-&gt;<span class="hljs-built_in">output_typec_data</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    Typec *interface;<br>&#125;;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//CREATIONPATTERNDESIGN_ADAPTER_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Adapter.cpp</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/24.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Adapter.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_adapter</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————开始测试适配器模式——————————&quot;</span> &lt;&lt; endl;<br>    Mac mac;<br>    USB keyboard;<br>    <span class="hljs-function">Adapter <span class="hljs-title">adapter</span><span class="hljs-params">(&amp;keyboard)</span></span>;<br>    mac.<span class="hljs-built_in">input_typec</span>(&amp;adapter);<br>    mac.<span class="hljs-built_in">work</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————结束测试适配器模式——————————&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-相关模式"><a href="#10-相关模式" class="headerlink" title="10. 相关模式"></a>10. 相关模式</h2><p>模式Bridge的结果与对象适配器类似，但是Bridge模式的出发点不同：Bridge的目的是将接口部分和实现部分分离，从而可以对它们较为容易也相对独立地加以改变。而Adapter则意味着改变一个已有对象的接口。</p><p>Decorator模式增强了其他对象的功能而同时又不改变它的接口，因此Decorator对应用程序的透明性比适配器要好。结果是Decorator支持递归组合，而纯粹使用适配器是不可能实现这一点的。</p><p>模式Proxy在不改变它的接口的条件下，为另一个对象定义了一个代理。</p><h1 id="Bridge（桥接）——对象结构模型"><a href="#Bridge（桥接）——对象结构模型" class="headerlink" title="Bridge（桥接）——对象结构模型"></a>Bridge（桥接）——对象结构模型</h1><h2 id="1-意图-1"><a href="#1-意图-1" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>将抽象部分与它的实现部分分离，使它们可以独立地变化。</p><h2 id="2-别名-1"><a href="#2-别名-1" class="headerlink" title="2. 别名"></a>2. 别名</h2><p>Handle&#x2F;Body</p><h2 id="3-动机-1"><a href="#3-动机-1" class="headerlink" title="3. 动机"></a>3. 动机</h2><p>当一个抽象可能有多个实现时，通常用继承来协调它们。抽象类定义对该抽象的接口，而具体的子类则用不同方式加以实现。但是此方法有时不够灵活。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象部分和实现部分独立的进行修改、扩充和重用。桥接模式把依赖具体实现，提升为依赖抽象，来完成对象和变化因素之间的低耦合，提高系统的可维护性和扩展性。桥接模式的主要目的是将一个对象的变化与其它变化隔离开，让彼此之间的耦合度最低。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[C++设计模式--桥接模式_kmcfly的博客-CSDN博客](https://blog.csdn.net/u011244446/article/details/48680141)">[2]</span></a></sup></p><h2 id="4-适用性-1"><a href="#4-适用性-1" class="headerlink" title="4. 适用性"></a>4. 适用性</h2><p>以下情况下使用Bridge模式：</p><ul><li>你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如在程序运行时刻实现部分应可以被选择或者切换。</li><li>类的抽象以及它的实现都应该可以通过生成子类方法加以扩充。这时的桥接模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。</li><li>对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。</li><li>想对客户完全隐藏抽象的实现部分。</li><li>有许多类要生成，类的层次结构说明你必须得将一个对象分解成两个部分。</li><li>你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。</li></ul><h2 id="5-结构-1"><a href="#5-结构-1" class="headerlink" title="5. 结构"></a>5. 结构</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204241435913.jpeg" alt="结构图"></p><h2 id="6-参与者-1"><a href="#6-参与者-1" class="headerlink" title="6. 参与者"></a>6. 参与者</h2><ul><li>Abstraction<ul><li>定义抽象类的接口</li><li>维护一个指向Implementor类型对象的指针</li></ul></li><li>RefinedAbstraction<ul><li>扩充由Abstraction定义的接口</li></ul></li><li>Implementor<ul><li>定义实现类的接口，该接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同。一般来讲，Implementor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作</li></ul></li><li>ConcreteImplementor<ul><li>实现Implementor接口并定义它的具体实现</li></ul></li></ul><h2 id="7-协作-1"><a href="#7-协作-1" class="headerlink" title="7. 协作"></a>7. 协作</h2><p>Abstraction 将 client 的请求转发给它的 Implementor对象。</p><h2 id="8-效果-1"><a href="#8-效果-1" class="headerlink" title="8. 效果"></a>8. 效果</h2><p>Bridge模式有以下有点：</p><ul><li><p>分离接口及其实现部分</p><p>。一个实现未必不变地绑定在一个接口上。抽象类的实现可以在运行时进行配置，一个对象甚至可以在运行时改变它的实现。</p><ul><li>将Abstraction与Implementor分离有助于降低对实现部分编译时的依赖，当改变一个实现类时，并不需要重新编译Abstraction类和它的客户程序。为了保证一个类库的不同版本之间的二进制兼容性，一定要有这个性质。</li><li>另外，接口与实现分离有助于分层，从而产生更好的结构化系统，系统的高层部分仅需知道Abstraction和Implementor。</li></ul></li><li><p><strong>提高可扩充性</strong>。你可以独立地对Abstraction和Implementor层次结构进行扩充。</p></li><li><p><strong>实现细节对客户透明</strong>。你可以对客户隐藏实现细节，例如共享Implementor对象以及相应的引用计数机制（如果有的话）。</p></li></ul><h2 id="9-示例代码-1"><a href="#9-示例代码-1" class="headerlink" title="9. 示例代码"></a>9. 示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Bridge.h</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/24.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CREATIONPATTERNDESIGN_BRIDGE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATIONPATTERNDESIGN_BRIDGE_H</span><br><br><span class="hljs-comment">// 用图形 和 颜色 这一经典例子来演示 Bridge模式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_bridge</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fill_color</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Shape</span>(Color* color) : <span class="hljs-built_in">color</span>(color) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw_shape</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">protected</span>:<br>    Color* color;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">Rectangle</span>(Color* color) : <span class="hljs-built_in">Shape</span>(color) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw_shape</span><span class="hljs-params">()</span> </span>&#123;<br>        color-&gt;<span class="hljs-built_in">fill_color</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;绘制一个正方形&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(Color* color) : <span class="hljs-built_in">Shape</span>(color) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw_shape</span><span class="hljs-params">()</span> </span>&#123;<br>        color-&gt;<span class="hljs-built_in">fill_color</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;绘制一个圆形&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedColor</span> : <span class="hljs-keyword">public</span> Color &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fill_color</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;填充背景颜色：红色&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlueColor</span> : <span class="hljs-keyword">public</span> Color &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fill_color</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;填充背景颜色：蓝色&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//CREATIONPATTERNDESIGN_BRIDGE_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Bridge.cpp</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/24.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Bridge.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_bridge</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————开始测试桥接模式——————————&quot;</span> &lt;&lt; endl;<br>    Color * red = <span class="hljs-keyword">new</span> RedColor;<br>    Color * blue = <span class="hljs-keyword">new</span> BlueColor;<br>    Shape* red_rectangle = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rectangle</span>(red);<br>    red_rectangle-&gt;<span class="hljs-built_in">draw_shape</span>();<br>    Shape* blue_circle = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rectangle</span>(blue);<br>    blue_circle-&gt;<span class="hljs-built_in">draw_shape</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————结束测试桥接模式——————————&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-相关模式-1"><a href="#10-相关模式-1" class="headerlink" title="10. 相关模式"></a>10. 相关模式</h2><p>Abstract Factory 模式可以用来创建和配置一个特定的Bridge模式。</p><p>Adapter 模式用来帮助无关的类协同工作，它通常在系统设计完成后才会被使用。然而，Bridge模式则是在系统开始时就被使用，它使得抽象接口和实现部分可以独立进行改变。</p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.likecs.com/show-305350077.html">Head First设计模式]身边的设计模式–适配器模式</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/u011244446/article/details/48680141">C++设计模式–桥接模式_kmcfly的博客-CSDN博客</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【设计模式】生成器模式与单例模式</title>
    <link href="/2022/04/17/2022-04/2022-04-17%20%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/17/2022-04/2022-04-17%20%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Builder（生成器）——对象创建型模式"><a href="#Builder（生成器）——对象创建型模式" class="headerlink" title="Builder（生成器）——对象创建型模式"></a>Builder（生成器）——对象创建型模式</h1><h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以器创建不同的表示。</p><h2 id="2-动机"><a href="#2-动机" class="headerlink" title="2. 动机"></a>2. 动机</h2><p>面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成，由于需求变化，这个复杂对象的各个部分经常变化，但它们组合在一起的算法很稳定。</p><h2 id="3-适用性"><a href="#3-适用性" class="headerlink" title="3. 适用性"></a>3. 适用性</h2><p>在以下情况下使用Builder模式：</p><ul><li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时</li><li>当构造过程必须允许被构造的对象有不同的表示时</li></ul><h2 id="4-结构"><a href="#4-结构" class="headerlink" title="4. 结构"></a>4. 结构</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204171447075.jpeg" alt="结构示意图"></p><h2 id="5-参与者"><a href="#5-参与者" class="headerlink" title="5. 参与者"></a>5. 参与者</h2><ul><li>Builder<ul><li>为创建一个Product对象的各个部件指定抽象接口</li></ul></li><li>ConcreteBuilder<ul><li>实现Builder的接口以构造和装配该产品的各个部件</li><li>定义并跟踪它所创建的表示</li><li>提供一个检索产品的接口</li></ul></li><li>Director<ul><li>构造一个使用Builder接口的对象</li></ul></li><li>Product<ul><li>表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程</li><li>包含定义组成部件的类，包括将这些部件装配成最终产品的接口</li></ul></li></ul><h2 id="6-协作"><a href="#6-协作" class="headerlink" title="6. 协作"></a>6. 协作</h2><ul><li><p>客户创建Director对象，并用它所想要的Builder对象进行配置</p></li><li><p>一旦生成了产品部件，导向器就会通知生成器</p></li><li><p>生成器处理导向器的请求，并将部件添加到该产品中</p></li><li><p>客户从生成器中检索产品</p></li></ul><p>下面的交互图说明了Builder和Director是如何与一个客户协作的。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204171447454.jpeg" alt="交互图"></p><h2 id="7-效果"><a href="#7-效果" class="headerlink" title="7. 效果"></a>7. 效果</h2><ul><li><strong>它使你可以改变一个产品的内部表示</strong>。Builder对象提供给导向器一个构造产品的抽象接口。该接口使得生成器可以隐藏这个产品的表示和内部结构。它同时也隐藏了该产品是如何装配的。因为产品是通过抽象接口构造的，你在改变产品的内部表示时所要做的只是定义一个新的生成器。</li><li><strong>它将构造代码和表示分开</strong>。Builder模式通过封装一个复杂对象的创建和表示方式提高了对象的模块性。客户不需要知道定义产品内部结构的类的所有信息，这些类是不出现在Builder接口中的。</li><li><strong>它使你可对构造过程进行更精细的控制</strong>。Builder模式与一下子就生成产品的创建模式不同，它是在导向器的控制下一步一步构造产品的。</li></ul><h2 id="8-示例代码"><a href="#8-示例代码" class="headerlink" title="8. 示例代码"></a>8. 示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Builder.h</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/17.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CREATIONPATTERNDESIGN_BUILDER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATIONPATTERNDESIGN_BUILDER_H</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_builder</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 需要构造的产品，这里就是电脑，简化实现，把其中需要生产的零部件都用字符串表示</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Computer</span> &#123;<br>    string cpu;<br>    string memory;<br>    string mainboard;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_info</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt;<span class="hljs-string">&quot;CPU:&quot;</span> &lt;&lt; cpu &lt;&lt; <span class="hljs-string">&quot; memory:&quot;</span> &lt;&lt; memory &lt;&lt; <span class="hljs-string">&quot; mainboard:&quot;</span> &lt;&lt; mainboard &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Builder类，定义一系列生产零部件的接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComputerBuilder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_computer</span><span class="hljs-params">()</span> </span>&#123;<br>        computer = <span class="hljs-keyword">new</span> Computer;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_cpu</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_mainboard</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_memory</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Computer *<span class="hljs-title">get_computer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (computer != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> computer;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    Computer *computer;<br>&#125;;<br><br><span class="hljs-comment">// 具体的Builder类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComputerBuilderA</span> : <span class="hljs-keyword">public</span> ComputerBuilder &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_cpu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (computer != <span class="hljs-literal">nullptr</span>) &#123;<br>            computer-&gt;cpu = <span class="hljs-string">&quot;Intel&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_mainboard</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (computer != <span class="hljs-literal">nullptr</span>) &#123;<br>            computer-&gt;mainboard = <span class="hljs-string">&quot;微星&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_memory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (computer != <span class="hljs-literal">nullptr</span>) &#123;<br>            computer-&gt;memory = <span class="hljs-string">&quot;三星&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComputerBuilderB</span> : <span class="hljs-keyword">public</span> ComputerBuilder &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_cpu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (computer != <span class="hljs-literal">nullptr</span>) &#123;<br>            computer-&gt;cpu = <span class="hljs-string">&quot;AMD&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_mainboard</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (computer != <span class="hljs-literal">nullptr</span>) &#123;<br>            computer-&gt;mainboard = <span class="hljs-string">&quot;华硕&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_memory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (computer != <span class="hljs-literal">nullptr</span>) &#123;<br>            computer-&gt;memory = <span class="hljs-string">&quot;致钛&quot;</span>;<br>        &#125;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-comment">// Director类，即借助使用 Builder，来控制电脑生产</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-built_in">Factory</span>(ComputerBuilder* builder) : <span class="hljs-built_in">builder</span>(builder) &#123;&#125;<br>    <span class="hljs-function">Computer* <span class="hljs-title">make_computer</span><span class="hljs-params">()</span>  </span>&#123;<br>        builder-&gt;<span class="hljs-built_in">build_computer</span>();<br>        builder-&gt;<span class="hljs-built_in">build_cpu</span>();<br>        builder-&gt;<span class="hljs-built_in">build_mainboard</span>();<br>        builder-&gt;<span class="hljs-built_in">build_memory</span>();<br>        <span class="hljs-keyword">return</span> builder-&gt;<span class="hljs-built_in">get_computer</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    ComputerBuilder *builder;<br><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//CREATIONPATTERNDESIGN_BUILDER_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Builder.cpp</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/17.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Builder.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_builder</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————开始测试Builder模式——————————&quot;</span> &lt;&lt; endl;<br>    ComputerBuilder* cba = <span class="hljs-keyword">new</span> ComputerBuilderA;<br>    ComputerBuilder* cbb = <span class="hljs-keyword">new</span> ComputerBuilderB;<br>    <span class="hljs-function">Factory <span class="hljs-title">fa</span><span class="hljs-params">(cba)</span></span>;<br>    <span class="hljs-function">Factory <span class="hljs-title">fb</span><span class="hljs-params">(cbb)</span></span>;<br>    fa.<span class="hljs-built_in">make_computer</span>()-&gt;<span class="hljs-built_in">show_info</span>();<br>    fb.<span class="hljs-built_in">make_computer</span>()-&gt;<span class="hljs-built_in">show_info</span>();<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————结束测试Builder模式——————————&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-相关模式"><a href="#9-相关模式" class="headerlink" title="9. 相关模式"></a>9. 相关模式</h2><p>Abstract Factory与Builder相似，因为它也可以创建复杂对象。主要区别是Builder模式着重于一步步构造一个复杂对象。而Abstract Factory 着重于多个系列的产品对象（简单的或复杂的）。Builder在最后一步返回产品，而对于Abstract Factory 来说，产品是立即返回的。</p><p>Composite模式通常是用Builder生成的。</p><h1 id="Singleton（单例）——对象创建型模式"><a href="#Singleton（单例）——对象创建型模式" class="headerlink" title="Singleton（单例）——对象创建型模式"></a>Singleton（单例）——对象创建型模式</h1><h2 id="1-意图-1"><a href="#1-意图-1" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><h2 id="2-动机-1"><a href="#2-动机-1" class="headerlink" title="2. 动机"></a>2. 动机</h2><p>对于一些类来说，只有一个实例是很重要的。例如，虽然系统中可以有许多打印机，但却只应该有一个打印假脱机(printer spooler) ，只应该有一个文件系统和一个窗口管理器。一个会计系统只能专用于一个公司。</p><p>怎样才能保证一个类只有一个实例并且这个实例易于被访问呢？全局变量使得一个对象可以被访问，但它不能防止你实例化多个对象。</p><p>一个更好的办法是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的方法。这就是Singleton模式。</p><h2 id="3-适用性-1"><a href="#3-适用性-1" class="headerlink" title="3. 适用性"></a>3. 适用性</h2><p>在下面的情况下可以使用Singleton模式：</p><ul><li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</li><li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无序更改代码就能使用一个扩展的实例时。</li></ul><h2 id="4-结构-1"><a href="#4-结构-1" class="headerlink" title="4. 结构"></a>4. 结构</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204171449058.jpeg" alt="结构示意图"></p><h2 id="5-参与者-1"><a href="#5-参与者-1" class="headerlink" title="5. 参与者"></a>5. 参与者</h2><ul><li>Singleton<ul><li>定义一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作（可以是C++中的一个静态成员函数）</li><li>可能负责创建它自己的唯一实例</li></ul></li></ul><h2 id="6-协作-1"><a href="#6-协作-1" class="headerlink" title="6. 协作"></a>6. 协作</h2><ul><li>客户只能通过Singleton的Instance操作访问一个Singleton的实例</li></ul><h2 id="7-效果-1"><a href="#7-效果-1" class="headerlink" title="7. 效果"></a>7. 效果</h2><p>Singleton模式有许多优点：</p><ul><li><strong>对唯一实例的受控访问</strong>。因为Singleton类封装它的唯一实例，所以它可以严格地控制客户怎样以及何时访问它。</li><li><strong>缩小命名空间</strong>。Singleton模式是对全局变量的一种 改进，它避免了那些存储唯一实例的全局变量污染命名空间</li><li><strong>允许对操作和表示的精化</strong>。Singleton类可以有子类，而且用这个扩展类的实例来配置一个应用是很容易的。你可以用你所需要的类的实例在运行时配置应用</li><li><strong>允许可变数目的实例</strong>。这个模式使得你易于改变你的想法，并允许Singleton类的多个实例。</li></ul><h2 id="8-实现"><a href="#8-实现" class="headerlink" title="8. 实现"></a>8. 实现</h2><p>下面是使用Singleton模式时需要考虑的实现问题。</p><ul><li>保证一个唯一的实例。在C++中可以用Singleton类的静态成员函数Instance来定义这个类操作</li><li>Instance可以使用惰性（lazy）初始化，即只有第一次被访问时才创建实例</li><li>创建Singleton类的子类。最简单的技术是在Singleton的Instance操作中决定你想使用的是哪一个单例。另一个选择Singleton的子类的方法是将Instance的实现从父类中分离出来并将它放入子类。<ul><li>一个更灵活的方法是使用一个单例注册表（registry of singleton）。可能的Singleton类的集合不是由Instance定义的，Singleton类可以根据名字在一个众所周知的注册表中注册它们的单例实例。这个注册表可以在字符串名字和单例之间建立映射。当Instance需要一个单例时，它参考注册表，根据名字请求单例。</li></ul></li></ul><h2 id="9-示例代码"><a href="#9-示例代码" class="headerlink" title="9. 示例代码"></a>9. 示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Singleton.h</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/17.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CREATIONPATTERNDESIGN_SINGLETON_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATIONPATTERNDESIGN_SINGLETON_H</span><br><br><span class="hljs-comment">// 最简单的单例实现方式，使用局部静态变量，惰性分配（懒汉），并且在C++11之后能够保证线程安全</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">get_instance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> Singleton instance;<br>        <span class="hljs-keyword">return</span> &amp;instance;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp; singleton) = <span class="hljs-keyword">delete</span>;<br>    Singleton <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> Singleton&amp; singleton) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-comment">// 懒汉，双重检查锁</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton2</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton2* <span class="hljs-title">get_instance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123;<br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton2</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton2* instance;<br>    <span class="hljs-type">static</span> std::mutex mutex;<br><br>    <span class="hljs-comment">// 定义一个内部垃圾回收类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">GC</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        ~<span class="hljs-built_in">GC</span>() &#123;<br>            <span class="hljs-keyword">if</span>(Singleton2::instance != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">delete</span> Singleton2::instance;<br>                Singleton2::instance = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-type">static</span> GC gc;<br>&#125;;<br>Singleton2* Singleton2::instance = <span class="hljs-literal">nullptr</span>;<br>Singleton2::GC Singleton2::gc;<br>std::mutex Singleton2::mutex;<br><br><br><span class="hljs-comment">// 饿汉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton3</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton3* <span class="hljs-title">get_instance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> &amp;instance;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton3</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Singleton3</span>() &#123;&#125;<br>    <span class="hljs-built_in">Singleton3</span>(<span class="hljs-type">const</span> Singleton3&amp; singleton) = <span class="hljs-keyword">delete</span>;<br>    Singleton3 <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> Singleton3&amp; singleton) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">static</span> Singleton3 instance;<br>&#125;;<br>Singleton3 Singleton3::instance;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//CREATIONPATTERNDESIGN_SINGLETON_H</span></span><br><br></code></pre></td></tr></table></figure><h2 id="10-相关模式"><a href="#10-相关模式" class="headerlink" title="10. 相关模式"></a>10. 相关模式</h2><p>很多模式都可以用Singleton模式实现，比如Abstract Factory，Builder，Prototype。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++内存管理总结</title>
    <link href="/2022/04/16/2022-04-16%20C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <url>/2022/04/16/2022-04-16%20C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前看完学习了侯捷老师《内存管理》这门视频课程，为了加深印象以及日后回顾复习，特此做个总结。</p><p>本文会分成四部分内容：</p><ul><li>第一部分介绍C++ 内存管理中的 memory primitives（一些基本知识点），对应对应《内存管理》视频课程第一讲；</li><li>第二部分介绍SGI STL中分配器的实现，对应《内存管理》视频课程第二讲，并且主要内容将参考文章 <a href="https://mp.weixin.qq.com/s/1rLCzJtspYzAxa0g6-BFCA">5 千字长文+ 30 张图解 | 陪你手撕 STL 空间配置器源码</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[5 千字长文+ 30 张图解 | 陪你手撕 STL 空间配置器源码](https://mp.weixin.qq.com/s/1rLCzJtspYzAxa0g6-BFCA)">[1]</span></a></sup>；</li><li>第三部分介绍 VC6 malloc底层实现，对应《内存管理》课程内容第三讲；</li><li>第四部分介绍 Loki （<em>《Modern C++ Design》配套发行的一个 C++ 代码库</em>）中的内存管理实现，对应《内存管理》课程第四讲。</li></ul><blockquote><p>说明：文中会有不少图片和内容摘自课程课件或者参考文章，如果有造成侵权请告知删除。</p></blockquote><h1 id="Memory-Primitives（基本知识点）"><a href="#Memory-Primitives（基本知识点）" class="headerlink" title="Memory Primitives（基本知识点）"></a>Memory Primitives（基本知识点）</h1><h2 id="1-使用memory的途经"><a href="#1-使用memory的途经" class="headerlink" title="1.使用memory的途经"></a>1.使用memory的途经</h2><p>对于C++ 应用程序，使用memory的途经如下图所示，可以使用最上层的 C++ Library（比如STL中的allocator分配器），也可以直接使用C++ primitives（主要指new表达式，array new，operator new和对应的delete等），再往下就是 CRT（C语言运行库，包含malloc&#x2F;free的实现），最底层就是操作系统层面提供的API（图中给出的是Windows提供的API）。</p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102251849.png" alt="" style="zoom:50%;" /></center><hr><p>进一步的，自底向上可以将内存管理分为三个层次<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[C++性能优化（八）——内存分配机制](https://blog.51cto.com/quantfabric/2567655)">[2]</span></a></sup>：</p><ol><li><p>操作系统内核的内存管理</p><ul><li>例如虚存页式存储，地址映射等知识，可以参考 <a href="kingofdark.top/2022/06/11/2022-06/2022-06-11%20%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">操作系统之内存管理</a>。</li></ul></li><li><p>glibc层使用系统调用维护的内存管理算法</p><ul><li><p>这里的内存管理算法主要是指malloc的实现算法，例如Linux中采用的ptmalloc算法，其实现通过使用brk、sbrk、mmap等系统调用；而在Windows中，其malloc实现为，依据申请的空间大小，大空间调用os API（HeapAlloc()），小空间使用SBH(小于等于1K)，这也是后文 <a href="https://kingofdark.top/2022/04/16/2022-04-16%20C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/#vc6-malloc%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">VC6 malloc底层实现</a> 要具体介绍的内容。</p></li><li><p>注意这里的malloc只是分配一个虚拟地址，并没有分配实际物理地址，只有当用户使用内存时，操作系统内核才会分配具体的物理地址给用户使用<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[malloc背后的系统知识](https://wwwofai.com/article/18070)">[3]</span></a></sup>。</p></li></ul></li><li><p>应用程序从glibc动态分配内存后，根据应用程序本身的程序特性进行优化</p><ul><li><p>比如使用引用计数std::shared_ptr，内存池方式等等。</p></li><li><p>下一章节介绍的STL分配器就采用了内存池的方式， 就属于这一层次的内存管理。</p></li></ul></li></ol><h2 id="2-C-memory-primitives（内存相关的基本组件-原语）"><a href="#2-C-memory-primitives（内存相关的基本组件-原语）" class="headerlink" title="2.C++ memory primitives（内存相关的基本组件&#x2F;原语）"></a>2.C++ memory primitives（内存相关的基本组件&#x2F;原语）</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102251209.png" alt="C++内存管理基本原语"></p><h2 id="3-new-expression-与-delete-expression"><a href="#3-new-expression-与-delete-expression" class="headerlink" title="3.new expression 与 delete expression"></a>3.new expression 与 delete expression</h2><ul><li><p>new expression 的操作可以拆解为三步：第一步通过 <code>operator new</code>函数申请内存空间，第二步对返回的指针进行转型，第三步调用构造函数 。（如果简化的话，也可以认为是两步，第一步申请内存空间，第二步在申请到的内存空间上执行构造函数）</p><ul><li>在<code>operator new</code> 函数中，实际上会去调用<code>malloc</code>函数申请内存空间；<code>operator new</code>  的第二个参数，用于保证不抛出异常</li><li><code>_callnewh</code>：当malloc失败之后，就会调用用户设定的new handler函数（通过<code>set_new_handler</code>进行设置）。所以应该在new_handler函数中去尝试释放内存，以便下次进入循环时，malloc可以分配成功。</li></ul></li><li><p>delete expression 的操作也可以拆解为两步，第一步先是调用析构函数，第二步是释放对应的内存空间（实际上失去调用<code>free</code>函数）</p></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102251342.png" alt="new expression"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102252544.png" alt="delete expression"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102252302.png" alt="new handler机制"></p><h2 id="4-array-new-与-delete"><a href="#4-array-new-与-delete" class="headerlink" title="4.array new 与 delete[]"></a>4.array new 与 delete[]</h2><p>需要注意的是new [] 和 delete[] 应该配合使用。如下图给出的例子，<code>Demo</code>是一个包含三个<code>int</code>变量的类，<code>new Demo[3]</code> 的内存结构如右侧所示：</p><ul><li>最上方和最下方的 <code>61h</code> 表示的是cookie（malloc在申请内存会附加的信息，用来记录此次申请内存空间的大小，正是因为有这个cookie的信息，所以在调用free的时候才不需要传入“释放空间大小”这一参数）。 </li><li>中间橙色部分，表示的是在Debug调试模式下，malloc在申请时附加的一些数据信息（比如记录这是从哪个文件的哪一行发出的请求）；如果不是debug模式下，应该是不会包含这部分额外信息</li><li>下面的数字“3”就是记录此次分配数组元素的个数，用来指示应该调用多少次构造&#x2F;析构<ul><li>如果申请元素的类型没有 non-trivial dtor（重要的析构函数），双重否定句，也就是当元素类型的析构函数是trivial（不重要的）时候，就不会记录“3”，比如说申请的是 <code>int</code> 基本类型，该类型没有对应的析构函数，直接回收内存即可</li></ul></li><li>再下面每3个 <code>int</code> 组成一个 <code>Demo</code> 对象</li><li><code>no man land</code>：无人区，用于隔离数据，如果这一块内存被修改了，表示越界访问出错了</li><li><code>Pad</code>：这个是malloc申请内存时对齐需要填充的空间</li></ul><p>注意，new之后得到的<code>p</code>指向的地址上元素首地址0x00481c34，而<code>delete []p </code>传入p的地址指向的起始位置是“3”对应的地址0x00481c30，以便于知道需要析构多少次。因此如果不写[ ]，调用的是 <code>delete p</code> 就会在<strong>运行时报错，因为这样会按照没有“3”的情况去解读空间布局</strong>，而这就可能导致解析得到的要释放的内存地址和大小不正确。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102252390.png" alt="array new"></p><h2 id="5-placement-new"><a href="#5-placement-new" class="headerlink" title="5.placement new"></a>5.placement new</h2><p><code>placement new</code> 实际上没有分配内存，会去执行重载的<code>operator new(size_t, void*) </code>，只是把传进来的指针直接返回，所以相当于只是调用了构造函数。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102253169.png" alt="placement new"></p><p>注意，可以自己再重载operator new，引入更多的参数，比如下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;<br>    <span class="hljs-comment">// 类的其他一些变量或函数 ...</span><br>    <span class="hljs-comment">// 重载 operator new</span><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>, <span class="hljs-type">void</span>* p, <span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-comment">// do something...</span><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用形式</span><br><span class="hljs-type">char</span>* buf = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">sizeof</span>(Complex)*<span class="hljs-number">3</span>];<br>Complex* pc = <span class="hljs-built_in">new</span>(buf,<span class="hljs-number">3</span>) <span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);        <span class="hljs-comment">// new() 传入了两个参数</span><br></code></pre></td></tr></table></figure><h2 id="6-分配内存的途径"><a href="#6-分配内存的途径" class="headerlink" title="6.分配内存的途径"></a>6.分配内存的途径</h2><p>下面两张图分别展示了C++普通程序和STL容器里分配内存的途径：</p><ul><li><p>对于C++普通程序来说，最多还是使用 new expression 来动态分配内存，而 new expression 是不可改变的，不可重载的，会被编译器转换成去调用 <code>operator new</code></p><p> 和 <code>placement new</code> 两步</p><ul><li><p>如果该类自身有重载<code>operator new</code>函数，则会去调用重载的函数</p></li><li><p>如果类自身没有重载，就会去调用全局的 <code>operator new</code>函数，该全局函数的实现就是再去调用<code>malloc</code>函数。</p><ul><li>注意：全局的<code>operator new</code> 也是能够重载的，但是<strong>会影响全局的内存分配</strong>，因为所有没有重载<strong>类成员函数</strong><code>operator new</code>的类，都会调用该<strong>全局</strong><code>operator new</code>来分配内存。</li></ul></li></ul></li><li><p>对于C++ STL 容器来说，容器内元素的内存分配是通过分配器<code>allocator</code>来实现，<code>allocator</code>有多种实现方式，像是<code>new_allocator</code> 就是简单对全局<code>operator new</code> 进行封装，而<code>pool_alloc</code>则是采用了内存池管理的模式，这也是后文要重点介绍的内容。</p></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102253262.png"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102253759.png"></p><h1 id="STL之分配器"><a href="#STL之分配器" class="headerlink" title="STL之分配器"></a>STL之分配器</h1><p><a href="https://mp.weixin.qq.com/s/1rLCzJtspYzAxa0g6-BFCA">5 千字长文+ 30 张图解 | 陪你手撕 STL 空间配置器源码</a></p><p>原文其实已经介绍得很详细了，因此这里将配合《内存管理》视频课程对这这部分的讲解，对原文做一定的补充，凝练出最核心的部分。</p><blockquote><p>注意：参考的这篇文章是讲解SGI STL中分配器实现，而《内存管理》中介绍的是 G2.9 std::alloc的实现，但其实原理是类似的，标准库的实现也是参考了SGI STL的实现， G2.9 std::alloc 就对应于 SGI STL中的第二级分配器，都是运用内存池的思想。</p></blockquote><p>上文也有提到， new 和 delete 都包含两阶段操作：</p><ul><li>对于 <code>new</code> 来说，编译器会先调用 <code>::operator new</code> 分配内存；然后调用 <code>Obj::Obj()</code> 构造对象内容。</li><li>对于 <code>delete</code> 来说，编译器会先调用 <code>Obj::~Obj()</code> 析构对象；然后调用  <code>::operator delete</code> 释放空间。</li></ul><p>同样，STL allocator 也将这两个阶段操作区分开来：</p><ul><li>内存配置由 <code>alloc::allocate()</code> 负责；内存释放由 <code>alloc::deallocate()</code> 负责；</li><li>对象构造由 <code>::construct()</code> 负责；对象释放由 <code>::destroy()</code> 负责。</li></ul><p>SGI STL中定义的框架结构如下图所示（图片来源参考文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[5 千字长文+ 30 张图解 | 陪你手撕 STL 空间配置器源码](https://mp.weixin.qq.com/s/1rLCzJtspYzAxa0g6-BFCA)">[1]</span></a></sup>）。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102300626.png" alt="STL分配器相关头文件"></p><p>对象构造和析构之后的内存管理诸项事宜，由 &lt;stl_alloc.h&gt; 一律负责。SGI 对此的设计原则如下：</p><ul><li>向 system heap 要求空间</li><li>考虑多线程 (multi-threads) 状态</li><li>考虑内存不足时的应变措施</li><li>考虑过多“小型区块”可能造成的内存碎片 (fragment) 问题</li></ul><p>考虑到小型区块可能造成的内存破碎问题，SGI 为此设计了双层级配置器。当配置区块超过 128bytes 时，称为足够大，使用第一级配置器，直接使用 malloc() 和 free()。</p><p>当配置区块不大于 128bytes 时，为了降低额外负担，直接使用第二级配置器，采用复杂的 memory pool 处理方式。</p><p>无论使用第一级配接器（<code>__malloc_alloc_template</code>）或是第二级配接器（<code>__default_alloc_template</code>），alloc 都为其包装了接口，使其能够符合 STL 标准。</p><p>可以参考下图的说明（图片来源参考文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[5 千字长文+ 30 张图解 | 陪你手撕 STL 空间配置器源码](https://mp.weixin.qq.com/s/1rLCzJtspYzAxa0g6-BFCA)">[1]</span></a></sup>）。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102300137.png"></p><h2 id="alloc-第一级分配器"><a href="#alloc-第一级分配器" class="headerlink" title="alloc 第一级分配器"></a>alloc 第一级分配器</h2><p>（1）第一级配置器以 malloc(), free(), realloc() 等 C 函数执行实际的内存配置、释放和重配置操作，并实现类似 C++ new-handler 的机制（因为它并非使用 ::operator new 来配置内存，所以不能直接使用C++ new-handler 机制）。</p><p>（2）SGI 第一级配置器的 allocate() 和 reallocate() 都是在调用malloc() 和 realloc() 不成功后，改调用 oom_malloc() 和oom_realloc()。</p><p>（3）oom_malloc() 和 oom_realloc() 的实现跟C++ new_handler的实现是类似的，下图是实现源码，都是在不断循环调用“内存不足处理例程”，期望某次调用后，获得足够的内存而圆满完成任务，但如果用户并没有指定“内存不足处理程序”，这个时候便无力乏天，真的是没内存了，STL 便抛出异常，或调用exit(1) 终止程序。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102301185.png" alt="第一级分配器oom_alloc与oom_realloc源码"></p><p>下图则是<code>operator new</code>中的实现，可以看到new_handler机制的实现跟第一级分配器的实现是很相近的。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102302209.png" alt="operator new源码"></p><h2 id="alloc-第二级分配器"><a href="#alloc-第二级分配器" class="headerlink" title="alloc 第二级分配器"></a>alloc 第二级分配器</h2><p>首先来谈谈为什么划分出第二级分配器，并用复杂的内存池机制来进行管理。这是因为malloc实际分配的空间是大于申请的空间大小的，即会有cookie信息来记录此次分配的内存大小（用户对此无感知），正是因为携带了这份cookie信息，所以在free回收的时候才不需要显式传入需要回收的大小。</p><p>那么这就容易导致内存额外开销的问题，例如每次malloc我只需要申请4字节大小，但实际上却因为带有cookie信息，实际占用了12个字节（上下都记录4字节数据），显然空间利用率很低。因此才有了内存池的管理手段，一次分配大量的空间，然后再切割成一个个小份给用户使用，这样空间利用率就提高了。</p><hr><p>接下来谈谈内存池的运作模式，如下图所示。简单描述一下就是有16条空闲链表，每条链表负责分配以8字节为倍数的内存大小，例如下标为0负责8字节大小，下标为3的负责32字节大小。每条链表上挂着多个空闲区块，每个空闲区块用embeded pointer的方式连接起来（就是把空闲区块的前4个字节用来记录下一个空闲区块的位置，这样就避免申请额外的指针空间。进行内存区块的分配和回收，也就是对链表进行相应的操作，例如请求25~32字节大小的区块，就由下标为3的链表负责分配，拿出链表的第一个空闲区块给用户，空闲链表再指向下一个空闲区块；回收的时候，再挂到对应链表上，作为第一个空闲区块。<img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102303499.png" alt="std::alloc运行模式"></p><p>大致了解运行模式后，再来看看关键的数据结构：</p><ul><li><code>union _Obj</code>就是用来实现嵌入式指针，<code>_M_free_list_link</code>指向下一个空闲区块的地址，<code>_M_client_data</code>则表示当前<code>_Obj</code>的内存地址。</li><li><code>_S_free_list</code>就是需要维护的空闲链表</li><li><code>_S_start_free</code>和<code>_S_end_free</code>两个指针维护的是当前内存池的大小，但某条空闲链表上没有空闲区块的时候，就会从内存池中获取区块。而内存池的内存是通过malloc分配得到的。<code>_S_heap_size</code>变量维护的是当前已经累计申请的内存大小，用于malloc申请空间。</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102303912.png" alt="关键数据结构"></p><hr><p>继续深入，来看看核心函数的源码实现。内存分配主要由<code>allocate</code>函数负责，内存回收主要是<code>deallocate</code>函数负责。<code>deallocate</code>的实现比较简单，就是将回收的内存块根据其大小，放到对应的空闲链表上。所以这里将主要介绍<code>allocate</code>函数实现。</p><p>下面是<code>allocate</code>函数的源码，可以看到，如果申请的内存大小大于128字节，就会转去调用第一级分配器，也就是直接调用malloc。如果小于等于128字节，则根据其大小找到对应合适大小的空闲链表，如果对应空闲链表有空闲的内存块则可直接分配，如果没有，则调用<code>_S_refill</code>函数进行获取。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102303724.png" alt="第二级分配器allocate源码"></p><hr><p><code>_S_refill</code> 函数源码实现如下图，其中又主要调用<code>_S_chunk_alloc</code>来获取空闲内存块，默认会申请20块空闲区块，但如果只取得了一个，则直接返回给用户使用。如果返回的块数大于1，除了需要分配1块个用户使用，剩余的空闲区块要挂到管理对应大小的空闲链表上，在实现就利用了embedded pointer。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102304065.png" alt="第二级分配器_S_refill源码"></p><hr><p>最后来看<code>_S_chunk_alloc</code> 的源码实现，<strong>长图警告！</strong></p><p>依照代码逻辑来看，结构为3个if else：</p><ul><li>如果当前内存池剩余空间满足申请的空间大小，那么直接从内存池中进行分配，然后减小内存池大小（调整相应的指针）</li><li>如果当前内存池剩余空间不能够申请的空间大小，但是至少可以提供一个以上的区块，那么能够提供多少块就返回多少块，然后减小内存池大小</li><li>如果当前内存池剩余空间连一个区块的大小都无法提供，那么首先将当前内存池剩余空间分配给管理对应大小的空闲链表上，然后使用malloc申请大块空间。<ul><li>这里新申请的空间大小的计算特别注意一下，<code>size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; 4);</code> 是2倍原有的需求量再加上一个<code>_S_round_up</code>追加量，除了分配给用户的20个区块，剩余作为内存池容量，以供下次分配。可以推测是因为计算机在申请分配的所需的空间总是越要越大，为了加快分配就有了个追加量，而其中的数值可能是对应团队的经验值</li><li>如果malloc申请成功，那就递归的调用自身，再次分配，因此此时有足够的内存池大小了。</li><li>如果malloc分配失败了，表明当前系统已经没有多余的内存，那就从较大的空闲链表里分配一块作为内存池容量（从左往右找，找到最小能够满足分配的空闲区块大小），然后再递归调用自身进行分配。。</li><li>如果空闲链表里也没有能够分配的空闲区块，那么转去调用第一级分配器进行分配。第一级分配器还是回去调用malloc，而它malloc失败的话，会有oom_malloc() 处理机制，会尝试去解决内存不足的问题（例如释放一些内存），如果无法解决，那就真的山穷水尽，程序终止退出。</li></ul></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102304519.png" alt="第二级分配器_S_chunk_alloc源码"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在侯捷老师的视频课程中，还提到了两点：</p><ul><li>第二级分配器持有的内存池是越来越大的，并且在程序运行时不会归还给操作系统，也就是说如果高峰期分配了100MB内存，那么该内存池含有的空闲区块总和就一直是100MB，就算用户归还了，分配器还会一直持有以供下次分配，这就可能造成内存浪费的问题。那么为什么不为分配器设计内存归还的相关机制呢？<ul><li>这主要是因为<strong>实现难度极高</strong>，跟分配实现的机制相关，因为是以链表的形式连接空闲区块，当多次分配和归还之后，就很难找到相邻的内存块。并且链表的长度也不是固定的，在使用高峰期可能会变得很长。</li></ul></li><li>另一点是在<code>_S_chunk_alloc</code>函数实现中，当内存池大小不够，去使用malloc申请内存，而如果malloc申请内存失败了，就会去找其它较大空闲链表上的区块。这里有可能是因为申请的内存过大导致的，如果能够减小申请量，就可以进行分配了，例如当前需要的一块大小是8B，那么计算得到需要申请2 * 20 * 8&#x3D;320B（假设当前没有RoundUp追加量），而当前空闲内存只有200B，所以malloc分配失败，当如果我们申请160B 就能成功，仍然可以为用户提供空闲区块。那么，为什么不这么做呢？<ul><li>这主要是考虑到<strong>在多程序环境下，需要给其他程序预留内存</strong>。如果采用刚刚说的那种做法，相当于当前程序会最大程度的占用内存，那么留给其他程序的可用内存就变少了，就可能会给其他程序的运行造成麻烦。</li></ul></li></ul><p>最后再来一张SGI STL分配器进行内存分配的完整流程图，更多细节逻辑大家可以再去看源码，或者再看看提供的参考文章和侯捷老师的视频课程。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202205102305633.jpeg" alt="第二级分配器内存分配流程图"></p><h1 id="VC6-malloc底层实现"><a href="#VC6-malloc底层实现" class="headerlink" title="VC6 malloc底层实现"></a>VC6 malloc底层实现</h1><h1 id="Loki内存管理"><a href="#Loki内存管理" class="headerlink" title="Loki内存管理"></a>Loki内存管理</h1><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/1rLCzJtspYzAxa0g6-BFCA">5 千字长文+ 30 张图解 | 陪你手撕 STL 空间配置器源码</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.51cto.com/quantfabric/2567655">C++性能优化（八）——内存分配机制</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://wwwofai.com/article/18070">malloc背后的系统知识</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++踩坑记录之隐式类型转换</title>
    <link href="/2022/04/10/2022-04/2022-04-10%20C++%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%B9%8B%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/04/10/2022-04/2022-04-10%20C++%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%B9%8B%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>直接从问题引入吧，请问下面这段代码的输出是什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">string s = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>cout &lt;&lt; i - s.<span class="hljs-built_in">length</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204111248357.jpg" alt="" style="zoom:33%;" /></center><h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><p>如果你想当然地认为上面的输出是-4，那么显然你没有仔细地看过本文的标题（笑），要么就是你和我一样，火候还没有到家。那么输出结果到底是什么呢？见下图。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204101711581.png" alt="奇怪的输出结果"></p><p>什么！？居然输出的是18446744073709551613这么一个大数字，为什么？</p><p>其实这里包含了两个知识点，第一，就是<code>string</code>的<code>length()</code> 方法返回值类型是<code>unsigned long</code>，其实当你看到输出这么大的一个数字时，就不难猜想到跟unsigned long类型相关。第二，就是C++中的隐式类型转换，上述 <code>i - s.length()</code> 的计算过程中，<code> i</code> 是<code>int</code>类型，而 <code>s.length()</code> 是 <code>unsigned long</code> 类型，两者的类型不一致，所以会发生隐式类型转换，也就是把<code>int</code> 类型自动转换为 <code>unsigned long</code> 类型。</p><p><code>i</code> 转换为<code>unsigned long</code> 类型后，数值为1，而 <code>s.length()</code> 数值为5，因此相减会发生下溢，但因为是<code>unsigned long</code> 类型，所以输出一个大正整数。如果将结果转换成<code>long</code>类型，就可以看到预期输出的了。下面的代码和输出结果，可以帮助我们更好地理解这一过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 输出二进制表示</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> num)</span> </span>&#123;<br>    cout &lt;&lt;  <span class="hljs-string">&quot;binary:&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">63</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;<br>        cout &lt;&lt; ((num &gt;&gt; i ) &amp; <span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;i\t\t\t&quot;</span>;<br>    <span class="hljs-built_in">print</span>(i);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> u_i = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>&gt;(i);<br>    cout &lt;&lt; <span class="hljs-string">&quot;u_i\t\t\t&quot;</span>;<br>    <span class="hljs-built_in">print</span>(u_i);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;s.length()\t&quot;</span>;<br>    <span class="hljs-built_in">print</span>(s.<span class="hljs-built_in">length</span>());<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;i - s.length() : &quot;</span>;<br>    <span class="hljs-built_in">print</span>(i-s.<span class="hljs-built_in">length</span>());<br>    cout &lt;&lt; <span class="hljs-string">&quot;i - s.length() : &quot;</span> &lt;&lt; i - s.<span class="hljs-built_in">length</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204101737594.png" alt="输出结果"></p><p class='note note-info'>  <font size=3>    顺带一提，int 类型往 unsigned long 转换时，对于正数，高位补0，对于负数高位补1。  </font></p><hr><p>接下来我们再来看一个例子，看看下面这段代码，最终的 <code>id</code> 会输出什么？ </p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202309251928222.png"></p><p>这里也不卖关子了，最后会输出 -1，而不是预期的 INT64_MAX &#x2F; 2 的值。那么这里其实也是存在一个类型转换的问题，需要意识到字面量 1 ，它的类型实际上是 <code>int</code>，因此在 <code>MGet</code> 函数模板识别 Value 类型的时候会识别成 <code>int</code>，因此在函数返回时会做一次强制类型转换（<code>int64_t</code> 转换成 <code>int</code>，进行截断）， 然后再赋值给 <code>id</code> 时又做了一次隐式类型转换。那么第一次强制类型转换的结果，也就是函数返回值就是 -1，因为 INT64_MAX &#x2F; 2 低32位全是 1，向下转型成 <code>int</code> 后，对应的数值就是 -1，而 <code>int</code> 向上转型到 <code>int64_t</code>，高位补1，因此最终的数值还是表示 -1。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>最后小结一下，C++做为强类型语言，要求编译期的类型声明与检查，要求表达式中各操作数的类型（包括赋值操作的左值和右值，以及形参和实参）具有一致性，但同时也允许一定的灵活性，允许类型在一定程度上的兼容，也就是允许类型遵循一定规则下的隐式转换和强制转换<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[C++类型转换规则、何时发生隐式类型转换及强制类型转换适用场合](https://www.163.com/dy/article/GSUJ68H50552BFRV.html)">[3]</span></a></sup>。</p><p>一些常见发生隐式转换的时机有：</p><ul><li>在混合类型的表达式中，其操作数被转换为相同的类型。一般为低精度转高精度，就比如上面提到的 int 转 unsigned long。</li><li>用作条件的表达式被转换为 bool 类型。</li><li>用一表达式初始化某个变量，或将一表达式赋值给某个变量，则该表达式被转换为该变量的类型。</li><li>在函数调用中也可能发生隐式类型转换。</li></ul><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/luolaihua2018/article/details/111996610">C++类型转换：隐式转换和显式转换</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.cnblogs.com/apocelipes/p/14415033.html">彻底理解c++的隐式类型转换 </a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.163.com/dy/article/GSUJ68H50552BFRV.html">C++类型转换规则、何时发生隐式类型转换及强制类型转换适用场合</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
      <category>代码迷惑行为大赏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【设计模式】工厂方法和原型模式</title>
    <link href="/2022/04/09/2022-04/2022-04-09%20%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/09/2022-04/2022-04-09%20%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Factory-Method-工厂方法-——-对象创建型模式"><a href="#Factory-Method-工厂方法-——-对象创建型模式" class="headerlink" title="Factory Method 工厂方法 —— 对象创建型模式"></a>Factory Method 工厂方法 —— 对象创建型模式</h1><h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method是一个类的实例化延迟到其子类。</p><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2. 别名"></a>2. 别名</h2><p>虚构造器（virtual constructor）</p><h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3. 动机"></a>3. 动机</h2><p>考虑这样一个应用框架，它可以向用户显示多个文档。在这个框架中，两个主要的抽象是Application和Document。这两个类都是抽象的，客户必须通过他们的子类来做以应用相关的实现。例如，为创建一个绘图应用，我们定义类DrawingApplication和DrawingDocument。Application负责管理Document并根据需要创建他们——例如，用户从菜单中选择open或者new的时候。</p><p>因为被实例化的特定Document子类是与特定应用相关的，所以Application类不可能预测到哪一个Document子类将被实例化——Application仅仅知道一个新的文档被创建，而不知道哪一种Document被创建。这就产生了一个尴尬的局面：框架必须被实例化，但是他只知道不能被实例化的抽象类。</p><p>Factory Method 模式提供了一个解决方案。它封装了哪个Document子类将创建的信息并将这些信息从该框架中分离出来。如下图所示。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204091429416.jpeg" alt="Factory Method 解决方案"></p><h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4. 适用性"></a>4. 适用性</h2><p>在下列情况下可以使用Factory Method模式：</p><ul><li>当一个类不知道它所必须创建的对象的类的时候。</li><li>当一个类希望由它的子类来指定它所创建的对象的时候。</li><li>当类创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</li></ul><h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5. 结构"></a>5. 结构</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204091430163.jpeg" alt="Factory Method 结构图"></p><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6. 参与者"></a>6. 参与者</h2><ul><li>Product（Document）<ul><li>定义工厂方法所创建的对象的接口</li></ul></li><li>ConcreteProduct（MyDocument）<ul><li>实现Product接口</li></ul></li><li>Creator（Application）<ul><li>声明工厂方法，该方法返回一个Product类型的对象。Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象</li><li>可以调用工厂方法以创建一个Product对象</li></ul></li><li>ConcreteCreator（MyApplication）<ul><li>重定义工厂方法以返回一个ConcreteProduct实例。</li></ul></li></ul><h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7. 协作"></a>7. 协作</h2><p>Creator依赖于它的子类来定义工厂方法，所以它返回一个适当的ConcreteProduct实例。</p><h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8. 效果"></a>8. 效果</h2><p>工厂方法不再将与特定应用有关的类绑定到你的代码中。代码仅处理Product接口，因此他可以与用户定义的任何ConcreteProduct类一起使用。</p><p>工厂方法的一个潜在缺点在于，客户可能仅仅为了创建一个特定的ConcreteProduct对象，就不得不创建Creator的子类。当Creator子类不是必需的时候，客户现在必然要处理类演化的其他方面。</p><h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9. 实现"></a>9. 实现</h2><p>当应用Factory Method模式时要考虑下面一些问题：</p><p>1）主要有两种不同的情况。① Creator类是一个抽象类并且不提供它所声明的工厂方法的实现。② Creator是一个具体的类而且为工厂方法提供一个缺省的实现。</p><p>2）参数化工厂方法。该模式的另一种情况使得工厂方法可以创建多种产品。工厂方法采用一个参数来标识要被创建的对象种类。</p><p>3）特定语言的变化和问题。</p><p>4）使用模板以避免创建子类。工厂方法另一个潜在的问题是它们可能仅为了创建适当的Product对象而迫使你创建Creator子类。在C++中另一个解决办法是提供Creator的一个模板子类，他使用Product类作为模板参数。</p><p>5）命名约定。使用命名约定是一个好习惯，他可以清楚地说明你正在使用工厂方法。</p><h2 id="10-示例代码"><a href="#10-示例代码" class="headerlink" title="10. 示例代码"></a>10. 示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// FactoryMethod.h</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/9.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CREATIONPATTERNDESIGN_FACTORYMETHOD_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATIONPATTERNDESIGN_FACTORYMETHOD_H</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_factory_method</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 文档，抽象的一个产品类 Product ，提供默认实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Document</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Open</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_open</span>()) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;文档已经打开了！&quot;</span> &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            status = <span class="hljs-number">1</span>;<br>            cout &lt;&lt; <span class="hljs-string">&quot;打开该文档，现在可以编辑&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_open</span>()) &#123;<br>            status = <span class="hljs-number">0</span>;<br>            cout &lt;&lt; <span class="hljs-string">&quot;文档已关闭&quot;</span> &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;该文档没有被打开！&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Save</span><span class="hljs-params">(string text)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_open</span>()) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;没有打开该文档，无法保存!&quot;</span>  &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        prev_context.<span class="hljs-built_in">push</span>(cur_context);<br>        cur_context = text;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Revert</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_open</span>()) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;没有打开该文档，无法回退!&quot;</span>  &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!prev_context.<span class="hljs-built_in">empty</span>()) &#123;<br>            cur_context = prev_context.<span class="hljs-built_in">top</span>();<br>            prev_context.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_open</span>()) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;没有打开该文档，无法显示内容!&quot;</span>  &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;当前文档内容为：&quot;</span> &lt;&lt; cur_context &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 文档当前的状态 0表示关闭，1表示打开，2表示有修改</span><br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-comment">// 文档的当前内容</span><br>    string cur_context;<br>    <span class="hljs-comment">// 文档修改之前的内容</span><br>    stack&lt;string&gt; prev_context;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_open</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> status != <span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-comment">// 具体的产品类，对文档 Document的一个子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDocument</span> : <span class="hljs-keyword">public</span> Document &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_open</span>()) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;没有打开该文档，无法显示内容!&quot;</span>  &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;====文档字体是彩色的====&quot;</span> &lt;&lt; endl;<br>        Document::<span class="hljs-built_in">Show</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;==== EOF ====&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 工厂方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Document* <span class="hljs-title">CreateDocument</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">OpenDocument</span><span class="hljs-params">(Document* document)</span> </span>&#123;<br>        document-&gt;<span class="hljs-built_in">Open</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">CloseDocument</span><span class="hljs-params">(Document* document)</span> </span>&#123;<br>        document-&gt;<span class="hljs-built_in">Close</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 子类实现工厂方法，返回具体的Document</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> : <span class="hljs-keyword">public</span> Application &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Document* <span class="hljs-title">CreateDocument</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyDocument;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//CREATIONPATTERNDESIGN_FACTORYMETHOD_H</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// FactoryMethod.cpp</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/9.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FactoryMethod.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_factory_method</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————开始测试工厂方法模式——————————&quot;</span> &lt;&lt; endl;<br><br>    Application* application = <span class="hljs-keyword">new</span> MyApplication;<br>    Document* doc = application-&gt;<span class="hljs-built_in">CreateDocument</span>();<br>    doc-&gt;<span class="hljs-built_in">Show</span>();<br>    application-&gt;<span class="hljs-built_in">OpenDocument</span>(doc);<br>    doc-&gt;<span class="hljs-built_in">Save</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    doc-&gt;<span class="hljs-built_in">Show</span>();<br>    doc-&gt;<span class="hljs-built_in">Save</span>(<span class="hljs-string">&quot;say bye&quot;</span>);<br>    doc-&gt;<span class="hljs-built_in">Save</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    doc-&gt;<span class="hljs-built_in">Revert</span>();<br>    doc-&gt;<span class="hljs-built_in">Show</span>();<br>    application-&gt;<span class="hljs-built_in">CloseDocument</span>(doc);<br>    <span class="hljs-keyword">delete</span> doc;<br>    <span class="hljs-keyword">delete</span> application;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————结束测试工厂方法模式——————————&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-相关模式"><a href="#11-相关模式" class="headerlink" title="11. 相关模式"></a>11. 相关模式</h2><p>Abstract Factory经常用工厂方法来实现。</p><p>工厂方法通常在 Template Method中被调用。</p><p>Prototype不需要创建Creator的子类。但是它们通常要求一个针对Product类的Initialize操作。Creator使用Initialize来初始化对象，而Factory Method不需要这样的操作。</p><h1 id="Prototype-原型-——-对象创建型模式"><a href="#Prototype-原型-——-对象创建型模式" class="headerlink" title="Prototype 原型 —— 对象创建型模式"></a>Prototype 原型 —— 对象创建型模式</h1><h2 id="1-意图-1"><a href="#1-意图-1" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><h2 id="2-适用性"><a href="#2-适用性" class="headerlink" title="2. 适用性"></a>2. 适用性</h2><p>在以下情况下可以使用Prototype模式：</p><ul><li>当一个系统应该独立于它的产品创建、构成和表示时。</li><li>当要实例化的类是在运行时指定时，例如，通过动态装载。</li><li>为了避免创建一个与产品类层次平行的工厂类层次时</li><li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆他们可能比每次都用合适的状态手工实例化该类更方便一些。</li></ul><h2 id="3-结构"><a href="#3-结构" class="headerlink" title="3. 结构"></a>3. 结构</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204091432650.jpeg" alt="Prototype结构图"></p><h2 id="4-参与者"><a href="#4-参与者" class="headerlink" title="4. 参与者"></a>4. 参与者</h2><ul><li>Prototype<ul><li>声明一个克隆自身的接口</li></ul></li><li>ConcretePrototye<ul><li>实现一个克隆自身的操作</li></ul></li><li>Client<ul><li>让一个原型克隆自身而创建一个新的对象</li></ul></li></ul><h2 id="5-协作"><a href="#5-协作" class="headerlink" title="5. 协作"></a>5. 协作</h2><p>客户请求一个原型克隆自身</p><h2 id="6-效果"><a href="#6-效果" class="headerlink" title="6. 效果"></a>6. 效果</h2><p>Prototype 有许多与 Abstract Factory和Builder 一样的效果：它对客户隐藏了具体的产品类，因此减少了客户知道的名字和数目。此外，这些模式使客户无需改变即可使用与特定应用相关的类。</p><p>下面列出Prototype模式的另外一些优点：</p><p>1）<strong>运行时增加和删除产品</strong>。Prototype允许只通过客户注册原型实例就将一个新的具体产品类并入系统。它比其他创建型模式更为灵活，因为客户可以在运行时建立和删除原型。</p><p>2）<strong>改变值以指定新对象</strong>。高度动态的系统允许你通过对象组合定义新的行为——例如，通过为一个对象变量指定值——并且不定义新的类。你通过实例化已有类并且将这些实例注册为客户对象的原型，就可以有效定义新类别的对象。</p><p>3）<strong>改变结构以指定新对象</strong>。</p><p>4）<strong>减少子类的构造</strong>。</p><p>5）<strong>用类动态配置应用</strong>。一个希望动态载入类的实例的应用不能静态引用类的构造器，而应该由运行环境在载入时自动创建每个类的实例，并用原型管理器来注册这个实例。</p><p>Prototype的主要缺陷是每一个Prototype的子类都必须实现Clone操作，这可能很困难。</p><h2 id="7-实现"><a href="#7-实现" class="headerlink" title="7. 实现"></a>7. 实现</h2><p>当实现原型时，要考虑下面一些问题：</p><p>1）<strong>使用一个原型管理器</strong>。当一个系统中原型数目不固定时（也就说，他们可以动态创建和销毁），要保持一个可用原型的注册表。客户不会自己管理原型，但会在注册表中存储和检索原型。客户在克隆一个原型前会向注册表请求该原型。</p><p>2）实现克隆操作。Prototype模式最困难的部分在于正确实现Clone操作。当对象结构包含循环引用时，这尤为棘手。</p><p>3）初始化克隆对象。</p><h2 id="8-示例代码"><a href="#8-示例代码" class="headerlink" title="8. 示例代码"></a>8. 示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Prototype.h</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/9.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CREATIONPATTERNDESIGN_PROTOTYPE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATIONPATTERNDESIGN_PROTOTYPE_H</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_prototype</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 抽象的文具类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stationery</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;这是一个文具&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Stationery* <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pen</span> : <span class="hljs-keyword">public</span> Stationery&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;这是一只笔&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 这里就简单实现为浅拷贝</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Stationery* <span class="hljs-title">clone</span><span class="hljs-params">()</span>  </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Pen</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Eraser</span> : <span class="hljs-keyword">public</span> Stationery &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;这是一块橡皮擦&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Stationery* <span class="hljs-title">clone</span><span class="hljs-params">()</span>  </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Eraser</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StationeryFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StationeryFactory</span>(Stationery* stationery) : <span class="hljs-built_in">prototype</span>(stationery) &#123;<br><br>    &#125;<br>    <span class="hljs-function">Stationery* <span class="hljs-title">create_stationery</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> prototype-&gt;<span class="hljs-built_in">clone</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">StationeryFactory</span>()&#123;<br>        <span class="hljs-keyword">if</span> (prototype != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span> prototype;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 要生产文具的原型</span><br>    Stationery* prototype;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//CREATIONPATTERNDESIGN_PROTOTYPE_H</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Prototype.cpp</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/9.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Prototype.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_prototype</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————开始测试原型模式——————————&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-function">StationeryFactory <span class="hljs-title">pen_factory</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Pen)</span></span>;<br>    Stationery* pen1 = pen_factory.<span class="hljs-built_in">create_stationery</span>();<br>    Stationery* pen2 = pen_factory.<span class="hljs-built_in">create_stationery</span>();<br>    pen1-&gt;<span class="hljs-built_in">use</span>();<br>    pen2-&gt;<span class="hljs-built_in">use</span>();<br>    <span class="hljs-function">StationeryFactory <span class="hljs-title">eraser_factory</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Eraser)</span></span>;<br>    Stationery* eraser = eraser_factory.<span class="hljs-built_in">create_stationery</span>();<br>    eraser-&gt;<span class="hljs-built_in">use</span>();<br><br>    <span class="hljs-keyword">delete</span> pen1;<br>    <span class="hljs-keyword">delete</span> pen2;<br>    <span class="hljs-keyword">delete</span> eraser;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————结束测试原型模式——————————&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-相关模式"><a href="#9-相关模式" class="headerlink" title="9. 相关模式"></a>9. 相关模式</h2><p>Prototype和 Abstract Factory模式在某些方面是相互竞争的。但是他们也可以一起使用。Abstract Factory 可以存储一个被克隆的原型集合，并且返回产品对象。</p><p>大量使用 Composite 和 Decorator模式的设计也可以从Prototype模式获益。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奇怪的fork结果</title>
    <link href="/2022/04/02/2022-04/2022-04-02%20%E5%A5%87%E6%80%AA%E7%9A%84fork%E7%BB%93%E6%9E%9C/"/>
    <url>/2022/04/02/2022-04/2022-04-02%20%E5%A5%87%E6%80%AA%E7%9A%84fork%E7%BB%93%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在上操作系统的相关课程，恰好学到了fork函数。这么为了引入问题，简单测试一下，请问下面的代码会输出什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>     fork();<br>     fork();<br>     fork();<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204031058600.jpg"></p><h1 id="奇妙的过程"><a href="#奇妙的过程" class="headerlink" title="奇妙的过程"></a>奇妙的过程</h1><p>相信聪明的小伙伴，马上就能回答，“会输出8行 Hello World”。原因也很简单，因为每次执行完fork函数都会生成一个跟父进程一样的子进程，所以第一次执行完fork，总共有2个进程，第二次执行完fork就会有4个，第三次执行完就会有8个，所以最后每个进程都会输出一行Hello World。</p><p>接下来，我们稍微改变代码，变成下面这样子，那么这次输出结果会怎么样呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>     fork();<br>     fork();<br>     fork();<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这不也还是很简单吗，结果只是输出一行“Hello World”，因为打印操作在fork操作前，所以接下来的子进程都不会再执行打印输出的操作了。一开始我也是这么想的，但是VScode上的输出结果却令人大吃一惊，这怎么还是输出8行啊？</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204022126863.png" alt="VScode输出结果"></p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204031059494.jpg" alt="" style="zoom: 50%;" /></center></br><p>这真让人有些摸不着头脑，然后我又试了试在命令行下直接编译执行，发现这次得到的结果符合预期，这更加令人疑惑了。所以我又去试了试在Clion下执行这段代码，发现输出的结果也是符合预期的。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204022128750.png" alt="命令行下编译执行"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204022130779.png" alt="Clion执行结果"></p><p>那么在多方对比之下，只能是认为是VScode出了问题。当时我还认为是VScode里Code Runner这个插件的问题，所以在Stack Overflow上提问了<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[stackoverflow上 提问fork的奇怪输出结果](https://stackoverflow.com/questions/71691584/why-are-the-results-performed-using-code-runner-in-vscode-different-from-the-res)">[1]</span></a></sup>，随后得到了大牛的解答。</p><p>简单来说printf是有一个buffer的，也就是说并不是执行完printf语句，就会立即输出显示到终端屏幕（标准输出stdout）上，只有buffer满了，或者显示调用刷新，或是输入回车符 ‘\n’ ，才会立即将缓冲区的内容输出到屏幕上。</p><p>但是对于VScode来说，程序代码并不是直接运行在终端shell里的，标准输出stdout会绑定到IDE自身的一个GUI（图形用户界面）。此时，只有当缓冲区满了，或者是手动刷新缓冲区的时候，才会立刻输出到GUI界面上，也就是说缓冲区接收到了’\n’回车符也不会立即输出。下图是我的理解，可能不太准确，不过大体上这么解释能够说得通。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204031034635.jpeg" alt="个人图解（可能不太准确）"></p><p>因此就有了输出8行的奇怪形象，因为每个子进程都继承了缓冲区里的内容，直到最后程序退出时刷新缓冲区，因此最后每个程序都输出一行。</p><p>然后在尝试下添加<code>fflush</code>手动刷新缓冲区，输出果然变成了只有一行，验证了之前的想法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>     fflush(<span class="hljs-built_in">stdout</span>);<br>     fork();<br>     fork();<br>     fork();<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204031041593.png" alt="添加fflush后输出结果"></p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204031102883.jpg" alt="" style="zoom: 50%;" /></center><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>至此，有关fork之后奇怪的输出结果终于水落石出，其中涉及到的一个关键点就是printf或者说stdout是有缓冲区的，并不是执行完该函数语句就会立刻输出到屏幕上，这一个知识点其实以前也了解过，但是没有重视，或者说没有进一步了解底层实现，只知道个概念，所以真正遇到问题时，还是不能想到这一点。</p><p>所以还是要看源码啊，源码之前，了无秘密。但尴尬的是，我在IDE里想看对应库函数的源代码实现时，总是跳转不到对应的实现，只有一些声明，这就很尴尬。不知道有没有人跟我有类似的苦恼，正好等下次解决了，又可以水一篇博文了 :-)。</p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://stackoverflow.com/questions/71691584/why-are-the-results-performed-using-code-runner-in-vscode-different-from-the-res">stackoverflow上 提问fork的奇怪输出结果</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/LG1259156776/article/details/52935741">printf缓冲区小结</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>代码迷惑行为大赏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【设计模式】抽象工厂模式</title>
    <link href="/2022/04/02/2022-04/2022-04-02%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/02/2022-04/2022-04-02%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Abstract-Factory-抽象工厂——对象创建型模式"><a href="#Abstract-Factory-抽象工厂——对象创建型模式" class="headerlink" title="Abstract Factory 抽象工厂——对象创建型模式"></a>Abstract Factory 抽象工厂——对象创建型模式</h1><h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>提供一个接口以创建一系列相关或相互依赖的对象，而无需指定它们具体的类。</p><h2 id="2-动机"><a href="#2-动机" class="headerlink" title="2. 动机"></a>2. 动机</h2><p>考虑一个支持多种视感（look-and-feel）标准的用户界面工具包，不同的视感风格为诸如滚动条、窗口和按钮等用户界面“窗口组件”定义不同的外观和行为。为保证视感风格标准之间的可移植性，一个应用不应该为一个特定的视感外观硬编码它的窗口组件。在整个应用实例化特定视感风格的窗口组件类将使得以后很难改变视感风格。</p><p>为解决这一问题，我们可以定义一个抽象的WidgetFactory类，这个类声明了一个创建每一类基本窗口组件的接口。每一类窗口组件都有一个抽象类，而具体子类则实现了窗口组件的特定视感风格。</p><h2 id="3-适用性"><a href="#3-适用性" class="headerlink" title="3. 适用性"></a>3. 适用性</h2><p>在以下情况下使用Abstract Factory</p><ul><li>一个系统要独立于它的产品的创建、组合和表示。</li><li>一个系统要由多个产品系列中的一个来配置。</li><li>要强调一系列相关的产品对象的设计以便进行联合使用。</li><li>提供一个产品类库，但只想显示它们的接口而不是实现。</li></ul><h2 id="4-结构"><a href="#4-结构" class="headerlink" title="4. 结构"></a>4. 结构</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204021937446.jpeg" alt="UML类图示意"></p><h2 id="5-参与者"><a href="#5-参与者" class="headerlink" title="5. 参与者"></a>5. 参与者</h2><ul><li>AbstractFactory <ul><li>声明一个创建抽象产品对象的操作接口</li></ul></li><li>ConcreteFactory<ul><li>实现创建具体产品对象的操作</li></ul></li><li>AbstractProduct<ul><li>为一类产品对象声明一个接口</li></ul></li><li>ConcreteProduct<ul><li>定义一个将被相应的具体工厂创建的产品对象</li><li>实现AbstracProduct接口</li></ul></li><li>Client<ul><li>仅使用由AbstractFactory 和 AbstractProduct类声明的接口</li></ul></li></ul><h2 id="6-协作"><a href="#6-协作" class="headerlink" title="6. 协作"></a>6. 协作</h2><p>通常在运行时创建一个ConcreteFactory类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不同的具体工厂。</p><p>AbstractFactory将产品对象的创建延迟到它的ConcreteFactory子类。</p><h2 id="7-效果"><a href="#7-效果" class="headerlink" title="7. 效果"></a>7. 效果</h2><p>AbstractFactory模式有一下优点和缺点：</p><ul><li>优点：它分离了具体的类。</li><li>优点：它使得易于交换产品系列。一个具体工厂类在一个应用中仅出现一次——在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。</li><li>优点：它有利于产品的一致性。当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。</li><li>缺点：难以支持新种类的产品，也就是难以扩展抽象工厂以生产新种类的产品。这是因为AbstractFactory接口确定了可以被创建的产品集合。支持新种类的产品就需要扩展该工厂接口，这将涉及AbstractFactory类及其所有子类的改变。</li></ul><h2 id="8-示例代码"><a href="#8-示例代码" class="headerlink" title="8. 示例代码"></a>8. 示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// AbstractFactory.h</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/2.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CREATIONPATTERNDESIGN_ABSTRACTFACTORY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATIONPATTERNDESIGN_ABSTRACTFACTORY_H</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * @brief 定义一个生产组件的抽象工厂 WidgetFactory，派生出 Mac 和 Linux 两种风格的具体抽象工厂实现类；</span><br><span class="hljs-comment"> * 抽象的产品类对应有 Window 窗口组件和 ScrollBar 滚动条组件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_abstract_factory</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 抽象产品类，窗口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;这是一个普通窗口&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品类，对应于 Mac 风格系列</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MacWindow</span> : <span class="hljs-keyword">public</span> Window&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;这是一个 mac 风格的窗口&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品类，对应于 Linux 风格系列</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinuxWindow</span> : <span class="hljs-keyword">public</span> Window&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;这是一个 Linux 风格的窗口&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 抽象产品类，滚动条</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrollBar</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">scroll</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;这是一个普通滚动条&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MacScrollBar</span> : <span class="hljs-keyword">public</span> ScrollBar &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">scroll</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;这是 Mac 风格的滚动条&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinuxScrollBar</span> : <span class="hljs-keyword">public</span> ScrollBar &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">scroll</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;这是 Linux 风格的滚动条&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 抽象工厂类 AbstractFactory</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WidgetFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::shared_ptr&lt;ScrollBar&gt; <span class="hljs-title">create_scrollbar</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::shared_ptr&lt;Window&gt; <span class="hljs-title">create_window</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体工厂类，用于生产 Mac 风格系列的组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MacWidgetFactory</span> : <span class="hljs-keyword">public</span> WidgetFactory &#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::shared_ptr&lt;ScrollBar&gt; <span class="hljs-title">create_scrollbar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_shared</span>&lt;MacScrollBar&gt;();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::shared_ptr&lt;Window&gt; <span class="hljs-title">create_window</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_shared</span>&lt;MacWindow&gt;();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体工厂类，用于生产 Linux 风格系列的组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinuxWidgetFactory</span> : <span class="hljs-keyword">public</span> WidgetFactory &#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::shared_ptr&lt;ScrollBar&gt; <span class="hljs-title">create_scrollbar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_shared</span>&lt;LinuxScrollBar&gt;();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::shared_ptr&lt;Window&gt; <span class="hljs-title">create_window</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_shared</span>&lt;LinuxWindow&gt;();<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//CREATIONPATTERNDESIGN_ABSTRACTFACTORY_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// AbstractFactory.cpp</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/4/2.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;AbstractFactory.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_abstract_factory</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————开始测试抽象工厂模式——————————&quot;</span> &lt;&lt; endl;<br><br>    shared_ptr&lt;WidgetFactory&gt; wf = <span class="hljs-built_in">make_shared</span>&lt;MacWidgetFactory&gt;();<br>    shared_ptr&lt;ScrollBar&gt; sb = wf-&gt;<span class="hljs-built_in">create_scrollbar</span>();<br>    shared_ptr&lt;Window&gt; window = wf-&gt;<span class="hljs-built_in">create_window</span>();<br>    sb-&gt;<span class="hljs-built_in">scroll</span>();<br>    window-&gt;<span class="hljs-built_in">show</span>();<br><br>    wf = <span class="hljs-built_in">make_shared</span>&lt;LinuxWidgetFactory&gt;();<br>    sb = wf-&gt;<span class="hljs-built_in">create_scrollbar</span>();<br>    window = wf-&gt;<span class="hljs-built_in">create_window</span>();<br>    sb-&gt;<span class="hljs-built_in">scroll</span>();<br>    window-&gt;<span class="hljs-built_in">show</span>();<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————结束测试抽象工厂模式——————————&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-相关模式"><a href="#9-相关模式" class="headerlink" title="9. 相关模式"></a>9. 相关模式</h2><p>AbstractFactory类通常用工厂方法（Factory Method）来实现，但它们也可以用Prototype实现。</p><p>一个具体的工厂通常是一个单例（Singleton）。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【设计模式】享元模式与策略模式</title>
    <link href="/2022/03/26/2022-03/2022-03-26%20%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BA%AB%E5%85%83%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/26/2022-03/2022-03-26%20%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BA%AB%E5%85%83%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Flyweight（享元）模式"><a href="#Flyweight（享元）模式" class="headerlink" title="Flyweight（享元）模式"></a>Flyweight（享元）模式</h1><h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>运用共享技术有效地支持大量细粒度的对象</p><h2 id="2-动机"><a href="#2-动机" class="headerlink" title="2. 动机"></a>2. 动机</h2><p>Flyweight模式描述了如何共享对象，使得可以细粒度地使用它们而不需要高昂的代价。</p><p>Flyweight是一个共享对象，他可以同时在多个场景（context）中使用，并且在每个场景中flyweight都可以作为一个独立的对象——这一点与非共享对象的实例没有区别。flyweight不能对它所运行的场景做出任何假设，这里关键的概念是<strong>内部状态</strong>与<strong>外部状态</strong>之间的区别。内部状态存储于flyweight中，它包含了独立于flyweight场景的信息，这些信息使得flyweight可以被共享。而外部状态取决于flyweight场景，并根据场景而变化，因此不可共享。用户对象负责在必要的时候将外部状态传递给flyweight。</p><p>Flyweight模式对那些通常由于数量太大而难以用对象来表示的概念或实体进行建模。</p><h2 id="3-适用性"><a href="#3-适用性" class="headerlink" title="3. 适用性"></a>3. 适用性</h2><p>Flyweight模式的有效性很大程度上取决于如何使用它以及在何处使用它。当一下情况成立时，使用Flyweight模式：</p><ul><li>一个应用使用了大量的对象。</li><li>完全由于使用大量的对象造成很大的存储开销。</li><li>对象的大多数状态都可变为外部状态。</li><li>如果删除对象的外部状态，那么可以用相对较少的共享对象取代很对组对象</li><li>应用程序不依赖于对象标识。由于Flyweight对象可以被共享，因此概念上明显有别的对象，标识测试将返回真值。</li></ul><h2 id="4-结构"><a href="#4-结构" class="headerlink" title="4. 结构"></a>4. 结构</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203281441718.jpeg" alt="结构示意图"></p><p>下面对象图说明了如何共享flyweight</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203281441858.jpeg" alt="对象图"></p><h2 id="5-参与者"><a href="#5-参与者" class="headerlink" title="5. 参与者"></a>5. 参与者</h2><ul><li>Flyweight（Glyph）<ul><li>描述一个接口，通过这个接口flyweght可以接受并作用于外部状态</li></ul></li><li>ConcreteFlyweight（character）<ul><li>实现Flyweight接口，并为内部状态（如果有的话）增加存储空间。ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的。即它必须独立于ConcreteFlyweight 对象的场景。</li></ul></li><li>UnsharedConcreteFlyweight（Row、Column）<ul><li>并非所有的Flyweight子类都需要被共享。Flyweight接口使共享成为可能，但它并不强制共享。在flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点。</li></ul></li><li>FlyweightFactory<ul><li>创建并管理Flyweight对象</li><li>确保合理地共享Flyweight。当用户请求一个flyweight时，FlyweightFactory对象提供一个已创建的实例或创建一个（如果不存在的话）</li></ul></li><li>Client<ul><li>维持一个对Flyweight的引用</li><li>计算或存储一个（或多个）flyweight的外部状态</li></ul></li></ul><h2 id="6-协作"><a href="#6-协作" class="headerlink" title="6. 协作"></a>6. 协作</h2><ul><li>flyweight执行时所需的状态必定是内部的或外部的。内部状态存储于ConcreteFlyweight对象中，而外部状态则是由Client对象存储或计算。当用户调用flyweight对象的操作时，将该状态传递给它。</li><li>用户不应该直接对ConcreteFlyweight类进行实例化，而只能从FlyweightFactory对象得到ConcreteFlyweight对象。这可以保证对它们适当地进行共享。</li></ul><h2 id="7-实现"><a href="#7-实现" class="headerlink" title="7. 实现"></a>7. 实现</h2><p>在实现Flyweight模式时，应注意一下几点：</p><p>① 删除外部状态。该模式的可用性在很大程度上取决于是否容易识别外部状态并将它从共享对象中删除。</p><p>② 管理共享对象。 因为对象是共享的，用户不能直接对它进行实例化，所以FlyweightFactory来帮助用户查找某个特定的flyweight对象。共享还意味着某种形式的引用计数和垃圾回收，这样当一个flyweight不再使用时，可以回收它的存储空间。</p><h2 id="8-示例代码"><a href="#8-示例代码" class="headerlink" title="8. 示例代码"></a>8. 示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Flyweight.h</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/3/26.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BEHAVIORALPATTERNDESIGN_FLYWEIGHT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEHAVIORALPATTERNDESIGN_FLYWEIGHT_H</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_Flyweight</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 棋子状态，坐标</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ChessPoint</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-built_in">ChessPoint</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">ChessPoint</span>(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) : <span class="hljs-built_in">x</span>(x),<span class="hljs-built_in">y</span>(y) &#123;&#125;<br>    <span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + ::<span class="hljs-built_in">to_string</span>(x)+<span class="hljs-string">&quot;,&quot;</span> + ::<span class="hljs-built_in">to_string</span>(y)+<span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ChessPointHash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> ChessPoint&amp; point)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(point.x + <span class="hljs-number">10</span> * point.y);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ChessPointEqual</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> ChessPoint&amp; p1,<span class="hljs-type">const</span> ChessPoint&amp; p2 )</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (p1.x == p2.x &amp;&amp; p1.y == p2.y);<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">// 象棋棋子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chess</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Type</span> &#123;<br>        Red,<br>        Black,<br>        Board<br>    &#125;;<br>    <span class="hljs-built_in">Chess</span>(string name, Type type) :<span class="hljs-built_in">name</span>(name),<span class="hljs-built_in">type</span>(type) &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">move</span><span class="hljs-params">(ChessPoint start, ChessPoint end)</span> </span>&#123;<br>        <span class="hljs-comment">// 棋盘越界</span><br>        <span class="hljs-keyword">if</span> (start.x &lt; <span class="hljs-number">0</span> || start.y &lt; <span class="hljs-number">0</span> || start.x &gt;= <span class="hljs-number">9</span> || start.y &gt;= <span class="hljs-number">10</span> ||<br>            end.x &lt;<span class="hljs-number">0</span> || end.y &lt; <span class="hljs-number">0</span> || end.x &gt;= <span class="hljs-number">9</span> || end.y &gt;= <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">get_name</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function">Type <span class="hljs-title">get_type</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> type;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    string name;<br>    Type type;<br>&#125;;<br><br><span class="hljs-comment">// 兵</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Soldier</span> : <span class="hljs-keyword">public</span> Chess &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Soldier</span>(string name, Type type) : <span class="hljs-built_in">Chess</span>(name, type)  &#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">move</span><span class="hljs-params">(ChessPoint start, ChessPoint end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!Chess::<span class="hljs-built_in">move</span>(start,end)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ( (start.x == end.x &amp;&amp; start.y +<span class="hljs-number">1</span> == end.y) ||       <span class="hljs-comment">// 向上走</span><br>             (start.y == end.y &amp;&amp; (start.x+<span class="hljs-number">1</span> == end.x || start.x<span class="hljs-number">-1</span> == end.y)))&#123;      <span class="hljs-comment">// 左右走</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 车</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> : <span class="hljs-keyword">public</span> Chess &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">move</span><span class="hljs-params">(ChessPoint start, ChessPoint end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!Chess::<span class="hljs-built_in">move</span>(start,end)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 车 没有多余的限制</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 如果不提前创建的话，如何根据传入的name，动态创建对应的类（不用if else 进行判断）？</span><br>    <span class="hljs-built_in">ChessFactory</span>() &#123;<br>        red_chess[<span class="hljs-string">&quot;兵&quot;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Soldier</span>(<span class="hljs-string">&quot;兵&quot;</span>,Chess::Red);<br>        red_chess[<span class="hljs-string">&quot;车&quot;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Soldier</span>(<span class="hljs-string">&quot;车&quot;</span>,Chess::Red);<br>        black_chess[<span class="hljs-string">&quot;兵&quot;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Soldier</span>(<span class="hljs-string">&quot;兵&quot;</span>,Chess::Red);<br>        red_chess[<span class="hljs-string">&quot;车&quot;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Soldier</span>(<span class="hljs-string">&quot;车&quot;</span>,Chess::Red);<br>    &#125;<br><br>    <span class="hljs-function">Chess* <span class="hljs-title">create_chess</span><span class="hljs-params">(string name, Chess::Type type)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (type == Chess::Type::Red) &#123;<br>            <span class="hljs-keyword">return</span> red_chess[name];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> black_chess[name];<br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">ChessFactory</span>() &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter : red_chess) &#123;<br>            <span class="hljs-keyword">delete</span> iter.second;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter : black_chess) &#123;<br>            <span class="hljs-keyword">delete</span> iter.second;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;string, Chess*&gt; red_chess;<br>    unordered_map&lt;string, Chess*&gt; black_chess;<br>&#125;;<br><br><br><span class="hljs-comment">// 象棋棋盘，类比 UnsharedConcreteFlyweight</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessBoard</span> : <span class="hljs-keyword">public</span> Chess &#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-built_in">ChessBoard</span>(string name, Type type, ChessFactory&amp; factory) : <span class="hljs-built_in">Chess</span>(name, type) &#123;<br>        <span class="hljs-comment">// 简单地做下初始化</span><br>        <span class="hljs-function">ChessPoint <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)</span></span>;<br>        <span class="hljs-function">ChessPoint <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>)</span></span>;<br>        board[p1] = factory.<span class="hljs-built_in">create_chess</span>(<span class="hljs-string">&quot;兵&quot;</span>,Red);<br>        board[p2] = factory.<span class="hljs-built_in">create_chess</span>(<span class="hljs-string">&quot;车&quot;</span>,Red);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">move</span><span class="hljs-params">(ChessPoint start, ChessPoint end)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> start_iter = board.<span class="hljs-built_in">find</span>(start);<br>        <span class="hljs-keyword">if</span> (start_iter == board.<span class="hljs-built_in">end</span>()) &#123;        <span class="hljs-comment">// 起点没有棋子</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;起点没有棋子！&quot;</span> &lt;&lt;endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> end_iter = board.<span class="hljs-built_in">find</span>(end);<br>        <span class="hljs-keyword">if</span> (end_iter != board.<span class="hljs-built_in">end</span>() &amp;&amp;          <span class="hljs-comment">// 起点和终点的棋子颜色相同</span><br>            end_iter-&gt;second-&gt;<span class="hljs-built_in">get_type</span>() == start_iter-&gt;second-&gt;<span class="hljs-built_in">get_type</span>()) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;起点和终点的棋子颜色相同&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">bool</span> flag = start_iter-&gt;second-&gt;<span class="hljs-built_in">move</span>(start,end);<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            board[end] = start_iter-&gt;second;<br>            board.<span class="hljs-built_in">erase</span>(start_iter);<br>            cout &lt;&lt; <span class="hljs-string">&quot;棋子：&quot;</span> &lt;&lt; start_iter-&gt;second-&gt;<span class="hljs-built_in">get_name</span>() &lt;&lt;<br>                 <span class="hljs-string">&quot; 从&quot;</span> &lt;&lt; start.<span class="hljs-built_in">to_string</span>() &lt;&lt; <span class="hljs-string">&quot;到&quot;</span> &lt;&lt; end.<span class="hljs-built_in">to_string</span>() &lt;&lt;<span class="hljs-string">&quot; 移动成功&quot;</span> &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;棋子：&quot;</span> &lt;&lt; start_iter-&gt;second-&gt;<span class="hljs-built_in">get_name</span>() &lt;&lt;<br>             <span class="hljs-string">&quot; 从&quot;</span> &lt;&lt; start.<span class="hljs-built_in">to_string</span>() &lt;&lt; <span class="hljs-string">&quot;到&quot;</span> &lt;&lt; end.<span class="hljs-built_in">to_string</span>() &lt;&lt;<span class="hljs-string">&quot; 移动失败&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;ChessPoint, Chess*, ChessPointHash, ChessPointEqual&gt; board;<br><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//BEHAVIORALPATTERNDESIGN_FLYWEIGHT_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Flyweight.cpp</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/3/26.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Flyweight.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_Flyweight</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————开始测试 Flyweight 模式——————&quot;</span> &lt;&lt; endl;<br>    ChessFactory factory;<br>    <span class="hljs-function">ChessBoard <span class="hljs-title">board</span><span class="hljs-params">(<span class="hljs-string">&quot;棋盘&quot;</span>,Chess::Board, factory)</span></span>;<br>    <span class="hljs-function">ChessPoint <span class="hljs-title">start1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span>, <span class="hljs-title">start2</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)</span>,<span class="hljs-title">end1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>)</span>,<span class="hljs-title">end2</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)</span>, <span class="hljs-title">end3</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>)</span></span>;<br>    board.<span class="hljs-built_in">move</span>(start1,end1);<br>    board.<span class="hljs-built_in">move</span>(start2,end1);<br>    board.<span class="hljs-built_in">move</span>(start2,end2);<br>    board.<span class="hljs-built_in">move</span>(end2,end3);<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————结束测试 Flyweight 模式——————&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; endl ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-相关模式"><a href="#9-相关模式" class="headerlink" title="9. 相关模式"></a>9. 相关模式</h2><p>Flyweight模式通常和Composite（组合）模式结合起来，用共享叶节点的有向无环图实现一个逻辑上的层次结构。</p><p>通常，最好用flyweight实现State和Strategy对象。</p><h1 id="Strategy（策略）模式"><a href="#Strategy（策略）模式" class="headerlink" title="Strategy（策略）模式"></a>Strategy（策略）模式</h1><h2 id="1-意图-1"><a href="#1-意图-1" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。本模式使得算法可独立于使用它的客户而变化</p><h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2. 别名"></a>2. 别名</h2><p>政策（policy）</p><h2 id="3-适用性-1"><a href="#3-适用性-1" class="headerlink" title="3. 适用性"></a>3. 适用性</h2><p>在以下情况下使用Strategy模式：</p><ul><li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。</li><li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间&#x2F;时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。</li><li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</li></ul><h2 id="4-结构-1"><a href="#4-结构-1" class="headerlink" title="4. 结构"></a>4. 结构</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203281444593.jpeg" alt="结构示意图"></p><h2 id="5-参与者-1"><a href="#5-参与者-1" class="headerlink" title="5. 参与者"></a>5. 参与者</h2><ul><li>Strategy（策略，如Compositor）<ul><li>定义所支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法</li></ul></li><li>ConcreteStrategy（具体策略，如SimpleCompositor、TeXCompositor、ArrayCompositor）<ul><li>以Strategy接口实现具体算法</li></ul></li><li>Context（上下文，如Composition）<ul><li>用一个ConcreteStrategy对象来配置</li><li>维护一个Strategy对象的引用</li><li>可定义一个接口来让Strategy访问它的数据</li></ul></li></ul><h2 id="6-协作-1"><a href="#6-协作-1" class="headerlink" title="6. 协作"></a>6. 协作</h2><ul><li>Strategy和Context相互作用以实现选定的算法。当算法被调用时，Context可以将该算法所需要的所有数据都传递给该Strategy。或者，Context可以将自身作为一个参数传递给Strategy操作。这就让Strategy在需要时可以回调Context</li><li>Context将客户的请求转发给它的Strategy。客户通常创建并传递一个ConcreteStrategy对象给该Context，这样客户仅与Context交互。通常有一系列Strategy类可供客户从中选择。</li></ul><h2 id="7-实现-1"><a href="#7-实现-1" class="headerlink" title="7. 实现"></a>7. 实现</h2><p>考虑下面的实现问题：</p><ol><li>定义Strategy和Context接口。</li></ol><ul><li>Strategy和Context接口必须使得ConcreteStrategy能够有效地访问它所需要的context中的任何数据，反之亦然。一种方法是让Context将数据放在参数中传递给Strategy，这使得Strategy和Context解耦，但Context也可能发送一些Strategy不需要的数据。</li><li>另一种方法是让Context将自身作为一个参数传递给Strategy，该Strategy再显式地想Context请求数据。或者Strategy可以存储对它的Context的引用。</li></ul><ol start="2"><li>将Strategy作为模板参数</li></ol><ul><li>在C++中，可利用模板机制用一个Strategy来配置一个类。然而这种方法仅当满足下面条件时才能使用：① 可以在编译时选择Strategy；② 不需要在运行时改变。在这种情况下，要被配置的类（如Context）被定义为一个以Strategy类作为参数的模板类。</li></ul><ol start="3"><li>使Strategy对象成为可选的</li></ol><ul><li>即使在不使用额外的Strategy对象的情况下，Context也有意义的话，那么它还可以被简化。Context在访问某Strategy前先检查它是否存在。如果有，就使用它；如果没有，那么Context执行缺省的行为。这种方法的好处是客户根本不需要处理Strategy对象，除非不喜欢缺省的行为。</li></ul><h2 id="8-示例代码-1"><a href="#8-示例代码-1" class="headerlink" title="8. 示例代码"></a>8. 示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Strategy.h</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/3/26.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BEHAVIORALPATTERNDESIGN_STRATEGY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEHAVIORALPATTERNDESIGN_STRATEGY_H</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 策略模式，模拟两个实现</span><br><span class="hljs-comment"> * 1. 定义Strategy和Context接口，模拟场景为 输入框字符串的验证策略</span><br><span class="hljs-comment"> * 2. 将Strategy作为模板参数，可以参考STL中分配器，其中就运用了策略模式</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_strategy</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 校验器，对应于 Strategy 类，对字符串进行校验</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Validator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">validate</span><span class="hljs-params">(string text)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (text.<span class="hljs-built_in">empty</span>()) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;文本为空！&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">Validator</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-comment">// 输入框 对应Context类，需要对输入的字符串进行校验，在不同场景下需要不同的验证策略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InputText</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">InputText</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_validator</span><span class="hljs-params">(shared_ptr&lt;Validator&gt; validator)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;validator = validator;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">input_text</span><span class="hljs-params">(string input)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (validator-&gt;<span class="hljs-built_in">validate</span>(input)) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;输入：&quot;</span>&lt;&lt; input &lt;&lt;<span class="hljs-string">&quot;\t校验成功！&quot;</span> &lt;&lt; endl;<br>            text = input;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;输入：&quot;</span>&lt;&lt; input &lt;&lt;<span class="hljs-string">&quot;\t校验失败，请重新输入！&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">get_text</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> text;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    string text;<br>    std::shared_ptr&lt;Validator&gt; validator;<br>&#125;;<br><br><span class="hljs-comment">// 数字校验器，校验策略为输入的必须是数字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DigitValidator</span> : <span class="hljs-keyword">public</span> Validator&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">validate</span><span class="hljs-params">(string text)</span> </span>&#123;<br>        <span class="hljs-type">bool</span> flag = Validator::<span class="hljs-built_in">validate</span>(text);<br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : text) &#123;<br>            <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 字母校验器，校验策略为输入的必须是字母</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterValidator</span> : <span class="hljs-keyword">public</span> Validator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">validate</span><span class="hljs-params">(string text)</span> </span>&#123;<br>        <span class="hljs-type">bool</span> flag = Validator::<span class="hljs-built_in">validate</span>(text);<br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : text) &#123;<br>            <span class="hljs-keyword">if</span> (!( (c &gt;=<span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>) || (c&gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">// 然后模拟将Strategy作为模板参数，类比STL容器和分配器的关系，做一个简单地示意</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">allocate</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Allocator</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-comment">// 类比策略类，实现简单内存分批额策略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleAllocator</span> : <span class="hljs-keyword">public</span> Allocator&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">allocate</span><span class="hljs-params">()</span>  </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;实现简单内存分配策略&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 类比策略类，实现内存池分配策略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PoolAllocator</span> : <span class="hljs-keyword">public</span> Allocator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">allocate</span><span class="hljs-params">()</span>  </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;实现内存池分配策略&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T val)</span> </span>&#123;<br>        allocator.<span class="hljs-built_in">allocate</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;加入元素： &quot;</span> &lt;&lt; val &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    Allocator allocator;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//BEHAVIORALPATTERNDESIGN_STRATEGY_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Strategy.cpp</span><br><span class="hljs-comment">// Created by 张宇轩 on 2022/3/26.</span><br><span class="hljs-comment">// Copyright (c) 2022 zhangyuxuan. All rights reserved.</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Strategy.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_strategy</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————开始测试 Strategy 模式——————&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 定义接口</span><br>    InputText it;<br>    it.<span class="hljs-built_in">set_validator</span>(<span class="hljs-built_in">make_shared</span>&lt;DigitValidator&gt;());<br>    it.<span class="hljs-built_in">input_text</span>(<span class="hljs-string">&quot;1aaaa&quot;</span>);<br>    it.<span class="hljs-built_in">set_validator</span>(<span class="hljs-built_in">make_shared</span>&lt;CharacterValidator&gt;());<br>    it.<span class="hljs-built_in">input_text</span>(<span class="hljs-string">&quot;aaaa&quot;</span>);<br><br>    <span class="hljs-comment">// 使用模板参数</span><br>    Container&lt;<span class="hljs-type">int</span>,SimpleAllocator&gt; container;<br>    container.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    Container&lt;<span class="hljs-type">int</span>,PoolAllocator&gt; container2;<br>    container2.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————结束测试 Strategy 模式——————&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-相关模式-1"><a href="#9-相关模式-1" class="headerlink" title="9. 相关模式"></a>9. 相关模式</h2><p>Flyweight：Strategy对象通常是很好的轻量级对象</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【设计模式】组合模式与装饰模式</title>
    <link href="/2022/03/20/2022-03/2022-03-20%20%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/20/2022-03/2022-03-20%20%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Composite组合-——-对象结构型模式"><a href="#Composite组合-——-对象结构型模式" class="headerlink" title="Composite组合 —— 对象结构型模式"></a>Composite组合 —— 对象结构型模式</h1><ol><li>意图</li></ol><p>将对象组合成树形结构以表示“部分——整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。</p><ol start="2"><li>使用性</li></ol><ul><li>你想表示对象的部分 - 整体层次结构</li><li>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有独享</li></ul><ol start="3"><li>结构<br><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203202023130.jpeg" alt="类图设计"></li></ol><p>典型结构如下：<br><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203202024231.jpeg" alt="典型结构"></p><ol start="4"><li>参与者</li></ol><ul><li>Component（Graphic)<ul><li>为组合中的对象声明接口</li><li>在适当情况下，实现所有类共有接口的缺省行为</li><li>声明一个接口用于访问和管理Component的子组件</li><li>（可选）在递归结构中定义一个接口，用于访问一个父组件，并在合适情况下实现它</li></ul></li><li>Leaf（Rectangle，Line，Text等）<ul><li>在组合中表示叶节点对象，叶节点没有子节点</li><li>在组合中定义图元对象的行为</li></ul></li><li>Composite（Picture）<ul><li>定义有子部件的那些部件的行为</li><li>存储子部件</li><li>在Component接口中实现与子部件有关的操作</li></ul></li><li>Cilent<ul><li>通过Component接口操作组合部件的对象</li></ul></li></ul><ol start="5"><li>相关模式</li></ol><p>通常，部件 - 父部件连接用于 Responsibility of Chain模式</p><ul><li>Decorator模式经常与Composite模式一起使用。当装饰和组合一起使用时，它们通常有一个公共的父类。因此装饰必须支持具有Add、Remove、GetChild操作的Component接口</li><li>Flyweight 让你共享组件，但不再能引用其父组件</li><li>Iterator 可用来遍历Composite</li><li>Visitor 将本来应该分布在Composite和Leaf类中的操作和行为局部化</li></ul><ol start="6"><li>示例代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Decorator.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> PATTERNDESIGN_DECORATOR_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PATTERNDESIGN_DECORATOR_H</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_composite</span><span class="hljs-params">()</span> </span>;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 组合模式</span><br><span class="hljs-comment"> * 粗略地将计算机作为例子，一些基本的外设作为Leaf，主板作为一个小整体 Composite（里面又包含了cpu、内存、显卡等）</span><br><span class="hljs-comment"> * 以查询价格作为公共接口</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// Component类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Equipment</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Equipment</span>(std::string name, <span class="hljs-type">int</span> price) : <span class="hljs-built_in">name</span>(name),<span class="hljs-built_in">price</span>(price) &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Equipment</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">get_name</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">get_price</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Equipment* equipment)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Equipment* equipment)</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>可以更近一步，使用 Iterator 模式</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Equipment* <span class="hljs-title">get_child</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    std::string name;<br>    <span class="hljs-type">int</span> price;<br>&#125;;<br><br><span class="hljs-comment">// 鼠标，Leaf类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mouse</span> : <span class="hljs-keyword">public</span> Equipment&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Mouse</span>(std::string name, <span class="hljs-type">int</span> price) : <span class="hljs-built_in">Equipment</span>(name,price) &#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">get_price</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.9</span> ;        <span class="hljs-comment">// 比如这段时间鼠标平均价下降</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// CPU，Leaf类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPU</span> : <span class="hljs-keyword">public</span> Equipment &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CPU</span>(std::string name, <span class="hljs-type">int</span> price, std::string type) : <span class="hljs-built_in">Equipment</span>(name, price), <span class="hljs-built_in">type</span>(type) &#123;<br><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string type;<br>&#125;;<br><br><span class="hljs-comment">// 显卡，Leaf类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphicCards</span> :<span class="hljs-keyword">public</span> Equipment &#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-built_in">GraphicCards</span>(std::string name, <span class="hljs-type">int</span> price) : <span class="hljs-built_in">Equipment</span>(name, price) &#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">get_price</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> price * <span class="hljs-number">2</span>;           <span class="hljs-comment">// 这段时间显卡溢价</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Composite类，主板</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainBoard</span> : <span class="hljs-keyword">public</span> Equipment &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MainBoard</span>(std::string name, <span class="hljs-type">int</span> price) : <span class="hljs-built_in">Equipment</span>(name, price) &#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Equipment* equipment)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (equipment == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        children.<span class="hljs-built_in">push_back</span>(equipment);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Equipment* equipment)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (equipment == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = children.<span class="hljs-built_in">begin</span>(); iter != children.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>            <span class="hljs-keyword">if</span> (*iter == equipment) &#123;<br>                children.<span class="hljs-built_in">erase</span>(iter);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Equipment* <span class="hljs-title">get_child</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= children.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> children[index];<br>    &#125;<br><br>    <span class="hljs-comment">// 累加该设备上附带的所有设备的价值</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">get_price</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-type">int</span> sum = price;<br>       <span class="hljs-keyword">for</span> (Equipment* p : children) &#123;<br>           sum += p-&gt;<span class="hljs-built_in">get_price</span>();<br>       &#125;<br>       <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;Equipment*&gt; children;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//PATTERNDESIGN_DECORATOR_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Decorator.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Composite.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_composite</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————开始测试装饰模式——————————&quot;</span> &lt;&lt; endl;<br>    Equipment* cpu = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CPU</span>(<span class="hljs-string">&quot;CPU&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;Intel&quot;</span>);<br>    Equipment* graphic_card = <span class="hljs-keyword">new</span> <span class="hljs-built_in">GraphicCards</span>(<span class="hljs-string">&quot;显卡&quot;</span>,<span class="hljs-number">4000</span>);<br>    Equipment* main_board = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MainBoard</span>(<span class="hljs-string">&quot;主板&quot;</span>,<span class="hljs-number">800</span>);<br>    main_board-&gt;<span class="hljs-built_in">add</span>(cpu);<br>    main_board-&gt;<span class="hljs-built_in">add</span>(graphic_card);<br>    cout &lt;&lt; main_board-&gt;<span class="hljs-built_in">get_name</span>() &lt;&lt; <span class="hljs-string">&quot; with &quot;</span> ;<br>    cout &lt;&lt; main_board-&gt;<span class="hljs-built_in">get_child</span>(<span class="hljs-number">0</span>)-&gt;<span class="hljs-built_in">get_name</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; main_board-&gt;<span class="hljs-built_in">get_child</span>(<span class="hljs-number">1</span>) -&gt;<span class="hljs-built_in">get_name</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;all price:&quot;</span> &lt;&lt; main_board-&gt;<span class="hljs-built_in">get_price</span>() &lt;&lt; endl;<br>    main_board-&gt;<span class="hljs-built_in">remove</span>(cpu);<br>    cout &lt;&lt; <span class="hljs-string">&quot;主板（带有显卡）当前价格:&quot;</span> &lt;&lt; main_board-&gt;<span class="hljs-built_in">get_price</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————结束测试装饰模式——————————&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Decorator（装饰）——对象结构型模式"><a href="#Decorator（装饰）——对象结构型模式" class="headerlink" title="Decorator（装饰）——对象结构型模式"></a>Decorator（装饰）——对象结构型模式</h1><ol><li>意图</li></ol><p>动态地给一个对象添加一些额外的职责。就添加功能来说，Decorator模式相比生成子类更加灵活</p><ol start="2"><li>别名</li></ol><p>包装器（wrapper）</p><ol start="3"><li>动机</li></ol><p>有时我们希望给某个对象而不是整个类添加一些功能，例如一个图形用户界面工具箱允许你对任意一个用户界面组件添加一些特性（例如边框），或是一些行为（例如窗口滑动）。</p><p>使用继承机制是添加功能的一种有效途经，从其他类继承过来的边框特性可以被多个子类的实例所使用，但这种方法不够灵活，因为边框的选择时静态的，用户不能控制对组件加边框的方式和时机。</p><p>一种较为灵活的方式就是将组件嵌入另一个对象中，由这个对象添加边框。我们称这个嵌入的对象为装饰。这个装饰与它所装饰的组件接口一致，因此它对使用该组件的客户透明。它将客户请求转发给该组件，并且可能在转发前后执行一些额外的动作（例如画一个边框）。透明性使得你可以递归地嵌套多个装饰，从而可以添加任意多的功能。</p><ol start="4"><li>适用性</li></ol><p>以下情况下使用Decorator模式：</p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</li><li>处理那些可以撤销的职责</li><li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，类定义被隐藏，或类定义不能用于生成子类（这个意思就是装饰的意思？）。</li></ul><ol start="5"><li>结构</li></ol><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203202024851.jpeg" alt="类图设计"></p><ol start="6"><li>参与者</li></ol><ul><li>Component（VisualComponent）<ul><li>定义一个对象接口，可以给这些对象动态地添加职责</li></ul></li><li>ConcreteComponent(TextView)<ul><li>定义一个对象，可以给这个对象添加一些职责</li></ul></li><li>Decorator<ul><li>维持一个指向Component对象的指针，并定义一个与Component接口一致的接口</li></ul></li><li>ConcreteDecorator（BorderDecorator、ScrollDecorator)<ul><li>向组件添加职责</li></ul></li></ul><ol start="7"><li>协作</li></ol><p>Decorator将请求转发给它的Component对象，并有可能在转发请求前后执行一些附加的动作</p><ol start="8"><li>相关模式</li></ol><ul><li>Adapter：Decorator模式不同于Adapter模式，因为装饰仅改变对象的职责而不改变它的接口；而适配器将给对象一个全新的接口</li><li>Composite：可以将装饰视为一个退化的、仅有一个组件的组合。然而， 装饰仅给对象添加一些额外的职责——它的目的不在于对象聚集。</li><li>Strategy：用一个装饰可以改变对象的外表；而Strategy模式使你可以改变对象的内核。这是改变对象的两种途经。</li></ul><ol start="9"><li>示例代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Decorator.h </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STRUCTURALPATTERNDESIGN_DECORATOR_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRUCTURALPATTERNDESIGN_DECORATOR_H</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 装饰模式</span><br><span class="hljs-comment"> * 以GUI组件为例，定义可视化组件为基本的component类，文本框为具体的一个组件类，</span><br><span class="hljs-comment"> * 边框和滚轮则是装饰器类</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_decorator</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// Component类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VisualComponent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    ~<span class="hljs-built_in">VisualComponent</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextLine</span> : <span class="hljs-keyword">public</span> VisualComponent &#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span>  </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;画出一个文本框&quot;</span> &lt;&lt; std::endl;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 简单修饰器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> : <span class="hljs-keyword">public</span> VisualComponent&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Decorator</span>(VisualComponent* component) : <span class="hljs-built_in">component</span>(component) &#123;<br><br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Decorator</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        component-&gt;<span class="hljs-built_in">draw</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    VisualComponent* component;<br><br>&#125;;<br><br><span class="hljs-comment">// 边框修饰器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BorderDecorator</span> : <span class="hljs-keyword">public</span> Decorator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BorderDecorator</span>(VisualComponent* component, <span class="hljs-type">int</span> width) : <span class="hljs-built_in">Decorator</span>(component), <span class="hljs-built_in">width</span>(width) &#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>       Decorator::<span class="hljs-built_in">draw</span>();<br>       <span class="hljs-built_in">add_border</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> width;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_border</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;添加边框,&quot;</span> &lt;&lt; <span class="hljs-string">&quot;厚度为&quot;</span> &lt;&lt; width &lt;&lt; std::endl;<br>    &#125;<br><br><br>&#125;;<br><br><span class="hljs-comment">// 滚动条修饰器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrollDecorator</span> : <span class="hljs-keyword">public</span> Decorator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ScrollDecorator</span>(VisualComponent* component) : <span class="hljs-built_in">Decorator</span>(component) &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        Decorator::<span class="hljs-built_in">draw</span>();<br>        <span class="hljs-built_in">add_scroll</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_scroll</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;添加滚动条&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 窗口window，可以将一个可视化组件放入窗口中显示</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_content</span><span class="hljs-params">(VisualComponent* component)</span> </span>&#123;<br>        component-&gt;<span class="hljs-built_in">draw</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//STRUCTURALPATTERNDESIGN_DECORATOR_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Decorator.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Decorator.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_decorator</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————开始测试装饰模式——————————&quot;</span> &lt;&lt; endl;<br>    Window window;<br><br>    window.<span class="hljs-built_in">set_content</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">ScrollDecorator</span>(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-built_in">BorderDecorator</span>(<br>                            <span class="hljs-keyword">new</span> TextLine, <span class="hljs-number">3</span>)));<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————结束测试装饰模式——————————&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【99%环境搭建系列】xv6-riscv内核调试教程</title>
    <link href="/2022/03/19/2022-03/2022-03-19%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97-xv6%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B/"/>
    <url>/2022/03/19/2022-03/2022-03-19%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97-xv6%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在上《操作系统高级课程》，做的实验是MIT6.828的课程实验，在一个简易操作系统内核XV6上进行调试开发。后续我也会写一些介绍操作系统的文章。</p><p>关于XV6，这是MIT开发的一个教学目的的操作系统。<em>XV6</em>是在x86处理器上(x即指x86)用ANSI标准C重新实现的Unix第六版(Uni<em>x V6</em>，通常直接被称为V6)。并且MIT6.828这门关于操作系统的课程也是广受好评的，也推荐大家去学习。</p><p>这里再贴出一份相关的资源清单（不要再说找不到学习资源了而不学了~）：</p><ul><li>课程网站：<a href="https://pdos.csail.mit.edu/6.828/2020">https://pdos.csail.mit.edu/6.828/2020</a></li><li>xv6 官网安装教程：<a href="https://pdos.csail.mit.edu/6.828/2020/tools.html">https://pdos.csail.mit.edu/6.828/2020/tools.html</a></li><li>北大课程提示：<a href="https://github.com/FrankZn/xv6-pku-hints">https://github.com/FrankZn/xv6-pku-hints</a></li><li>xv6-book中文版：<a href="https://github.com/FrankZn/xv6-riscv-book-Chinese">https://github.com/FrankZn/xv6-riscv-book-Chinese</a></li><li>中文字幕视频：<a href="https://www.bilibili.com/video/BV19k4y1C7kA">6.S081 &#x2F; Fall 2020 麻省理工操作系统 - 2020 年秋季</a></li><li>实验代码参考：<a href="https://home.cnblogs.com/u/weijunji/">https://home.cnblogs.com/u/weijunji/</a></li></ul><hr><p>回归主题，这次文章的来由就是实现虚拟机上实现gdb调试xv6。一开始因为只下载了内核的代码，所以只能进行编译运行，使用自带的gdb出现各种问题，后来发现是没有安装相应的编译工具。但是实际安装起来却花费了我好大一番功夫，所以特此记录，帮助后来人减少弯路。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203200908096.(null)" alt="报错信息1"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203200908937.(null)" alt="报错信息2"></p><p>再提一下我的机器环境：</p><ul><li>宿主机操作系统：Win10</li><li>虚拟机：Ubuntu20.04</li></ul><h1 id="追记"><a href="#追记" class="headerlink" title="追记"></a>追记</h1><p>后来经过指点，发现根本不需要下面riscv-gnu-toolchain 安装这一步骤，可以跳过那部分（其实那部分操作相当于是自己手动进行编译了，但实际上只需要用到编译好的工具程序即可）。</p><p>话不多说，直接上教程。</p><ol><li>首先可以根据官网教程安装，也就是执行下面这条命令，安装相关工具：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu <br></code></pre></td></tr></table></figure><ol start="2"><li>然后再克隆实验代码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git://g.csail.mit.edu/xv6-labs-2020<br></code></pre></td></tr></table></figure><ol start="3"><li>切换分支，并进行编译</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout util<br>make qemu<br></code></pre></td></tr></table></figure><p>如果出现类似下面的界面，则表明安装成功</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204082125043.png" alt="xv6内核运行截图"></p><ol start="4"><li>按ctrl + a + x 退出内核运行，在启动make qemu-gdb</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make qemu-gdb<br></code></pre></td></tr></table></figure><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204082133201.png" alt="make qemu-gdb运行结果"></p><ol start="5"><li>然后打开另一个中断窗口，直接执行gdb的话，会出现下面的提示</li></ol><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204082134470.png" alt="提示"></p><ol start="6"><li>按照提示，在<code>~/.gdbinit</code>文件中加入 <code>set auto-load safe-path /</code></li><li>然后执行<code>gdb-multiarch</code>，看到出现类似下面的界面，就表示成功了，接下里就是愉快的调试时间了，可以参考下文的GDB调试内容。</li></ol><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202204082134187.png" alt="执行成功"></p><h1 id="riscv-gnu-toolchain-安装"><a href="#riscv-gnu-toolchain-安装" class="headerlink" title="riscv-gnu-toolchain 安装"></a>riscv-gnu-toolchain 安装</h1><p>根据官网上的教程安装，发现虚拟机连不上外网（这里还尝试一番功夫，没能成功），所以看到这篇文章，<a href="https://blog.csdn.net/qq_35990574/article/details/110006307">riscv-gnu-toolchain工具链下载安装_roockiet的博客</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[riscv-gnu-toolchain工具链下载安装_roockiet的博客](https://blog.csdn.net/qq_35990574/article/details/110006307)">[1]</span></a></sup></p><p>使用gitee上的镜像进行下载，需要执行的命令大体如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-comment"># 安装编译需要的一些依赖</span><br>sudo apt<span class="hljs-literal">-get</span> install autoconf automake autotools<span class="hljs-literal">-dev</span> <span class="hljs-built_in">curl</span> libmpc<span class="hljs-literal">-dev</span> libmpfr<span class="hljs-literal">-dev</span> libgmp<span class="hljs-literal">-dev</span> gawk <span class="hljs-built_in">build-essential</span> bison flex texinfo gperf libtool patchutils bc zlib1g<span class="hljs-literal">-dev</span> libexpat<span class="hljs-literal">-dev</span><br><br><span class="hljs-comment"># 克隆工具仓库</span><br>git clone https://gitee.com/mirrors/riscv<span class="hljs-literal">-gnu-toolchain</span>.git<br><br><span class="hljs-comment"># 进入目录</span><br><span class="hljs-built_in">cd</span> riscv<span class="hljs-literal">-gnu-toolchain</span> <br><br><span class="hljs-comment"># 手动克隆其他仓库，下载比较耗时，耐心等待吧</span><br>git clone https://gitee.com/mirrors/riscv<span class="hljs-literal">-binutils-gdb</span>.git riscv<span class="hljs-literal">-binutils</span><br>git clone https://gitee.com/mirrors/riscv<span class="hljs-literal">-dejagnu</span>.git riscv<span class="hljs-literal">-dejagnu</span><br>git clone https://gitee.com/mirrors/riscv<span class="hljs-literal">-gcc</span>.git riscv<span class="hljs-literal">-gcc</span><br>git clone https://gitee.com/mirrors/riscv<span class="hljs-literal">-binutils-gdb</span>.git riscv<span class="hljs-literal">-gdb</span><br>git clone https://gitee.com/mirrors/riscv<span class="hljs-literal">-glibc</span>.git riscv<span class="hljs-literal">-glibc</span><br>git clone https://gitee.com/mirrors/riscv<span class="hljs-literal">-newlib</span>.git riscv<span class="hljs-literal">-newlib</span><br><br><span class="hljs-comment"># 这个qemu目录，后面好像没有用到，可以把这个目录给去了，如果担心，那就也一并下载吧</span><br>git clone https://gitee.com/mirrors/qemu.git qemu<br><br><span class="hljs-comment"># 所有仓库下载完成，开始编译</span><br>./configure <span class="hljs-literal">--prefix</span>=/usr/local  <span class="hljs-comment">#（选择安装目录，请确保对应的目录有足够大的容量，算上下载的仓库大约20G）</span><br>sudo make<br><span class="hljs-comment"># 这样编译大约需要 1 ~ 2 小时</span><br></code></pre></td></tr></table></figure><hr><p>注意这个riscv-gnu-toolchain所有的仓库都克隆下来后，并且直接执行make安装的话，耗时较久，估计有1~2小时，最后大约有18G（我是安装在了&#x2F;opt&#x2F;bin目录下），所以一定要确保对应分区的容量足够，不然就会因为容量不够而写失败（都是血淋淋的教训啊，看到下图根目录的挂载点了吗，之前就是因为安装在根目录对应的分区下，导致容量空间直接满了。。）。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203192203252.(null)" alt="查看磁盘分区使用情况"></p><p>如果为了节省空间和时间，可以只尝试下面的配置方式，只安装riscv64-unknown-elf-gcc，参考这篇文章，<a href="https://blog.csdn.net/weiqi7777/article/details/88045720">riscv各种版本gcc工具链编译与安装_weiqi7777的博客-CSDN博客_riscv编译器</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[riscv各种版本gcc工具链编译与安装_weiqi7777的博客-CSDN博客_riscv编译器](https://blog.csdn.net/weiqi7777/article/details/88045720)">[2]</span></a></sup></p><p>因为后面调试时只用到了riscv64-unknown-elf-gdb，所以我猜测只需要安装对应gcc工具即可，不过我自已没有尝试过可不可行，所以还是交由各位看官自行决定。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell">../configure --prefix=/opt/riscv64 --with-arch=rv64imc --with-abi=lp64<br>make<br></code></pre></td></tr></table></figure><h1 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h1><ol><li>首先在一个窗口上执行：</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make qemu-gdb</span><br></code></pre></td></tr></table></figure><ol start="2"><li>然后打开另一个窗口，执行：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">riscv64-unknown-elf-gdb kernel/kernel<br></code></pre></td></tr></table></figure><ol start="3"><li>然后可以看到进入了gdb界面，接着远程连接上一个窗口的gdb，执行下面的命令：</li></ol><p><code>target remote localhost:26000</code> （这里的26000填上一个窗口的端口号）</p><ol start="4"><li>连接成功之后，显示如下：</li></ol><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203200909360.(null)" alt="远程连接程序"></p><ol start="5"><li>然后把自己编译好的用户程序加载进来，也就是user目录下的文件<code> file user/_find</code></li></ol><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203200909713.(null)" alt="加载要调试的编译文件"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203200909785.(null)" alt="设置断点并执行"></p><ol start="6"><li>然后设置好断点，就可以按下 c 让程序运行到断点处，再返回上个窗口，执行对应命令，就可以看到程序暂停住了，返回gdb调试程序窗口，也能看到当前暂停的地方就是刚刚设置的断点处。</li></ol><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203200909251.(null)" alt="远程内核开始运行"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203200910116.(null)" alt="gdb查看当前断点"></p><ol start="7"><li>之后就是痛苦地愉快地调试bug啦~有关gdb调试技巧，还可以参考我之前写的这篇文章，<a href="http://gg.gg/y7c2n">GDB调试学习</a>。</li></ol><h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><p>这次安装过程中遇到两个坑，一个是在克隆仓库的时候，虚拟机无法访问外网，一个是安装riscv编译工具时，分区的容量不够了，这里就简单地做个记录。</p><h2 id="虚拟机网络配置"><a href="#虚拟机网络配置" class="headerlink" title="虚拟机网络配置"></a>虚拟机网络配置</h2><p>一开始的需求是实现虚拟机共享主机的VPN，也能够访问外网，参考了这篇文章，<a href="https://www.jianshu.com/p/6c7abd4adc9b">Ubuntu虚拟机共享主机VPN（适用于NAT或桥接）</a><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Ubuntu虚拟机共享主机VPN（适用于NAT或桥接）](https://www.jianshu.com/p/6c7abd4adc9b)">[3]</span></a></sup></p><p>尝试之后，报错代理服务器错误，正常的国内网页无法访问了。因为这个时候我用的是NAT模式，所以就想要尝试用桥接模式再试一下。</p><p>参考这里的视频教程 <a href="https://www.bilibili.com/video/BV1ji4y1772Z?from=search&seid=5722489325382065130&spm_id_from=333.337.0.0">VMware网络选择和ubuntu 20_04 网络配置教程</a><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[VMware网络选择和ubuntu 20_04 网络配置教程](https://www.bilibili.com/video/BV1ji4y1772Z?from=search&seid=5722489325382065130&spm_id_from=333.337.0.0)">[4]</span></a></sup>，</p><p>配置静态IP的方式，我之前也提到过<a href="http://gg.gg/y7c4c">【99%环境搭建系列】云计算管理平台Devstack安装</a>，后来虽然国内网络能够正常访问了，但是外网还是不行。</p><p>后来尝试很久还是没能成功，最后也就作罢了。既然外网访问不了，那就找国内镜像吧，幸运的是这条路走通了。</p><hr><p>最后没有实现需求，我想可能还是自己对网络的了解还是太粗浅了，日后一定要再恶补一下。不过借此机会，也了解学习了下VPN、桥接模式、NAT模式的概念，这里做个简单总结吧。</p><p>VPN：Vitrual Private Network，简单来说就是通信双方之间的数据进行了加密。更多内容参考 <a href="https://www.bilibili.com/video/BV1KY411t75D?from=search&seid=9126546184192701202&spm_id_from=333.337.0.0">VPN概念，技术原理和误区_哔哩哔哩_bilibili</a><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[VPN概念，技术原理和误区_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1KY411t75D?from=search&seid=9126546184192701202&spm_id_from=333.337.0.0)">[5]</span></a></sup></p><p>桥接模式：虚拟机使用宿主机的真实网卡，宿主机和虚拟机在相同的公网IP段下。</p><p>NAT模式：虚拟机和宿主机使用同一个虚拟网卡，从而实现在同一个局域网网段下，比如192.168.17.0 &#x2F; 24。</p><h2 id="ubuntu添加磁盘分区"><a href="#ubuntu添加磁盘分区" class="headerlink" title="ubuntu添加磁盘分区"></a>ubuntu添加磁盘分区</h2><p>还有一个坑就是在编译安装的时候，磁盘分区容量不够了。所以这里在演示一下如何给linux虚拟机添加磁盘分区。</p><ol><li>首先在VMware -&gt; 虚拟机选项 -&gt; 管理，选择扩展，添加想要增加的分区容量。（注意需要关闭虚拟机进行设置)</li><li>此时是还无法使用新增容量的，需要在虚拟机上添加分区，并挂载某一目录。那么首先登陆虚拟机，添加分区。</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-comment"># 列出所有设备，找到 type 类型为 disk 的设备名称</span><br>lsblk<br><br><span class="hljs-comment"># fdisk 适合MBR分区 </span><br>fdisk /dev/sda <span class="hljs-comment"># 这里的设备名称就是上面找到的设备名称</span><br><br><span class="hljs-comment"># 然后按 n ， 新增分区，选择一个区号，一路回车，最后 w 写入 </span><br><span class="hljs-comment"># 更详细的教程可以参考 https://www.cnblogs.com/rootshaw/p/12895022.html</span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>添加好分区之后，就是格式化 <code>sudo mkfs.ext4 /dev/sda3</code> (设备名换成刚刚新增的分区)</p></li><li><p>然后就是挂载目录<code>sudo mount /dev/sda3 /opt/bin</code>（选择自己需要挂载的目录）</p></li><li><p>使用<code> df -h</code> 可以看是否挂载成功。挂载成功之后就可以使用该分区了。</p></li><li><p>上面的挂载，每次重启后都需要手动重新设置，所以这里再实现开机自动挂载，其实就是往配置文件<code>/etc/fstab</code> 里写配置，格式如下：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">分区/设备名     要挂载的目录     文件系统类型     defaults        0       0<br>/dev/sda3   /opt/bin   ext4   defaults 0   0<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，折腾了我快一星期，总计耗时约10小时的调试环境安装之旅终于落下了帷幕。此时此刻我的心情是复杂的，一方面是为自己的无能而流泪（一个简单的调试环境搭建弄了这么久），兜兜转转这么久，也还只是完成了调试前的准备工作，查bug还在后头呢。另一方面也是一种释然，至少我没有半途而废，虽然过程坎坷，但我终究还是来到了终点。或许一开始我可以尝试用print输出来调试，但是我知道这种调试方式终究走不远，因为真正出问题的时候，是没有办法通过实时输出来进行调试的。所以这次使用gdb来调试内核，是一个千载难逢的机会，我不该错过。</p><hr><p><em>缓慢的、持久的、有纪律的努力，最终会导致令人难以置信的结果。</em></p><p><em>每当我无法忍受日常生活时，我就提醒自己，没有什么比每天坚持做下去更重要了。虽然我很难看到未来会怎样，但我知道持久性具有强大的威力，就像一句古老格言说的“继续去做”（keep doing）。</em></p><p>——<a href="https://www.collaborativefund.com/blog/lessons-from-the-sea/">《大海教给我的》</a></p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/qq_35990574/article/details/110006307">riscv-gnu-toolchain工具链下载安装_roockiet的博客</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/weiqi7777/article/details/88045720">riscv各种版本gcc工具链编译与安装_weiqi7777的博客-CSDN博客_riscv编译器</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.jianshu.com/p/6c7abd4adc9b">Ubuntu虚拟机共享主机VPN（适用于NAT或桥接）</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1ji4y1772Z?from=search&seid=5722489325382065130&spm_id_from=333.337.0.0">VMware网络选择和ubuntu 20_04 网络配置教程</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1KY411t75D?from=search&seid=9126546184192701202&spm_id_from=333.337.0.0">VPN概念，技术原理和误区_哔哩哔哩_bilibili</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>环境搭建系列</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6-riscv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git指南</title>
    <link href="/2022/03/12/2022-03/2022-03-12%20Git%E6%8C%87%E5%8D%97/"/>
    <url>/2022/03/12/2022-03/2022-03-12%20Git%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。Git是由Linux内核社区以Linus为主基于BitKeeper开发的分布式版本控制系统，具有快速、简单、分布式、能够高效管理大规模项目的特点。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203121131335.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto"></p><h2 id="本地仓库结构"><a href="#本地仓库结构" class="headerlink" title="本地仓库结构"></a>本地仓库结构</h2><p>Git本地仓库逻辑结构可以分为三部分：</p><ul><li>工作区 Working Directory：就是存放项目文件、代码的地方，对于添加、修改、删除文件的操作，都发生在工作区中；</li><li>暂存区 Staging Area、Index：用于临时存放你的改动，将工作区中的操作进行保存；</li><li>版本库 Repository：把所有的commit组织起来，也就是保存所有提交的数据，记录历史版本。</li></ul><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203121132711.png" alt="" style="zoom:50%;" /></center>上图也描绘了基本的工作流程，当你在工作区完成阶段性操作后，就可以执行`add`命令，将修改保存到暂存区。当你觉得完成这次开发后，就可以执行`commit`命令，提交到版本库。此外`.git`这个目录是在git自带的一个隐藏项目，在初始化的时候会自动生成，里面的各个目录就记录着实现版本控制所需的数据，例如对象库，对象概念将在稍后介绍。<p>网上也有不少关于git的文章，下图来自于这篇文章<a href="https://www.cnblogs.com/qdhxhz/p/9757390.html">Git：工作区、暂存区、版本库、远程仓库</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[【Git】(1)---工作区、暂存区、版本库、远程仓库 ](https://www.cnblogs.com/qdhxhz/p/9757390.html)">[1]</span></a></sup>，更为详细地展示了git整个流程。其中 Remote 表示是远程仓库，可以认为是代码托管的服务器&#x2F;远程备份，像我们最为熟知的就是Github。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203121139228.png" alt="git基本流程"></p><h2 id="Git中的对象"><a href="#Git中的对象" class="headerlink" title="Git中的对象"></a>Git中的对象</h2><p>Git中有三种基本对象：</p><ol><li>blob：文件，保存文件的数据内容</li><li>tree：目录树，保存目录结构和文件名等信息</li><li>commit：提交，保存提交内容、作者、提交者、提交时间等信息</li></ol><blockquote><p>注意：这里说的是基本对象，还有说法是tag也是一种对象，用来标记某一次提交(commit) ，类似于里程碑的一种记录</p></blockquote><p>而对象有对象名，是40个字符（20字节的16进制表示）的字符串，由SHA-1计算文件内容的哈希值，当没有冲突歧义的时候，可以就用前几位字符表示（但不可以少于4位）。</p><p>在git中，对象之间的关系如下图所示，commit包含一个tree对象（主目录），而一个tree对象可以包含多个blob（文件）和多个tree（子目录）。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203121202585.png" alt="blob,tree,commit之间的关系"></p><p>可以用<code>get cat-file -t [对象名]</code>查看某个对象的类型，如下图所示，该对象是一个tree：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203121719515.png" alt="查看对象类型"></p><p>可以用<code>get cat-file -p [对象名]</code>查看某个对象的内容，如下图所示，可以看到该tree对象下有一个blob文件，和两个tree对象（两个子目录）：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203121719712.png" alt="查看对象内容"></p><h1 id="单分支管理"><a href="#单分支管理" class="headerlink" title="单分支管理"></a>单分支管理</h1><h2 id="初始化和提交"><a href="#初始化和提交" class="headerlink" title="初始化和提交"></a>初始化和提交</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将自动地在当前目录完成版本库的初始化，即在当前目录下生成一个.git的隐藏目录</span><br>git init<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将自动在当前目录下创建一个指定项目名的目录，并在该目录下创建一个名为.git的隐藏目录</span><br>git init &lt;项目名&gt;<br></code></pre></td></tr></table></figure><p>一个新的<code>.git</code>目录下通常会包括7个文件&#x2F;目录：</p><ul><li>hooks：包含客户端或服务端的钩子脚本（hooks scripts)</li><li>info：默认包含一个全局性忽略文件</li><li>objects：存储所有的对象</li><li>refs：存储所有分支和tag（指向commit对象的指针）</li><li>config：版本库级别的配置文件</li><li>description：仅供GitWeb程序使用</li><li>HEAD：当前指针，用于当前操作</li></ul><p>而当进行add操作之后就会出现一个index文件</p><ul><li>index：保存暂存区的信息</li></ul><hr><p>最为常用的就是<code>add</code>和<code>commit</code>的命令了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将path所指定的目录或文件添加到暂存区</span><br>git add &lt;path&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将暂存区中&lt;path&gt;所指定的目录或文件添加到版本库，同时产生一个新的commit，path默认为当前目录</span><br>git commit [&lt;path&gt;] -m &quot;&lt;提交说明&gt;&quot;<br></code></pre></td></tr></table></figure><p>但其实这两个命令，是由许多个更底层的命令组成的：</p><ul><li><code>git update-index --add --cacheinfo</code> 命令将对象库中的blob添加到暂存区</li><li><code>git update-index --add</code> 将工作区中的文件添加到暂存区（同时在对象库中生成blob对象）</li><li><code>git write-tree</code> 命令根据当前暂存区内容在对象库中新建一个tree对象</li><li><code>git read-tree</code> 命令将tree对象读到暂存区</li><li><code>git commit-tree</code> 命令可以将指定的tree对象”封装“成commit对象保存在版本库中</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203121911543.png" alt="add和commit的命令分解"></p><h2 id="提交历史和管理"><a href="#提交历史和管理" class="headerlink" title="提交历史和管理"></a>提交历史和管理</h2><p>这里就列举一些比较关键常用的命令吧：</p><ul><li><code>git diff</code> ：可以显示工作区、暂存区、版本库中文件具体的差别</li><li><code>git log [-n]</code> ：显示最近提交的commit记录；<code>-n</code> 参数表示显示最近n条记录；还可以通过添加 <code>--pretty=raw</code> 参数来显示commit对象的内容</li><li><code>git status</code>：显示工作区、暂存区、版本库中文件增删改的情况</li><li><code>git stash [list | [pop|apply] [--index] [stash名] ]</code>：将当前的修改进度暂时保存起来<ul><li>没有参数就是现场保存</li><li>参数为list表示查看保存现场的栈的内容</li><li>参数为pop或apply表示将栈中的内容恢复，区别在于pop后栈的记录会被删除而apply不会</li></ul></li><li><code>git blame &lt;文件名&gt;</code> ：可以按行查看指定文件的最后一次修改的commit，修改人，时间</li></ul><h1 id="多分支管理"><a href="#多分支管理" class="headerlink" title="多分支管理"></a>多分支管理</h1><p><strong>游标（head）</strong>：可以看成是一个指针，指向某个特定的commit对象或者分支，即当前操作的默认对象，如git log，git status等命令中，版本库的当前操作commit就是head所指向的commit对象。</p><p><strong>分支（branch）</strong>：可以看成是一个指针，指向了一个提交（commit），在该分支上的所有提交都会对该分支进行更新，保证该分支一直指向最新的commit</p><blockquote><p>注意：head可以指向分支或者commit，但是分支总是指向commit</p></blockquote><p><strong>经典场景</strong>：功能特性的开发——在添加一个新功能时可以通过再新的分支上进行开发，从而使得功能特性的开发不会影响到正常的版本迭代，在开发完成后再通过分支的合并将该功能添加到最新的版本上。</p><ul><li><code>git branch &lt;分支名&gt;</code>：该命令可以在当前head指向的commit位置创建一个指定分支名的branch分支。master就是一个branch</li><li><code>git checkout [-b] &lt; commit &gt; </code>：该命令的主要功能为改变head游标，将其指向commit<ul><li>因为branch和tag本质上都是一个commit对象，所以这里用了&lt; commit &gt;参数，其实也可以写成分支名</li><li><code>-b</code> 参数是创建并切换</li></ul></li></ul><p>有时候在操作切换分支的时候，我们可能会遇到一个很经典的问题：**分离头指针状态(detached HEAD)**。该状态表明当前head没有指向任何认知，而是指向了一个独立的commit，如下图所示。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203121937329.png" alt="分离头指针状态"></p><p>想要恢复也很简单，使用checkout命令切换到一个分支上即可。</p><hr><p>分支会随着commit的提交而更新，但是有时候需要记录一个稳定的版本，如v1.1，v1.2，此时就需要引入tag。</p><p>tag可以记录某个特定的commit，并使其不随着commit的提交而改变其指向的commit位置。tag可以看成是一个指向commit的常量指针，所有对commit的操作都可以对tag使用。</p><ul><li><code>git tag &lt; tag名 &gt;</code>：可以在当前head指向的commit位置建立一个指定tag名的tag</li></ul><hr><p>当前需要对分支进行修改&#x2F;重置的时候，可以使用下面的命令，将当前分支指向某commit</p><ul><li><code>git reset [--soft | --mixed | --head] &lt; commit &gt;</code><ul><li>中间参数默认为 –mixed</li><li><code>--soft</code>：会将当前指向的branch指向指定的commit</li><li><code>--mixed</code>（或无参数）：除了改变branch的位置外，还会使用该commit的内容更新<strong>暂存区</strong>的内容</li><li><code>--hard</code> ：除了改变branch的位之外，还会用该commit的内容更新<strong>暂存区和工作区</strong>的内容（<strong>危险操作！贸然使用容易丢失当前工作区的修改</strong>）</li></ul></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203121946975.png" alt="分支修改"></p><hr><p>还有几个分支相关的重要命令：</p><ul><li><p><code>git merge &lt; commit &gt;</code>：将当前head所指向的分支和指定commit分支进行合并，最后会生成一个新的commit，该commit的parent指针同时指向两个commit</p></li><li><p><code>git rebase &lt; commit &gt; </code>： 变基操作，该命令将提交到某一分支上的所有修改都移至另一分支上</p></li><li><p><code>git rebase -i HEAD~3</code> ： -i 选项进入交互式界面，可以对前三个commit进行压缩</p></li></ul><p>关于merge和rebase的相关概念可以参考这篇文章<a href="https://www.imooc.com/article/316077">git rebase 和 merge 的区别</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[git rebase 和 merge 的区别](https://www.imooc.com/article/316077)">[2]</span></a></sup>，这里就不再重复造轮子了，下图就是简单示意，上面是merge后的分支变化，下面是rebase后的分支变化。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203122020985.png" alt="merge（上）rebase（下）"></p><h1 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h1><p>多人协作时就会涉及远程仓库的概念，简单理解就是远程服务器上的git版本库。目前常见的基于git的代码托管平台有Github、Gitee、Gitlab等，可以简单的把代码托管平台看成更是一个远程的git仓库，通过push、fetch等命令来进行操作。</p><p>这里就简单罗列相关命令：</p><ul><li><code>git clone</code> ：在当前目录下创建指定的git仓库的克隆</li><li><code>git push</code>：将当前指向的分支推送至远程版本库</li><li><code>git fetch</code>：将远程版本库中本地没有的记录拉取到本地</li><li><code>git pull</code>：该命令等于<code>git fetch</code> 加 <code>git merge [fetch命令获得的head]</code></li><li><code>git remote -v</code> ：可以查看当前使用push、fetch、pull命令同步的远程版本库</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203122027018.png" alt="多人协作开发"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203122030217.png" alt="大型项目协作开发"></p><p>Github上项目的开发流程如上图所示，如果我们对别人的项目感兴趣，可以通过fork操作，将他人的项目仓库复制一个自己的项目仓库，然后通过fetch、push对个人仓库进行操作。而通过Pull requests操作，可以申请将自己个人仓库上的特定分支与他人仓库上的特定分支进行合并。</p><hr><p> 但是如果我们把带有bug的分支提交到远端，并合入了 master ，这时候就需要用到 <code>git revert</code>命令来撤销 commit 修改，具体可以参考 <a href="https://blog.csdn.net/liuxiao723846/article/details/122691779">git revert 命令</a> 。进一步的，思考这样一个场景，如果一个 repo 的运营人员不小心在提交的 commit 上暴露了隐私信息（例如数据库账号密码），那么此时应该怎么处理呢？ 这里我提供的思路是，本地使用 <code>git reset --hard</code>来重置commit 历史，并覆盖远程分支。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大体上把git重要的知识点都介绍了一下，但实际上主要常用的命令可能就那么几个，add、commit、push、pull、merge、rebase、checkout，把这几个命令用熟了基本够用了，遇到不会的现查就是了（话不能这么说啊）。 总归是了解得越多越好，只不过上面这几个命令算是基本要求了，不能不会啊~</p><p>最后再推荐几个git相关的学习参考网站：</p><ul><li><p><a href="https://git-scm.com/docs">Git官方文档</a></p></li><li><p><a href="https://www.progit.cn/">Pro Git第二版（中文版）</a></p></li><li><p><a href="https://learngitbranching.js.org/?locale=zh_CN">在线学习git（沙盒环境）</a></p></li></ul><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/qdhxhz/p/9757390.html">【Git】(1)—工作区、暂存区、版本库、远程仓库 </a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.imooc.com/article/316077">git rebase 和 merge 的区别</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++踩坑记录之字面值常量</title>
    <link href="/2022/03/04/2022-03/2022-03-04%20C++%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F/"/>
    <url>/2022/03/04/2022-03/2022-03-04%20C++%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p class='note note-info'>   最近在刷题的时候无意间又踩了个坑，发现自己的修行还远远不够，所以也特此记录一下。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203051921295.jpg"></p><p>目标是想要拼接一个字符串常量和一个<code>char</code>型字符，类似下面这样的代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">string input=<span class="hljs-string">&quot;abc&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;&quot;</span> + input[<span class="hljs-number">0</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>那么问题来了，上面会输出什么呢？</p><h1 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h1><p>之前我想象中是拼接后返回是一个string对象，最后输出<code>input</code>的第一个字符，但是输出结果却让人意外，上面输出的结果不是期望值 <code>&quot;a&quot;</code>，而是一串莫名奇妙的字符，如下图。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203050828438.png" alt="令人不解的输出"></p><p>这让我有些摸不着头脑，这一串是怎么来的，当前执行的程序根本没有写过这样的字符串呀？等等，这些字符看着有点眼熟，然后我尝试搜索了一下，发现这个字符串在我之前执行的另一个源文件里。</p><p>这是怎么回事呢？为什么当前运行的程序，却涉及了另一个根本就没有启动、不相关的源文件呢？</p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203051921292.jpg" alt="安详" style="zoom: 50%;" /></center><p>然后灵光一现，我仿佛想起什么，该不会是这个常量字符串根本没有调用 string 重载的加法运算符吧？</p><p>然后再IDE里测试了一下，发现果然上面的这个加法是无法跳转到string对应的重载运算符上的，但如果用string构造函数封装一下，发现就可以进行跳转了。其实编译器也提示我，这种加法操作并没有真正的把<code>input[0]</code>这个字符插入到前面的这个字符串字面量里。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203051707911.png" alt="编译器提示"></p><p>然后联想一下用<code>char*</code>表示字符串的方式，以及字面值常量在内存中的存放位置，答案就浮出水面了。</p><p>我们知道字面值常量存储在内存的常量区，而平常我们使用<code>char* s = &quot;abc&quot;;</code>这样的表达方式，也说明字符串字面量其实指向的就是它在内存常量区的地址，是一个地址值（或者再极端一点，把字符串字面量当成一个<code>char*</code>指针来看）。因此<code>&quot;&quot;+input[0]</code>在执行加法运算时，这里把<code>input[0]</code>隐式转换成了int，然后进行指针的加法运算，最后计算的结果指向了常量区的某处地址，而这个地址恰好指向我上个程序执行后还保存着的字符串字面量（<em>为什么常量区还存储着之前程序的内容，我猜测可能是<strong>缓存</strong>之类的原因</em>），也就是<code>from left to right are: </code>这个字符串，所以最终输出了上述结果。</p><p>最后通过<a href="https://cppinsights.io/">https://cppinsights.io/</a> 这个网站验证下猜想的结果，发现的确如此。可以看到编译过后，如果和字符串字面进行相加，实际上会对<code>input[0]</code>进行<code>static_cast&lt;int&gt;</code>的转换，而如果和string类进行相加，则会调用重载运算符方法。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203051725718.png" alt="cppinsights"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，问题解决（<del>又水了一篇博客</del>）。总结一下，这次踩的坑很粗浅，大概涉及两个知识点，一个是字符串字面值指向的是常量区的一个地址，二是C++有数据隐式转换，在进行算术运算时会自动提升类型，比如<code>char</code>转为<code>int</code>。究其因为应该是自己的基础不够牢固，对字面值常量欠缺认识，也有可能是受以前Java的影响，自以为会封装成类，太过于想当然了，需要引以为戒。</p><p>最后再记录下近期自己的一些感受吧，因为在准备找实习，所以也是在看八股，刷算法题，然后今天练习的时候，又被难住了，就觉得自己真弱呀，自己这样的水平和实力能去面试吗？回头一看，发现自己相比过去好像并没有太大的进步，或者说没有可以拿得出手，值得自豪的本事。或许有自谦的成分，但我自己知道，跟顶尖的人相比，不，就跟我理想中的自己相比，还差得太远了，待办事项里、待学习的东西还有一箩筐。</p><p>但是，平凡无奇的我啊，现在有时间让你消沉吗？！我能做的，我要做的，就是咬牙坚持，继续学习！</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203051946077.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组与二级指针</title>
    <link href="/2022/02/28/2022-02/2022-02-28%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/"/>
    <url>/2022/02/28/2022-02/2022-02-28%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近再刷《剑指Offer》的面试题，其中遇到有一题跟二维数组相关，所以需要这样形式的函数，<code>void func(int** matrix, int rows, int columns)</code>，那么问题来了，再调用这个函数的时候，<strong>应该传入怎样的实参呢</strong>？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 需要被调用的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>** matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> columns)</span> </span>&#123;<br>  cout &lt;&lt; matrix[rows<span class="hljs-number">-1</span>][columns<span class="hljs-number">-1</span>] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 第一种传入实参方式</span><br><span class="hljs-type">int</span> matrix[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-built_in">func</span>(matrix, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 第二种传入实参</span><br><span class="hljs-type">int</span>** matrix = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>matrix[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>];<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>    matrix[i][j] = i*<span class="hljs-number">2</span> + j + <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br><span class="hljs-built_in">func</span>(matrix, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203012135420.jpg" alt="" style="zoom:50%;" /></center><h1 id="踩坑过程"><a href="#踩坑过程" class="headerlink" title="踩坑过程"></a>踩坑过程</h1><p>其实上面的答案很简单，直接敲代码测试一下，就知道第一种传参方式编译器直接报错，提示你类型不匹配。但是我头铁啊，愣是用强制转换 <code>func((int**)matrix, 2, 2)</code>的方式，然后就是程序崩溃报错了。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203012139296.jpg"></p><p>这是为什么呢？现在来理性分析一波，以下面的测试代码来进行说明。</p><p>首先<code>matrix</code> 是一个二维数组，它（数组名）对应的指针类型实际上是 <code>int(*)[2]</code> ，即指向数组的指针（有人称作是行数组指针）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[C/C++——二维数组与指针、指针数组、数组指针（行指针）、二级指针的用法 ](https://www.cnblogs.com/oddcat/p/9701518.html)">[1]</span></a></sup>，也就是说如果把<code>matrix</code>看成是一个指针的话，指向的类型是一个长度为2的int数组，因此在对<code>matrix</code>执行指针加法<code>（matrix+1）</code>的时候，一次移动的字节数为一个数组的长度即 2*4 &#x3D; 8 字节。那么执行解引用时， <code>matrix[1]</code> 得到是第2行一维数组的首地址，其类型就是一维数组。同时一维数组名对应指针类型为<code>int *</code>，因此再对 <code>matrix[1]</code> 执行指针加法操作<code>（matrix[1] + 1）</code>时，一次移动的字节数为一个int类型的字节长度。</p><p>其次对于二级指针（指针的指针）<code>p</code> 来说，因为<code> p</code> 指向的是一个<code>int * </code>指针，所以 <code>p</code> 执行指针加法的时候，一次移动的长度为 <code>int *</code> 指针类型的字节数（即8字节），那么解引用得到数据类型也就是 <code>int *</code> ，所以<code> p[0]</code> 得到的元素就是一个<code>int *</code> 指针，打印 <code>p[0]</code> 的值就是打印该指针的值，而指针的值就是一个地址。为什么这里打印出来的值这么怪异呢？因为它把<code>matrix</code>二维矩阵存储的int值当做指针的值来进行解析了，例如3 和 5 两个int值合起来为8字节，这个8个字节被当做地址的值而不是元素int的值，再加上我的电脑是小端（即低字节在低地址），最后打印出来的 <code>p[0]</code> 就是<code>0x500000003</code> 了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> matrix[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;matrix    address: &quot;</span> &lt;&lt; matrix &lt;&lt; endl;     <span class="hljs-comment">// 0x16d92b610</span><br>cout &lt;&lt; <span class="hljs-string">&quot;matrix[0] address: &quot;</span> &lt;&lt; matrix[<span class="hljs-number">0</span>] &lt;&lt; endl;  <span class="hljs-comment">// 0x16d92b610</span><br>cout &lt;&lt; <span class="hljs-string">&quot;matrix+1  address: &quot;</span> &lt;&lt; matrix+<span class="hljs-number">1</span> &lt;&lt; endl;   <span class="hljs-comment">// 0x16d92b618</span><br>cout &lt;&lt; <span class="hljs-string">&quot;matrix[1] address: &quot;</span> &lt;&lt; matrix[<span class="hljs-number">1</span>] &lt;&lt; endl;  <span class="hljs-comment">// 0x16d92b618</span><br><br><span class="hljs-type">int</span>** p = (<span class="hljs-type">int</span>**) matrix;<br>cout &lt;&lt; <span class="hljs-string">&quot;p    address: &quot;</span> &lt;&lt; p &lt;&lt; endl;          <span class="hljs-comment">// 0x16d92b610</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p[0] address: &quot;</span> &lt;&lt; p[<span class="hljs-number">0</span>] &lt;&lt; endl;       <span class="hljs-comment">// 0x500000003</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p+1  address: &quot;</span> &lt;&lt; p+<span class="hljs-number">1</span> &lt;&lt; endl;        <span class="hljs-comment">// 0x16d92b618</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p[1] address: &quot;</span> &lt;&lt; p[<span class="hljs-number">1</span>] &lt;&lt; endl;       <span class="hljs-comment">// 0x800000007</span><br><br><span class="hljs-type">int</span> ** p_matrix = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[<span class="hljs-number">2</span>];<br>p_matrix[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>];<br>p_matrix[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>];<br>p_matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>; p_matrix[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>;<br>p_matrix[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">7</span>; p_matrix[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">8</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;p_matrix    address: &quot;</span> &lt;&lt; p_matrix &lt;&lt; endl;    <span class="hljs-comment">// 0x60000081c020</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p_matrix[0] address: &quot;</span> &lt;&lt; p_matrix[<span class="hljs-number">0</span>] &lt;&lt; endl; <span class="hljs-comment">// 0x60000081c030</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p_matrix+1  address: &quot;</span> &lt;&lt; p_matrix+<span class="hljs-number">1</span> &lt;&lt; endl;  <span class="hljs-comment">// 0x60000081c028</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p_matrix[1] address: &quot;</span> &lt;&lt; p_matrix[<span class="hljs-number">1</span>] &lt;&lt; endl; <span class="hljs-comment">// 0x60000081c040</span><br></code></pre></td></tr></table></figure><p>啰里啰嗦说了这么多，可能还是没解释清楚，反而把自己绕晕了，所以再用下面这张图解释一下。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203011443395.jpeg" alt="内存图解"></p><p>弄清楚内存中数据分布后，现在应该知道为什么不能直接把二维数组matrix直接传给二级指针了吧。不过还有一个点，可能还是比较令人感到疑惑的，就是为什么<code>matrix+1</code> 和 <code>matrix[1]</code> 打印出来的值是相同的？</p><p>我是这么理解的（<strong>如果不对，还请在评论区中指出</strong>）：因为matrix 类型时 <code>int(*)[2] </code>，是一个指向一维数组的指针，因此解引用得到的应该就是个数组，所以可以认为 <code>matrix[1]</code> 就是个一维数组，而一维数组名不就是数组首元素的地址嘛，因此我觉得编译器在对 <code>matrix+1</code>这个地址解引用取值的时候，并没有像 二级指针 <code>int** p</code> 那样去取内存里的值作为地址值，而是直接将当前的地址值作为数组名的地址值反悔了。所以最终 <code>matrix+1</code> 和 <code>matrix[1]</code> 打印得到的结果相同。</p><hr><p>其实还遇到了另一种比较奇怪的形式，见下面的函数。我试了好几种传参方式，但总是编译通过，编译器一直提示我类型不匹配，告诉我形参<code>matrix</code>的真实类型为<code>int(*)[columns]</code>，这就和尴尬，因为<code>columns</code>是个变量，我怎么传一个数组长度为变量的数组指针？</p><p>我们都知道C++里，数组的长度是一个固定值，那么这里的<code>func2</code>为什么可以通过编译？更痛苦的是我还无法传参。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 这里 martix 类型等价为 int(*)[columns]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> columns, <span class="hljs-type">int</span> matrix[rows][columns])</span> </span>&#123;<br>    cout &lt;&lt; matrix[rows<span class="hljs-number">-1</span>][columns<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>后来我在stackoverflow上提了这个问题（结果标记为 <em>模板参数自动推导</em> 的问题，但我感觉还是不太一样），有人回复我说，这种函数定义方式在C里面是有效的，但在C++里是不合法，所以这不是如何传参的问题，而是这样的写法在C++标准里是不允许的。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[stackoverflow上的提问](https://stackoverflow.com/questions/71303527/how-to-pass-parameters-to-this-function-void-funcint-rows-int-columns-int-m)">[2]</span></a></sup>虽然感觉还是没说明白为什么编译可行，但是姑且认为是C++标准不允许这样的写法，所以导致没法传参。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>最后总结一下，二维数组是不能直接赋值给二级指针的，二维数组对应的指针类型是一个数组指针，下面表格给出数组和指针的参数匹配。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[C/C++二维数组名和二级指针](https://www.cnblogs.com/fuao2000/p/11005671.html)">[3]</span></a></sup></p><table><thead><tr><th align="left">实参</th><th>例子</th><th>所匹配的形参</th></tr></thead><tbody><tr><td align="left">二维数组</td><td>char c[4][3]</td><td>char (*c)[3]</td></tr><tr><td align="left">指针数组</td><td>char * c[4]</td><td>char ** c</td></tr><tr><td align="left">数组指针</td><td>char (*c)[3]</td><td>char (*c)[3]</td></tr><tr><td align="left">二级指针</td><td>char ** c</td><td>char ** c</td></tr></tbody></table><p>然后再给出几种正确的传递二维数组的姿势。</p><h2 id="1-形参使用二级指针"><a href="#1-形参使用二级指针" class="headerlink" title="1.形参使用二级指针"></a>1.形参使用二级指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> **matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> columns)</span> </span>&#123;<br>    cout &lt;&lt; matrix[rows - <span class="hljs-number">1</span>][columns - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> rows = <span class="hljs-number">2</span>, columns = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> **matrix = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> *[rows];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        matrix[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[columns];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; columns; j++) &#123;<br>            matrix[i][j] = i * columns + j + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">func</span>(matrix,rows, columns);<br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;rows;i++) &#123;<br>        <span class="hljs-keyword">delete</span>[] matrix[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] matrix;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-形参使用一级指针"><a href="#2-形参使用一级指针" class="headerlink" title="2.形参使用一级指针"></a>2.形参使用一级指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> columns)</span> </span>&#123;<br>    cout &lt;&lt; matrix[(rows - <span class="hljs-number">1</span>) * columns + (columns - <span class="hljs-number">1</span>)];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows = <span class="hljs-number">2</span>, columns = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> *matrix = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[rows * columns];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; columns; j++) &#123;<br>            matrix[i * columns + j] = i * columns + j + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">func</span>(matrix, rows, columns);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-形参使用数组指针"><a href="#3-形参使用数组指针" class="headerlink" title="3.形参使用数组指针"></a>3.形参使用数组指针</h2><p>采用这种方式，需要形参指定二维数组的列数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// columns = 2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> (*matrix)[<span class="hljs-number">2</span>], <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> columns)</span> </span>&#123;<br>    cout &lt;&lt; matrix[rows<span class="hljs-number">-1</span>][columns<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows = <span class="hljs-number">2</span>, columns = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> matrix[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-built_in">func</span>(matrix, rows, columns);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-形参使用指针数组"><a href="#4-形参使用指针数组" class="headerlink" title="4.形参使用指针数组"></a>4.形参使用指针数组</h2><p>采用这种方式，需要形参指定二维数组的行数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// rows = 3</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>* matrix[<span class="hljs-number">3</span>], <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> columns)</span> </span>&#123;<br>    cout &lt;&lt; matrix[rows - <span class="hljs-number">1</span>][columns - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows = <span class="hljs-number">3</span>, columns = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> *matrix[rows];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        matrix[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[columns];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; columns; j++) &#123;<br>            matrix[i][j] = i * columns + j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">func</span>(matrix, rows, columns);<br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        <span class="hljs-keyword">delete</span>[] matrix[i];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="5-形参使用-vector-容器"><a href="#5-形参使用-vector-容器" class="headerlink" title="5.形参使用 vector 容器"></a>5.形参使用 vector 容器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> columns)</span> </span>&#123;<br>    cout &lt;&lt; matrix[rows - <span class="hljs-number">1</span>][columns - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows = <span class="hljs-number">3</span>, columns = <span class="hljs-number">2</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrix</span>(rows);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;columns;j++) &#123;<br>            matrix[i].<span class="hljs-built_in">push_back</span>(i * columns + j + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">func</span>(matrix, rows, columns);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202203012140651.jpeg"></p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/oddcat/p/9701518.html">C&#x2F;C++——二维数组与指针、指针数组、数组指针（行指针）、二级指针的用法 </a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://stackoverflow.com/questions/71303527/how-to-pass-parameters-to-this-function-void-funcint-rows-int-columns-int-m">stackoverflow上的提问</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.cnblogs.com/fuao2000/p/11005671.html">C&#x2F;C++二维数组名和二级指针</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多即是少，少即是多</title>
    <link href="/2022/02/21/2022-02/2022-02-21%20%E5%A4%9A%E5%8D%B3%E6%98%AF%E5%B0%91%EF%BC%8C%E5%B0%91%E5%8D%B3%E6%98%AF%E5%A4%9A/"/>
    <url>/2022/02/21/2022-02/2022-02-21%20%E5%A4%9A%E5%8D%B3%E6%98%AF%E5%B0%91%EF%BC%8C%E5%B0%91%E5%8D%B3%E6%98%AF%E5%A4%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这几天一直在折腾obsidian这款笔记软件，看相关视频，学习有关用法，广阔的主题和不计其数的插件令我烟花缭乱，完全被绚丽的界面配置所吸引。</p><p>但是等我冷静下来之后，扪心自问，自己真的需要这么深入学习使用obsidian吗？我决定接触使用obsidian的初心是什么？我的真实需求到底是什么？这样理清自己的思路后，或许就会豁然开朗了。</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>其实我的需求很简单，就是想要找一个地方可以记录我的财务状况。此前我的主要笔记软件用的是飞书，但因为飞书需要联网，且数据存储在别人的服务器上，所以一些个人私密数据就不好写在上面，所以就需要一款本地的文本编辑软件。</p><p>然后就通过公众号等渠道，就了解到了obsidian这款笔记软件，相比 typora 来说具有更多的插件和更高的自由度。而此前我写博客用的就是 typora 来编辑撰写，所以就想着能不能改成用 obsidian，这样可以尝试去学习使用炫酷的插件了（还是追求花里胡哨的心理啊），甚至之后可以取代飞书。</p><p>但是现在我发现，其实当下尝试去深度学习使用obsidian并没有太大必要：一来我最初的需求很简单，只是想在本地记录点财务信息；二来如果使用obsidian取代typora来写博客，其实我还是没法用上obsidian里最关键的双链功能，因为博客渲染的时候无法支持；三来如果用obsidian取代飞书做笔记，成本比较高，想要把obsidian打造成现在飞书这样子需要花费的精力和时间可太大了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上所述，其实我大可不必去深入学习obsidian，去学各种插件，打造一个完美的写作系统，毕竟已经有一个比较完备的软件在使用了，也没有特别的需求，有这个时间精力还不如去做当下优先级更高的事情，学习更多实际性的知识内容。</p><p>这件事让我联想到今天老师课上讲的话，“<strong>多即是少，少即是多</strong>”。在当下信息爆炸的时代，我们会接触到很多纷繁复杂的事物，我们或许会被表象所迷惑，而忘记自己真实的需求。当太多的选择摆在面前，反而无法决定，认为还是太少，还想追求更多更好。但其实只要掌握关键的几个技术、软件，就足以解决大多数问题和需求。</p><p>最关键的还是要明确自己的需求和想法，然后以此为出发点寻找合适的解决方法。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【漂流少年】青春的意义在于成长</title>
    <link href="/2022/02/19/2022-02/2022-02-19%20%E3%80%90%E6%BC%82%E6%B5%81%E5%B0%91%E5%B9%B4%E3%80%91%E9%9D%92%E6%98%A5%E7%9A%84%E6%84%8F%E4%B9%89%E5%9C%A8%E4%BA%8E%E6%88%90%E9%95%BF/"/>
    <url>/2022/02/19/2022-02/2022-02-19%20%E3%80%90%E6%BC%82%E6%B5%81%E5%B0%91%E5%B9%B4%E3%80%91%E9%9D%92%E6%98%A5%E7%9A%84%E6%84%8F%E4%B9%89%E5%9C%A8%E4%BA%8E%E6%88%90%E9%95%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前就听闻《漂流少年》这部番评价很高，就一直想找机会补了，恰好这段寒假时间里有空，就一次性刷完了。当时看完的确是心田里涌出了些什么，但可惜的是没有及时记录下来，现在回过头来，想要说些什么，却又无从说起了。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202201047171.png"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202201048916.png"></p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>《漂流少年》讲述了一个班级的中学生突然来到了奇妙的异次元世界，每个人获得了不同的超能力，为了回到现实世界，学生们做了各种尝试和努力，期间也发生了很多事件，最终只有主角长良和瑞穗回到了现实世界。</p><p>《漂流少年》是一部群像番，将班级里每个学生的个性刻画得很鲜明，很有特点，当卷入奇怪的事件中，漂流到异世界，每个人都有着各自的态度和表现。而历经众多事件后，每个人也都走上了不同的道路。</p><p>其中令我印象最深的就是主角的成长变化了（当然还有元气少女希和傲娇的瑞穗，笑），主角长良从一开始的消极避世，认为自己不重要，什么都不想做，到最后变得坚定不移，竭尽全力回到现实，这一成长过程令人侧目。或许是从长良身上看到了自己，那个妄自菲薄，胆小懦弱的自己，所以为长良的成长变化而喜悦动容，因为在我心底的某处，也一直希望自己能够做出改变，改正恶习，一扫颓废怠惰之风，变得坚定自信，勇往直前。</p><p>番剧里还讲述了很多故事，我认为很像是青春成长路上遇到的种种，有挫折有磨难，有黑暗有死亡，但也有恋情友情，有勇气有坚韧，有自信元气、傲娇善良的少女，有不断成长、自我救赎的少年，这一切共同交织的事物，组成了我们的青春。</p><p>最后故事的结尾，长良和瑞穗回到了希还活着的现实世界（但已经不是原来的世界了），一切都归于平淡，仿佛之前的那场漂流之旅未曾发生过，长良也回到了平静的生活之中。没有想象中的终成眷属，没有想象中的轰轰烈烈，但的确有什么发生了变化，长良成长了，不再是消极生活，而是能够抬起胸膛自信地走下去。作为观众的我来说，故事的结局并没有事事如愿，但这就是生活不是吗？</p><p>这是一场名为”成长“的青春漂流之旅。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>于我而言， 我不知道自己的青春何时开始，更无从谈起何时结束，我想自身或许还没经历过成长的阵痛，我还是带有孩子般的天真和稚气，不具有我这个年龄应有的成熟和坚毅。我想，我是渴望成长的，也希望自己变得负责任有担当，但总是缺乏实际行动。或许改变是有的，但还是太小，还是太慢，还是不满足。嘛，或许也不能操之过急。</p><p>你可以很菜，但你不能一直菜。</p><p>你可以天真，但你不能一直天真。</p><p>你可以逃避，但你不能一直逃避。</p><p class='note note-primary'>  <font size='4'>人生就是永无止境的徒劳，但正是因为一切皆无意义，所以「活着」的这个瞬间，这个光芒才会无比珍贵，因为那个瞬间是只属于那个人自己的。</font></p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202201025436.png" alt="" style="zoom: 50%;" /></center>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
      <category>动漫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漂流少年</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB调试学习</title>
    <link href="/2022/02/16/2022-02/2022-02-16%20GDB%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/02/16/2022-02/2022-02-16%20GDB%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>GDB是一个由GNU开源组织发布的、UNIX &#x2F; LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c&#x2F;c++程序员，gdb是必不可少的工具。标准的 GDB 是纯命令行式的，但也有一些基于它的图形化工具（比如 DDD、Data Display Debugger），但用好 GDB 命令行调试，还是我们的一项基本素质。</p><p><strong>GDB 不仅是一个调试工具，它也是一个学习源码的好工具。</strong>单纯的源码是静态的，虽然你可以分析它的整体架构，在头脑里模拟出它的工作流程，但计算机实在是太复杂了，内外部环境因素很多，仅靠“人肉分析”很难完全理解它的逻辑。这个时候，GDB 就派上用场了，以调试模式启动，任意设定外部条件，从指定的入口运行，把程序放慢几万倍，细致地观察每个变量的值，跟踪代码的分支和数据的流向，这样走上几个来回之后，再结合源码，就能够对程序的整体情况“了然于胸”。</p><p>本篇文章将简单地介绍 GDB 常见用法，更多内容可以参考下面的文章：</p><ul><li><a href="https://blog.csdn.net/niyaozuozuihao/article/details/91802994">linux下gdb调试方法与技巧整理</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[linux下gdb调试方法与技巧整理](https://blog.csdn.net/niyaozuozuihao/article/details/91802994)">[1]</span></a></sup></li><li><a href="https://github.com/hellogcc/100-gdb-tips">《100个gdb小技巧》</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[《100个gdb小技巧》](https://github.com/hellogcc/100-gdb-tips)">[2]</span></a></sup> (强烈推荐)</li></ul><h1 id="GDB使用流程"><a href="#GDB使用流程" class="headerlink" title="GDB使用流程"></a>GDB使用流程</h1><h2 id="1-启动GDB调试"><a href="#1-启动GDB调试" class="headerlink" title="1.启动GDB调试"></a>1.启动GDB调试</h2><p>测试程序源代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> x_2 = <span class="hljs-built_in">square</span>(x);<br>    <span class="hljs-keyword">return</span>  x_2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-built_in">get_num</span>(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>启动命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc test.cpp -o test # 编译源文件<br>gdb test<br>gdb -q test # -q 表示不打印gdb版本信息，界面较为干净；<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202160948610.png" alt="启动gdb"></p><h2 id="2-查看源码"><a href="#2-查看源码" class="headerlink" title="2.查看源码"></a>2.查看源码</h2><p>**list(简写 l)**： 查看源程序代码，默认显示10行，按回车键或继续输入<code>l</code>查看下10行。</p><p>效果如下所示：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202160951660.png" alt="list 查看源程序代码"></p><h2 id="3-运行程序"><a href="#3-运行程序" class="headerlink" title="3.运行程序"></a>3.运行程序</h2><p><strong>run(简写 r)</strong> ：运行程序直到遇到 结束或者遇到断点等待下一个命令；<br>效果如下所示（这里我没有设置断点，所以程序直接运行到结束）：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202160953401.png" alt="run 运行程序"></p><h2 id="4-设置断点"><a href="#4-设置断点" class="headerlink" title="4.设置断点"></a>4.设置断点</h2><p><strong>break(简写 b)</strong> ：命令格式 <code>b 行号</code>，在某行设置断点；<br><strong>info breakpoints</strong> (简写 <code>i b</code>) ：显示断点信息</p><ul><li>Num： 断点编号</li><li>Type：类型，breakpoint 或者 watchpoint</li><li>Disp：断点执行一次之后是否有效 kep：有效 dis：无效</li><li>Enb： 当前断点是否有效 y：有效 n：无效</li><li>Address：内存地址</li><li>What：位置</li></ul><p>演示效果如下：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202160957555.png" alt="b 设置断点"></p><h2 id="5-单步执行"><a href="#5-单步执行" class="headerlink" title="5.单步执行"></a>5.单步执行</h2><p>首先需要输入<code>run</code>启动程序，运行到第一个断点处，然后可以选择<code>step</code>单步调试（如果有函数调用则进入函数），<code>next</code>单步跟踪程序（遇到函数调用，直接调用函数，不会进入函数体内），<code>continue</code>继续运行到下一个断点处。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202161026973.png" alt="执行程序"></p><hr><p>程序运行的相关命令如下：</p><ul><li><strong>run</strong>：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li><li><strong>continue</strong> （简写c ）：继续执行，到下一个断点处（或运行结束）</li><li><strong>next</strong>：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li><li><strong>step</strong> （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li><li><strong>until</strong>：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li><li><strong>until+行号</strong>： 运行至某行，不仅仅用来跳出循环</li><li><strong>finish</strong>： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li><li>**call 函数(参数)**：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li></ul><h2 id="6-查看变量"><a href="#6-查看变量" class="headerlink" title="6.查看变量"></a>6.查看变量</h2><ul><li>print ：打印变量或表达式的值</li><li>whatis ：查询变量或函数</li><li>pt ：跟whatis作用类似</li><li>display：在单步调试的时候很有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。<ul><li>可以通过info dispaly，查看当前被设置的变量，然后可以用undisplay num（变量对应的编号）取消设置</li></ul></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202161039792.png" alt="查看变量"></p><h2 id="7-退出GDB"><a href="#7-退出GDB" class="headerlink" title="7.退出GDB"></a>7.退出GDB</h2><p>使用<code>quit</code>命令退出即可。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202161041935.png" alt="退出gdb"></p><h1 id="GDB常用命令"><a href="#GDB常用命令" class="headerlink" title="GDB常用命令"></a>GDB常用命令</h1><p>下面列出最常用的GDB命令：</p><ul><li>pt：查看变量的真实类型，不受 typedef 的影响。</li><li>bt：显示当前调用堆栈。</li><li>up&#x2F;down：在函数调用栈里上下移动。或者使用<code>frame 函数帧号</code>跳转。</li><li>fin：直接运行到函数结束。</li><li>i b：查看所有的断点信息。</li><li>i locals：查看当前堆栈页的所有变量。</li><li>wh：启动“可视化调试”。这个是我最喜欢的命令，可以把屏幕分成上下两个窗口，上面显示源码，下面是 GDB 命令输出，不必再用“l”频繁地列出源码了，能够大大提高调试的效率。<ul><li>ctrl x + a ：退出或进入可视化模式</li></ul></li><li>layout regs：显示源代码&#x2F;汇编和寄存器窗口</li><li>layout split：显示源代码和汇编窗口</li></ul><h1 id="分析CoreDump"><a href="#分析CoreDump" class="headerlink" title="分析CoreDump"></a>分析CoreDump</h1><p>在真实生产环境中，程序可能会崩溃而产生CoreDump文件，此时我们通常就需要用gdb来调试CoreDump文件，分析程序崩溃的原因。</p><p>接下来，来模拟这一过程。首先需要修改下源代码，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> x_2 = <span class="hljs-built_in">square</span>(x);<br>    <span class="hljs-keyword">return</span>  x_2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-built_in">get_num</span>(a);<br>    <span class="hljs-type">int</span>* p = <span class="hljs-literal">NULL</span>;<br>    *p = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后编译生成新的二进制文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -g test.cpp -o test6<br></code></pre></td></tr></table></figure><p>然后需要修改下配置<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[让程序崩溃后生成Core Dump](https://www.cnblogs.com/chingliu/archive/2011/07/25/2223815.html)">[3]</span></a></sup>，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">作用是让程序崩溃是产生的core dump文件大小没有限制，默认是0表示不生成core dump文件</span><br>ulimit -c unlimited<br></code></pre></td></tr></table></figure><p>然后执行修改后的程序，发生段错误：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202161515053.png" alt="程序崩溃发生段错误"></p><p>但奇怪的是，并没有生成core文件，明明我已经修改了ulimit。后来几经波折，发现了原因，参考<a href="https://baijiahao.baidu.com/s?id=1599347824327158577&wfr=spider&for=pc">在Linux上利用core dump和GDB调试segfault</a><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[在Linux上利用core dump和GDB调试segfault](https://baijiahao.baidu.com/s?id=1599347824327158577&wfr=spider&for=pc)">[4]</span></a></sup>。简单来说，就是Ubuntu默认忽略非Ubuntu软件包的二进制文件的崩溃日志，也就不会产生core dump文件。调整的做法也比较简单，就是重新设置kernel.core_pattern的值（该值表示core dump文件的输出目录），执行下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sysctl -w kernel.core_pattern=/tmp/core/core-%e.%p.%h.%t<br></code></pre></td></tr></table></figure><p>现在再执行之前的程序，就可以在对应目录下生成core dump文件，并可以用gdb来进行调试分析，如下图所示，可以看到出错原因在源代码的第15行，对一个空指针赋值：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202161511784.png" alt="调试core文件"></p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/niyaozuozuihao/article/details/91802994">linux下gdb调试方法与技巧整理</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://github.com/hellogcc/100-gdb-tips">《100个gdb小技巧》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.cnblogs.com/chingliu/archive/2011/07/25/2223815.html">让程序崩溃后生成Core Dump</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://baijiahao.baidu.com/s?id=1599347824327158577&wfr=spider&for=pc">在Linux上利用core dump和GDB调试segfault</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【骚操作】MacOS上自动压缩截图</title>
    <link href="/2022/02/15/2022-02/2022-02-15%20%E3%80%90%E9%AA%9A%E6%93%8D%E4%BD%9C%E3%80%91MacOS%E4%B8%8A%E8%87%AA%E5%8A%A8%E5%8E%8B%E7%BC%A9%E6%88%AA%E5%9B%BE/"/>
    <url>/2022/02/15/2022-02/2022-02-15%20%E3%80%90%E9%AA%9A%E6%93%8D%E4%BD%9C%E3%80%91MacOS%E4%B8%8A%E8%87%AA%E5%8A%A8%E5%8E%8B%E7%BC%A9%E6%88%AA%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前写博客一直是用 picgo + github 作为 typora的图床，但是有时候网不太行，图片显示得很慢。所以后来换了 gitee 作为图床，但是发现仍然有时候图片无法显示，但是通过浏览器的URL访问没有问题，这就让我很疑惑，后来查阅资料发现，gitee 居然不支持 1M 以上图片的查看<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[记一次css文件引起的跨域问题（gitee图片超过1M需要登录查看)](https://www.cnblogs.com/xsyz/p/14043564.html) ↩">[1]</span></a></sup>，这可太坑了。</p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202152050052.jpeg" alt="惊了" style="zoom: 25%;" /></center><p>然后我就想着能不能做到自动压缩截图大小，来实现曲线救国，通过查阅网上资料，还真让我找到了方法。</p><h1 id="自动压缩截图"><a href="#自动压缩截图" class="headerlink" title="自动压缩截图"></a>自动压缩截图</h1><p>实现方法参考这篇文章：<a href="https://depp.wang/2020/08/07/how-to-automatically-compress-screenshot-size-in-macos/">在 macOS 中，如何自动压缩截屏图片大小</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[在 macOS 中，如何自动压缩截屏图片大小](https://depp.wang/2020/08/07/how-to-automatically-compress-screenshot-size-in-macos/)">[2]</span></a></sup>，里面写得很详细了，我这里就简单地描述下实现原理，并演示实际效果。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>我们都知道有一些办法能够调整图片大小，比如利用MacOS上的预览，对图片进行导出，就可以实现压缩图片大小。还可以通过其他软件，或者命令行工具（例如pngquant，ImageMagick）来压缩图片。但是上面如果手动操作就有点繁琐了， 所以关键在于如何实现“<strong>自动</strong>”的效果。</p><p>提到“自动”，那么自然就需要自动的工作流软件了，也就是 Hazel 或者  Automator，利用工作流软件，来自动地对截图进行压缩。完整流程如下：</p><ol><li>将截图保存到一个目录中；</li><li>利用 Hazel 或者 Automator 工作流软件，自动触发脚本；</li><li>在脚本中，使用命令行工具对截图进行压缩并保存；</li><li>将压缩后的图片复制到剪贴板（也是利用脚本完成）；</li><li>屏幕通知图片压缩完成；</li><li>（可选）将压缩后的图片删除。</li></ol><h2 id="实际演示"><a href="#实际演示" class="headerlink" title="实际演示"></a>实际演示</h2><p>接下来我将演示如何配置 Hazel ，Automator 可以参考上面博文的内容。</p><ol><li>首先选择一个文件夹，作为存放截图的目录。<center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202152110926.png" alt="选择截图目录" style="zoom: 50%;" /></center></li><li>然后添加规则<center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202152112016.png" alt="添加规则" style="zoom:50%;" /></center></li><li>配置规则，如下图所示</li></ol><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202152113647.png" alt="配置规则"></p><ol start="4"><li>具体脚本内容如下所示：</li></ol><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202152115294.png" alt="压缩图片并复制到剪贴板"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pngquant 128 --skip-if-larger --strip --ext=.png --force &quot;$1&quot;<br>osascript -e &quot;set the clipboard to (read (POSIX file \&quot;$(perl -e &quot;print glob(&#x27;$1&#x27;)&quot;)\&quot;) as &#123;«class PNGf»&#125;)&quot;<br></code></pre></td></tr></table></figure><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202152116588.png" alt="屏幕提示"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">The compressed image `file` has been copied to the clipboard.<br></code></pre></td></tr></table></figure><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202152116561.png" alt="删除截图"></p><p>最后删除截图是可选的，因为在typora里图片复制后自动上传，所以我就设置了删除截图。</p><hr><p>至此就实现了自动压缩截图的效果，只要每次截图的时候保存到设置的目录，就会自动压缩图片，并复制到剪贴板，等屏幕提示“压缩已完成”后，我直接在 typora 里粘贴图片即可，又可以愉快地写博客喽~</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202152126405.jpeg"></p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/xsyz/p/14043564.html">记一次css文件引起的跨域问题（gitee图片超过1M需要登录查看)</a> ↩<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://depp.wang/2020/08/07/how-to-automatically-compress-screenshot-size-in-macos/">在 macOS 中，如何自动压缩截屏图片大小</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>骚操作系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【99%环境搭建系列】阿里云服务器配置Hexo博客</title>
    <link href="/2022/02/13/2022-02/2022-02-13%20%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEHexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/02/13/2022-02/2022-02-13%20%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEHexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个环境搭建系列好久没更了，所以趁此机会难得填坑一下。</p><p>之前一直白嫖是Github pages来部署自己的博客，然后觉得还是有一个自己的服务器更好一点，还能学习相关知识。所以趁还没回学校，把自己的博客部署到自己的服务器上，毕竟之前购买的域名一直没用上，甚是心痛啊。</p><p>这次我是在阿里云上买的服务器，主要是因为之前在阿里云上买的域名，所以这次搭建的过程就用阿里云进行说明。</p><h1 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h1><p>这里以阿里云的服务器来举例。</p><p>通常创建好服务器实例后，在重置一下实例的密码，就可以用root用户进行ssh连接了。使用root用户登录后，我这里是新建了一个用户，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">新建用户</span><br>adduser zyx<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置密码</span><br>passwd zyx<br></code></pre></td></tr></table></figure><p>然后赋予<code>zyx</code>用户root权限，具体做法是编辑<code>/etc/sudoers</code>，在root用户下方添加新增的用户名，如下所示。</p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202131602517.png" alt="image-20220213160236426" style="zoom: 67%;" /></center><h1 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h1><p>在本地创建密钥，使用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>然后一直回车，创建一个密钥。因为我是mac系统，生成的密钥文件位置在<code>~/.ssh/id_rsa.pub</code></p><p>然后回到服务器端，创建<code>.ssh</code>目录（在当前用户的~ 目录下即可），并编辑文件<code>.ssh/authorized_keys</code>，复制粘贴刚刚在本地创建好的密钥。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim .ssh/authorized_keys<br></code></pre></td></tr></table></figure><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><p>首先需要安装配置一下开发相关的软件环境了，使用的命令如下<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[hexo本地博客部署到云服务器](https://www.yyyzyyyz.cn/posts/45dafe31d273/)">[1]</span></a></sup>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更新下载源</span><br>sudo apt-get update<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 git</span><br>sudo apt install git<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 vim</span><br>sudo apt install vim<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 node.js</span><br>sudo apt install nodejs<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 nginx</span><br>sudo apt install nginx<br></code></pre></td></tr></table></figure><p>这里安装完 nginx ，开启 nginx 服务并确认服务状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动 nginx</span><br>systemctl start nginx.service<br><br><span class="hljs-comment"># 查看nginx服务状态，绿色的active说明启动成功</span><br>systemctl status nginx.service<br></code></pre></td></tr></table></figure><p>此时访问公网 IP 应该能看到如下的欢迎页：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312191605179.png" alt="nginx欢迎页"></p><p>然后再创建网站目录和远程仓库目录，使用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建网站目录，以这个目录作为博客静态文件的存放目录，之后再nginx配置文件里会用到</span><br>mkdir /home/zyx/hexo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建服务器上的远程仓库目录</span><br>git init --bare blog.git<br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建钩子文件</span><br>vim /home/zyx/blog.git/hooks/post-receive<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">---------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">把如下内容粘贴进去</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>git --work-tree=/home/zyx/hexo --git-dir=/home/zyx/blog.git checkout -f<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后给这个脚本添加执行权限，否则后面博客内容无法进行部署</span><br>chmod +x /home/zyx/blog.git/hooks/post-receive<br></code></pre></td></tr></table></figure><blockquote><p>注意上面创建远程仓库的命令，这里加了<code>--bare</code>参数，表示创建的是一个裸仓库，含义是这个仓库只保存git历史提交的版本信息，而不允许用户在上面进行各种git操作。</p></blockquote><h1 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h1><p>在安装完nginx并启动服务后，在浏览器中直接访问服务器的公网ip是可以看到nginx的欢迎页的。但是在实际操作中却发现，无法访问。后来发现是没有开放端口，所以我们需要在ECS云服务器的控制台中，在”<strong>网络与安全</strong>“中的”<strong>安全组</strong>“中，选择对应的安全组，选择”<strong>配置规则</strong>“，开放80（http）和443（https）端口。最终效果如下所示，此时再访问公网ip，就可以看到nginx的欢迎页的。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202131917400.png" alt="域名解析添加记录"></p><h1 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h1><p>在阿里云中，搜索”SSL证书“产品，选购免费的“DV单域名证书”，然后在控制台里创建证书，填上自己购买的域名和相关信息即可。签发成功后，就可以下载证书。</p><p>因为之后使用nginx进行配置，所以我这里下载的也就是nginx对应的证书。下载后会得到一个zip压缩包，解压后得到 <em>.key</em> 和 <em>.pem</em> 结尾的两个文件。</p><p>在nginx的安装目录（就是nginx.conf所在的目录，不知道的话可以通过<code>nginx -t</code>来查看配置文件所在目录）下，新建一个 <em>cert</em> 目录，将下载的两个证书文件放到 <em>cert</em> 目录下。</p><p>然后修改 <strong>nginx.conf</strong> 配置文件，添加如下配置<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[在Nginx（或Tengine）服务器上安装证书](https://help.aliyun.com/document_detail/98728.html?spm=5176.b657008.help.dexternal.7891799dpSS9Ed)">[2]</span></a></sup>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">server</span> &#123;<br>    <span class="hljs-string">listen</span> <span class="hljs-number">80</span><span class="hljs-string">;</span><br>    <span class="hljs-string">server_name</span> <span class="hljs-string">yourdomain.com;</span> <span class="hljs-comment">#需要将yourdomain.com替换成证书绑定的域名，或者是域名的用为IP</span><br>    <span class="hljs-string">root</span> <span class="hljs-string">/home/zyx/hexo;</span><span class="hljs-comment">#改成博客目录</span><br>    <span class="hljs-string">rewrite</span> <span class="hljs-string">^(.*)$</span> <span class="hljs-string">https://$host$1;</span> <span class="hljs-comment">#将所有HTTP请求通过rewrite指令重定向到HTTPS。</span><br>    <span class="hljs-string">location</span> <span class="hljs-string">/</span> &#123;<br>        <span class="hljs-string">index</span> <span class="hljs-string">index.html</span> <span class="hljs-string">index.htm;</span><br>    &#125;<br>&#125;<br><span class="hljs-string">server</span> &#123;<br>    <span class="hljs-comment">#如果您使用Nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。</span><br>    <span class="hljs-string">listen</span> <span class="hljs-number">443</span> <span class="hljs-string">ssl;</span><br>    <span class="hljs-string">server_name</span> <span class="hljs-string">yourdomain.com;</span> <span class="hljs-comment">#需要将yourdomain.com替换成证书绑定的域名。</span><br><span class="hljs-string">root</span> <span class="hljs-string">/home/zyx/hexo;</span><span class="hljs-comment">#改成博客目录</span><br>    <span class="hljs-string">index</span> <span class="hljs-string">index.html</span> <span class="hljs-string">index.htm;</span><br>    <span class="hljs-string">ssl_certificate</span> <span class="hljs-string">cert/cert-file-name.pem;</span>   <span class="hljs-comment">#需要将cert-file-name.pem替换成已上传的证书文件的名称。</span><br>    <span class="hljs-string">ssl_certificate_key</span> <span class="hljs-string">cert/cert-file-name.key;</span>   <span class="hljs-comment">#需要将cert-file-name.key替换已上传的证书私钥文件的名称。</span><br>    <span class="hljs-string">ssl_session_timeout</span> <span class="hljs-string">5m;</span><br>    <span class="hljs-string">ssl_ciphers</span> <span class="hljs-string">ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br>    <span class="hljs-string">ssl_protocols</span> <span class="hljs-string">TLSv1.1</span> <span class="hljs-string">TLSv1.2</span> <span class="hljs-string">TLSv1.3;</span><br>    <span class="hljs-string">ssl_prefer_server_ciphers</span> <span class="hljs-string">on;</span><br>    <span class="hljs-string">location</span> <span class="hljs-string">/</span> &#123;<br>        <span class="hljs-string">index</span> <span class="hljs-string">index.html</span> <span class="hljs-string">index.htm;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="网站备案"><a href="#网站备案" class="headerlink" title="网站备案"></a>网站备案</h1><h2 id="ICP备案"><a href="#ICP备案" class="headerlink" title="ICP备案"></a>ICP备案</h2><p>在右上角控制台旁边，有个“ICP备案”按钮，点击这里进行网站的ICP备案，按照相关流程操作即可<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[阿里云-ICP备案指导](https://help.aliyun.com/document_detail/36921.html0)">[3]</span></a></sup>。备案时间最好在工作日，大概需要一天时间。还有一个注意点是，备案用的服务器拥有时长必须<strong>满3个月</strong>以上，否则是无法用于网站备案的，也就是说免费申请的服务器是不能拿来做备案的。（白嫖党落泪QAQ）</p><p>只有域名ICP备案之后，才能通过域名访问网站，否则只能通过公网ip进行访问。<strong>还要记得在域名解析的控制台里，给自己购买的域名添加记录。</strong></p><p class='note note-info'>注意这里不用通过搜索“网站备案”来找，会把你导向眼花缭乱的云市场，属实没有必要。并且备案成功之后，注意要在自己的网站页面上增加备案的脚注。</p><h2 id="公安联网备案"><a href="#公安联网备案" class="headerlink" title="公安联网备案"></a>公安联网备案</h2><p>除了工信部的ICP备案，还需要进行<a href="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202211449323.png">公安联网备案</a>，同样按照阿里云的指导文档进行操作即可<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[阿里云-公安联网备案](https://help.aliyun.com/document_detail/116029.html)">[4]</span></a></sup>。注意在选择服务类型时，不要选择”博客网站“，选择”www服务“即可，不然可能又需要等待下次审核审核。</p><p>再补充一下，还需要上传安全评估报告，也就是下图的左侧登录入口。其中填报安全评估报告的内容可以参考<a href="https://wenku.baidu.com/view/17e55c62951ea76e58fafab069dc5022aaea46e6.html">安全网络报告中的问题及参考解答</a>。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202211451504.png" alt="全国互联网安全管理服平台"></p><p class='note note-info'>  注意一下，公安联网备案是需要本人现场到本地的网警部门审核签字的，所以最好在当地留出充裕的时间。我的一个惨痛教训就是临近开学的时候申请，结果人去学校了，所以就不能在本地这边办理了。<br>  幸运的是北京这边似乎网上办理就可以了。也就是ICP备案和公安联网备案可以是不同省份，但各个地方会有自己的要求。</p><h1 id="Hexo站点配置修改"><a href="#Hexo站点配置修改" class="headerlink" title="Hexo站点配置修改"></a>Hexo站点配置修改</h1><p>最后修改本地hexo博客所在目录下的站点配置文件，也就是**_config.yml**，填入之前在服务器上创建的git仓库地址。最终执行<code>hexo clean &amp; hexo g &amp; hexo d </code>命令，就可以将静态文件代码部署到服务器上了，就可以通过域名或者ip进行访问，看到部署好的博客页面。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> [<span class="hljs-string">username</span>]<span class="hljs-string">@100.0.0.100:/home/git/blog.git</span>   <span class="hljs-comment">#用户名@服务器Ip:git仓库位置</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br><br></code></pre></td></tr></table></figure><h1 id="问题踩坑"><a href="#问题踩坑" class="headerlink" title="问题踩坑"></a>问题踩坑</h1><p>最后再说个我后来迁移博客的时候踩的坑，就是上述准备工作就绪后，在本地执行命令<code>hexo d</code> 进行部署，然后访问公网 ip 结果报错 403 Forbidden，这个报错是主要权限配置错误，即 nginx服务器中的目录和文件可能会出现所有者&#x2F;组的错误，导致访问权限错误，可能的原因就是 nginx 的启动用户和对应目录的用户不一致，我就是犯了这个错，<strong>在 <code>nginx.conf</code> 文件配置里的 <code>user</code> 一项配置要改成和博客根目录所属的用户一致</strong>。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202312201727218.png"></p><p>除此之外，如果发现执行 <code>hexo d</code> 命令后，服务器上的博客根目录下并没有生成博客网站文件，很可能是之前 git 的钩子文件没有加上写权限。</p><h1 id="附录：Nginx常用命令"><a href="#附录：Nginx常用命令" class="headerlink" title="附录：Nginx常用命令"></a>附录：Nginx常用命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">停止开机自启动</span><br>systemctl disable nginx.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置nginx服务开机自启动</span><br>systemctl enable nginx.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动nginx服务</span><br>systemctl start nginx.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">停止nginx服务</span><br>systemctl stop nginx.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重启nginx服务</span><br>systemctl restart nginx.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重新读取nginx配置(这个最常用, 不用停止nginx服务就能使修改的配置生效)</span><br>systemctl reload nginx.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看服务当前状态</span><br>systemctl status nginx.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有已启动的服务</span><br>systemctl list-units --type=service<br></code></pre></td></tr></table></figure><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.yyyzyyyz.cn/posts/45dafe31d273/">hexo本地博客部署到云服务器</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://help.aliyun.com/document_detail/98728.html?spm=5176.b657008.help.dexternal.7891799dpSS9Ed">在Nginx（或Tengine）服务器上安装证书</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://help.aliyun.com/document_detail/36921.html0">阿里云-ICP备案指导</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://help.aliyun.com/document_detail/116029.html">阿里云-公安联网备案</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>环境搭建系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
      <tag>阿里云ECS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我还是什么都没有改变</title>
    <link href="/2022/02/12/2022-02/2022-02-12%20%E6%88%91%E8%BF%98%E6%98%AF%E4%BB%80%E4%B9%88%E9%83%BD%E6%B2%A1%E6%9C%89%E6%94%B9%E5%8F%98/"/>
    <url>/2022/02/12/2022-02/2022-02-12%20%E6%88%91%E8%BF%98%E6%98%AF%E4%BB%80%E4%B9%88%E9%83%BD%E6%B2%A1%E6%9C%89%E6%94%B9%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<p>又几乎颓废了一周，每天都在游戏中花费了大量时光，抛弃了目标，抛弃了理想，抛弃了所有，就像是溺水的人拼命地想要抓住什么，我也把游戏当作唯一的宣泄口。明明知道自己这样下去不行，明明罪恶感和内疚感不断朝我袭来，我却无法控制自己，每次告诉自己收手吧，却又径自坠入深渊。</p><p class='note note-danger'>  “你小子，真的是，真的是一点都没有改变啊！还是，什么都做不到啊！什么都...做不到”</p><p>是啊，从初中开始的每个假期，就从来没有按自己最初计划的那样度过，每次都是沉迷在游戏世界了，忘记时间，忘记自我，忘记身边的一切，自甘堕落，伤害自己，伤害身边的亲人，然后又每次在假期结束的时候，感到无尽的懊恼与悔恨，却又总是安慰自己，“没事的，大不了重新开始就好”，以此作为借口，给自己一个台阶下。可事实究竟如何呢？时光从来不能倒流，唯有时间，失去了就真正的失去了，这段失去的时光永远不会重来，而这段时光的价值我又得到了多少呢，我又能弥补多少呢？</p><p class='note note-danger'>  “我逐渐变成自己最厌恶的样子。”</p><p>或许一些东西，更直白地说，人的习性，根深蒂固的恶习，真的很难改正。但是就这样放弃了吗，因为失败太多次就放弃改变了吗？我，真的是这样软弱无能的人吗？</p><p>答案其实已经很明显了吧，我那燃烧的灵魂告诉我，不要畏惧失败，不要停下脚步，就算遍体鳞伤，就算一无所有，也要前进，也要战斗，也要证明给自己看，我到底是怎样的一个人！？</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202122109437.jpg" alt="有话直说，说到做到"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令行下性能分析</title>
    <link href="/2022/02/02/2022-02/2022-02-02%20Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2022/02/02/2022-02/2022-02-02%20Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>我根据我这些年的经验，挑选了四个“高性价比”的工具：top、pstack、strace 和 perf。它们用起来很简单，而且实用性很强，可以观测到程序的很多外部参数和内部函数调用，由内而外、由表及里地分析程序性能。</p><h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><p>通过top命令，就能够简单直观地看到 应用程序的CPU、内存等几个最关键的性能指标。下面这张图截自ubuntu20.04 虚拟机的top命令。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202041956057.png" alt="ubuntu中top命令截图"></p><p>其中个指标的含义可以参考自这篇博客<a href="https://blog.csdn.net/zhuoya_/article/details/81049967">top命令的用法</a> <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[top命令的用法](https://blog.csdn.net/zhuoya_/article/details/81049967)">[1]</span></a></sup>：</p><ul><li><p>Tasks一行：</p><ul><li><p>total : 进程总数</p></li><li><p>Running: 正在运行进程数</p></li><li><p>Sleeping: 睡眠的进程数</p></li><li><p>Stopped: 停止的进程数</p></li><li><p>zombie: 僵尸进程数</p></li></ul></li><li><p>Cpu一行：</p><ul><li>us：用户空间占用CPU的百分比</li><li>sy：内核空间占用CPU的百分比</li><li>ni：用户进程空间内改变过优先级的进程占用CPU百分比</li><li>id：空闲CPU百分比</li><li>wa：等待输入输出的CPU百分比</li><li>hi：硬中断占用CPU百分比</li><li>si：软中断占用CPU百分比</li><li>st：当hypervisor服务另一个虚拟处理器的时候，虚拟CPU等待实际CPU的百分比</li></ul></li></ul><p class='note note-info'>软中断是执行中断指令产生的，而硬中断是由外设引发的。</br>为了满足实时系统的要求，中断处理应该是越快越好。linux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断来完成。</p><ul><li>Mem为物理内存使用，Swap为交换区使用。</li><li>白色标注行：<ul><li><p>PID：进程ID</p></li><li><p>USER：进程所有者的用户ID</p></li><li><p>PR：priority，动态优先级，取值范围[0,99]，取值越小，优先级越高。priority的值在之前内核的O1调度器上表现是会变化的，所以叫做<strong>动态优先级</strong>。</p></li><li><p>NI：nice值，静态优先级。取值范围[-20,19]，取值越小，优先级越高。nice值设定好后，一般是不会改变的，除非使用系统调用进行修改，所以称为<strong>静态优先级</strong>。</p></li><li><p>VIRT：进程使用的虚拟内存的总量，VIRT &#x3D; SWAP + RES</p></li><li><p>RES：进程使用的、未被换出的物理内存大小，单位kb，RES &#x3D; CODE + DATA</p></li><li><p>SHR：共享内存，也会被统计在RES中。</p><ul><li><p>除了自身进程的共享内存，也包括其他进程的共享内存；</p></li><li><p>虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小；</p></li><li><p>计算某个进程所占的物理内存大小公式：RES – SHR；</p></li></ul></li><li><p>S：进程状态</p><ul><li>R：当前正在运行(RUNNING)</li><li>S：睡眠(SLEEP)</li><li>D：不可中断</li><li>T：停止(STOP)</li><li>Z：僵尸进程(ZOMBIE)</li></ul></li><li><p>%CPU：上次更新到现在的CPU时间占用百分比</p></li><li><p>%MEM：进程占用物理内存占比</p></li><li><p>TIME+：进程使用CPU时间总结</p></li><li><p>COMMAND：进程名称（命名名&#x2F;命令行）</p></li></ul></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202042034815.jpeg" alt="程序优先级描述"></p><h2 id="交互命令"><a href="#交互命令" class="headerlink" title="交互命令"></a>交互命令</h2><ul><li>按 <code>f</code> 键进入交互界面，此时按<code>d</code>可以显示或隐藏列，按<code>s</code>可以设置当前选中的列进行排序，默认为降序，可以按<code>R</code>进行升序（注意大写）。</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202042053474.png" alt="按 f 键进入交互界面"></p><ul><li>先按<code>-&gt;</code>右键表示选中该列，在按上下移动键，就可以调整列的显示顺序</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202042056414.png" alt="调整列的顺序"></p><ul><li><strong>h</strong>或者 **?**：显示帮助画面</li><li><strong>k</strong> :终止一个进程；默认使用15信号，可以使用信号9来强制结束该进程。但是在安全模式下此命令被屏蔽。</li><li><strong>t</strong>  ：切换显示进程和CPU状态信息。</li><li><strong>m</strong>  :切换显示内存信息。</li><li><strong>H</strong>：切换为线程查看模式</li><li><strong>i</strong> :忽略闲置和僵死进程，开关式命令。</li><li><strong>M</strong>  ：根据驻留内存大小进行排序。</li><li><strong>P</strong>  ：根据CPU使用百分比大小进行排序。</li><li><strong>T</strong>   ：根据时间或者累计时间进行排序。</li><li><strong>top -d 秒数</strong>：表示进程界面更新时间（默认5秒）</li><li><strong>top -p 1</strong> : 查看进程号为1的进程</li></ul><h1 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h1><p>从 top 的输出结果里，我们可以看到进程运行的概况，知道 CPU、内存的使用率。如果发现某个指标超出了预期，就说明程序可能存在问题，接下来，我们就应该采取更具体的措施去进一步分析，比如采用pstack。pstack 可以打印出进程的调用栈信息，有点像是给正在运行的进程拍了个快照，能看到某个时刻的进程里调用的函数和关系，对进程的运行有个初步的印象。</p><p>pstack其实是个Shell脚本，核心原理是GDB的<strong>thread apply all bt</strong>命令，基本逻辑是通过进程号process-id来分析是否使用了多线程，同时使用GDB Attach到在跑进程上，最后调用bt子命令后简单格式化输出<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Linux pstack 源码里的基础知识](https://cloud.tencent.com/developer/article/1005992)">[2]</span></a></sup>。</p><hr><p>编写一个测试程序如下，创建一个死循环线程，不停地睡眠1秒后输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleeptime</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>        cout &lt;&lt; <span class="hljs-string">&quot;sleep 1 s&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(sleeptime)</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译命令：<code>g++ -g -pthread test2.cpp -o test2</code>。</p><p>pstack命令：<code>sudo pstack $&#123;pid&#125;</code>这里的pid可通过top或者ps来找到。注意这里不加sudo可能不会打印输出。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202042256078.png" alt="pstack打印函数调用栈"></p><h1 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h1><p> <code>strace</code>是个功能强大的Linux调试分析诊断工具，可用于跟踪程序执行时进程系统调用(system call)和所接收的信号，尤其是针对源码不可读或源码无法再编译的程序。在Linux系统中，用户进程不能直接访问计算机硬件设备。当进程需要访问硬件设备(如读取磁盘文件或接收网络数据等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。<code>strace</code>可跟踪进程产生的系统调用，包括参数、返回值和执行所消耗的时间。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Linux进程照妖镜strace命令](https://zhuanlan.zhihu.com/p/69527356)">[3]</span></a></sup></p><p>参考知乎这篇文章<a href="https://zhuanlan.zhihu.com/p/69527356">Linux进程照妖镜strace命令</a>，演示下 strace 命令作用。</p><p>首先编写一个测试程序，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];<br>  <br>  <span class="hljs-comment">// 获取当前工作目录的绝对路径</span><br>    <span class="hljs-built_in">getcwd</span>(buffer, <span class="hljs-number">255</span>);<br><br>    <span class="hljs-built_in">printf</span>(buffer);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后执行下列命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编译</span><br>gcc test3.cpp -o test3<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用strace 追踪 test3程序</span><br>strace ./test3<br></code></pre></td></tr></table></figure><p>就可以看到程序产生的系统调用：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202151120052.png" alt="程序中的系统调用"></p><p>根据上述那片知乎文章参考，可以看到这里程序调用了<code>getcwd</code>函数，获取当前工作目录的绝对路径；<code>fstat</code>是用于检查文件状态，<code>brk</code>系统调用查阅了一下，大致作用是请求内核允许读写一个称为堆的连续内存块<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[BRK()系统调用做什么？](https://cloud.tencent.com/developer/ask/72042)">[4]</span></a></sup>，或者是说用于进程的内存分配<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Linux进程分配内存的两种方式--brk() 和mmap()](https://www.cnblogs.com/vinozly/p/5489138.html)">[5]</span></a></sup>；<code>write</code>则是往文件写入内容。</p><hr><p>strace的常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">执行名称为<span class="hljs-built_in">command</span>的命令或程序并跟踪系统调用</span><br>strace command<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">跟踪ID为的procid的进程系统调用情况</span><br>strace -p procid<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">统计ID为的procid的进程系统调用次数与用时，按CTRL+C结束统计</span><br>strace -c -p procid<br></code></pre></td></tr></table></figure><p class='note note-info'>  把 pstack 和 strace 结合起来，我们大概就可以知道，进程在用户空间和内核空间都干了些什么。当进程的 CPU 利用率过高或者过低的时候，我们有很大概率能直接发现瓶颈所在。</p><h1 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h1><p><code>perf</code> 可以说是 <code>pstack</code> 和 <code>strace</code> 的“高级版”，它按照固定的频率去“采样”，相当于连续执行多次的 pstack，然后再统计函数的调用次数，算出百分比。只要采样的频率足够大，把这些“瞬时截面”组合在一起，就可以得到进程运行时的可信数据，比较全面地描述出程序的运行情况。</p><p>首先执行下面命令，安装perf：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install linux-tools-common <br></code></pre></td></tr></table></figure><p>但是提示我需要再安装新的包，这里我再安装<code>linux-tools-5.4.0-97-generic</code>就可以了。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202151953426.png" alt="安装perf命令"></p><p>或者直接安装所有相关的依赖包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install linux-tools-common<br>sudo apt-get install linux-tools-&quot;$(uname -r)&quot;<br>sudo apt-get install linux-cloud-tools-&quot;$(uname -r)&quot;<br>sudo apt-get install linux-tools-generic<br>sudo apt-get install linux-cloud-tools-generic<br></code></pre></td></tr></table></figure><p>然后执行 <code>sudo perf top</code>命令，就可以看到 <code>perf</code>界面，如下图所示：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202152014700.png" alt="perf top 界面"></p><p>参考这篇文章<a href="https://www.cnblogs.com/arnoldlu/p/6241297.html">系统级性能分析工具perf的介绍与使用</a>，了解各列的含义：</p><ul><li><p>第一列：符号引发的性能事件的比例，指占用的cpu周期比例。</p></li><li><p>第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。</p></li><li><p>第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库；[k]表述此符号属于内核或模块。</p></li><li><p>第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p></li></ul><hr><p>perf top常用选项有：</p><blockquote><p>-e &lt; event &gt;：指明要分析的性能事件。</p><p>-p &lt; pid &gt;：Profile events on existing Process ID (comma sperated list). 仅分析目标进程及其创建的线程。</p><p>-k &lt; path &gt;：Path to vmlinux. Required for annotation functionality. 带符号表的内核映像所在的路径。</p><p>-K：不显示属于内核或模块的符号。</p><p>-U：不显示属于用户态程序的符号。</p><p>-d &lt; n &gt;：界面的刷新周期，默认为2s，因为perf top默认每2s从mmap的内存区域读取一次性能数据。</p><p>-g：得到函数的调用关系图。</p></blockquote><p>常用的 perf 命令是<code>perf top -K -p xxx</code>，按 CPU 使用率排序，只看用户空间的调用，这样很容易就能找出最耗费 CPU 的程序。</p><hr><p>此外，perf 和性能分析中的火焰图也是密切相关，通过<code>perf record</code>采集数据，再通过 <a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a> 相关命令就可以生成火焰图.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-F 指定采样频率； -a 指定采样所有CPU； -g 记录函数调用栈； <span class="hljs-built_in">sleep</span> 指定运行时间</span><br>perf record -F 99 -a -g -- sleep 60<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将perf数据 文本输出</span><br>perf script -i perf.data &gt; out.perf <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fold Stacks</span><br>stackcollapse-perf.pl out.perf &gt; out.folded<br><span class="hljs-meta prompt_"># </span><span class="language-bash">形成火焰图</span><br>flamegraph.pl out.folded &gt; kernel.svg<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定某个函数</span><br>grep $&#123;func&#125; out.folded | flamegraph.pl &gt; func.svg<br></code></pre></td></tr></table></figure><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/zhuoya_/article/details/81049967">top命令的用法</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/article/1005992">Linux pstack 源码里的基础知识</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/69527356">Linux进程照妖镜strace命令</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/ask/72042">BRK()系统调用做什么？</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.cnblogs.com/vinozly/p/5489138.html">Linux进程分配内存的两种方式–brk() 和mmap()</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>性能分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令学习</title>
    <link href="/2022/02/01/2022-02/2022-02-01%20Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/02/01/2022-02/2022-02-01%20Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="任务挂起和恢复"><a href="#任务挂起和恢复" class="headerlink" title="任务挂起和恢复"></a>任务挂起和恢复</h1><p>我想大家应该都知道<code>ctrl+c</code>是终止任务&#x2F;进程， <code>ctrl+z</code>是任务挂起（将一个正在前台执行的命令放到后台，并且处于暂停状态），那么任务挂起后该如何恢复呢？经过查阅<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[ctrl+z 以后怎么恢复挂起的进程](https://www.cnblogs.com/zxRPI/p/7872413.html)">[1]</span></a></sup>，可以参考使用如下命令：</p><ol><li>jobs 显示当前暂停的进程</li><li>bg %N 使第N个任务在后台运行(%前有空格)</li><li>fg %N 使第N个任务在前台运行<p class="note note-info">  注意：默认 bg 和 fg 不带%N时表示对最后一个进程操作</p></li></ol><hr><p>此外与任务&#x2F;进程控制相关的命令还有 &amp; 和 nohup<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[linux 远程主机后台运行任务 挂起脚本](https://www.jianshu.com/p/745a4cb32c47)">[2]</span></a></sup>。</p><p><code>Commod + &amp;</code> 在一个命令最后加上一个 &amp;，可以将这个命令放到后台执行；</p><p>如果让程序始终在后台执行，即使关闭当前的终端也执行（之前的&amp;做不到），这时候需要<code>nohup</code>。该命令可以在你退出帐户&#x2F;关闭终端之后继续运行相应的进程。<br> 关闭终端后，在另一个终端jobs已经无法看到后台跑得程序了，此时利用ps（进程查看命令）</p><h1 id="验证JSON格式正确性"><a href="#验证JSON格式正确性" class="headerlink" title="验证JSON格式正确性"></a>验证JSON格式正确性</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat a.json | python -m json.tool | wc -l <br></code></pre></td></tr></table></figure><p>使用上述命令，可以检查一个文件是否符合json格式，其实现原理如下：</p><ul><li>要验证的文件 a.json；</li><li>如果返回结果一行数字，则表示 a.json 文件格式正确；</li><li>否则返回 a.json 文件中错误的行号及错误信息。</li></ul><p>一旦 JSON 文件格式不对，或者文件内容缺失或者其他问题，就会导致 python -m 命令无法格式化，正是利用这一点，我们可以做一个 JSON 的验证。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Linux开发小技巧](https://mp.weixin.qq.com/s/UwgHGSSnJhiYnDISxGQXag)">[3]</span></a></sup></p><hr><p>为了简化命令，可以利用alias设置命令别名，但是因为需要命令行参数传入文件名，而alias不支持命令行参数。在查阅资料后<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[linux中给 alias 添加自定义的参数](https://www.phpernote.com/linux/1431.html)">[4]</span></a></sup>，找到一种方法，就是通过定义函数的方式来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias isjson=&#x27;isjson()&#123;cat &quot;$1&quot; | python -m json.tool | wc -l&#125;; isjson&#x27;<br></code></pre></td></tr></table></figure><h1 id="GREP、SED、AWK命令"><a href="#GREP、SED、AWK命令" class="headerlink" title="GREP、SED、AWK命令"></a>GREP、SED、AWK命令</h1><h2 id="GREP"><a href="#GREP" class="headerlink" title="GREP"></a>GREP</h2><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Linux开发小技巧](https://mp.weixin.qq.com/s/UwgHGSSnJhiYnDISxGQXag)">[3]</span></a></sup></p><ul><li>grep默认是忽略二进制数据的，可以加上 <code>-a</code> 或 <code>--text</code> 来表示不忽略二进制文件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -a file_name<br>或<br>grep --text file_name <br></code></pre></td></tr></table></figure><ul><li><strong>-E</strong>  : 使用正则表达式，匹配了才输出</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -E &quot;word1|word2|word3&quot; file.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">满足任意条件（word1、word2和word3之一）将匹配。</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep word1 file.txt | grep word2 |grep word3<br><span class="hljs-meta prompt_">#</span><span class="language-bash">必须同时满足三个条件（word1、word2和word3）才匹配。</span><br></code></pre></td></tr></table></figure><ul><li><strong>-r</strong>  ：递归搜索目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -r word directory<br></code></pre></td></tr></table></figure><ul><li><strong>-v</strong> : 显示不包含匹配文本的所有行。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -v &#x27;abc\|efg&#x27; log.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">排除 log.txt 中的 abc efg 关键字</span><br></code></pre></td></tr></table></figure><h2 id="SED"><a href="#SED" class="headerlink" title="SED"></a>SED</h2><p>sed 可依照脚本的指令来处理、编辑文本文件。sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p><p>对文件进行文本替换操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s/原字符串/新字符串/&#x27; filename<br>sed -i &#x27;s/原字符串/新字符串/g&#x27; filename<br></code></pre></td></tr></table></figure><p><strong>-i</strong> 表示直接修改读取的文件内容，而不是输出到终端。</p><p>最后带 g 进行了一个全局的搜索；不带g的话，只是匹配每行的第一个字段，后面的匹配则会忽略。</p><hr><p>示例：</p><ul><li>sed 文件首尾添加引号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s/^/&quot;/;s/$/&quot;/&#x27;  log.txt<br></code></pre></td></tr></table></figure><ul><li>sed 文件尾添加逗号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s/$/,/&#x27;  txt<br></code></pre></td></tr></table></figure><p class="note note-info">  注意上述命令在Mac系统的终端里会报错，需要在"-i" 后加上 "" </p><h2 id="AWK"><a href="#AWK" class="headerlink" title="AWK"></a>AWK</h2><p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。</p><ul><li>-F ：指定输入文件折分隔符</li><li>-v : 赋值一个用户定义变量。</li></ul><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">每行按空格或TAB分割，输出文本中的1、4项</span><br>awk &#x27;&#123;print $1,$4&#125;&#x27; log.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式化输出</span><br>awk &#x27;&#123;printf &quot;%-8s %-10s\n&quot;,$1,$4&#125;&#x27; log.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用<span class="hljs-string">&quot;,&quot;</span>分割</span><br>awk -F , &#x27;&#123;print $1,$2&#125;&#x27;   log.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用自定义变量</span><br>awk -v a=1 &#x27;&#123;print $1,$1+a&#125;&#x27; log.txt# 数值加<br>awk -v a=1 &#x27;&#123;print $1,$1a&#125;&#x27; log.txt# 字符加<br></code></pre></td></tr></table></figure><h1 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h1><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><ul><li>压缩文件： <code>zip 压缩文件名 源文件</code></li><li>压缩目录： <code>zip -r 压缩文件名 源目录</code></li><li>解压： <code>unzip 压缩文件名</code></li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir book<br>touch book/1.txt<br>touch book/2.txt<br>zip -r book.zip book<br>unzip book.zip<br></code></pre></td></tr></table></figure><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><table><thead><tr><th align="left">命令</th><th align="left">示例</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">gzip 源文件</td><td align="left">gzip a.txt</td><td align="left">压缩为.gz格式的压缩文件，源文件会消失</td></tr><tr><td align="left">gzip -c 源文件 &gt; 压缩文件</td><td align="left">gzip -c yum.txt &gt; yum.txt.gz</td><td align="left">压缩为.gz格式的压缩文件，源文件不会消失</td></tr><tr><td align="left">gzip -r 目录</td><td align="left">gzip -r xx</td><td align="left">压缩目录下的所有子文件，但是不压缩目录</td></tr><tr><td align="left">gzip -d 压缩文件名</td><td align="left">gzip -d yum.txt.gz</td><td align="left">解压缩文件,不保留压缩包</td></tr><tr><td align="left">gunzip 压缩文件</td><td align="left">gunzip yum.txt.gz</td><td align="left">解压缩文件,不保留压缩包</td></tr></tbody></table><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><ul><li>tar -cvf 打包文件名 源文件<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[linux总结](https://mp.weixin.qq.com/s/QyERReOEIBC5T4580ffVHw)">[5]</span></a></sup><ul><li>-c 打包</li><li>-v 显示过程</li><li>-f 指定打包后的文件名</li><li>-x 解打包</li></ul></li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -cvf book.tar book<br>tar -xvf book.tar<br></code></pre></td></tr></table></figure><p><strong>更多压缩命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar –cvf jpg.tar *.jpg #将目录里所有jpg文件打包成tar.jpg <br><br>tar –czf jpg.tar.gz *.jpg #将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz <br><br>tar –cjf jpg.tar.bz2 *.jpg #将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 <br><br>tar –cZf jpg.tar.Z *.jpg #将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z <br><br>rar a jpg.rar *.jpg #rar格式的压缩，需要先下载rar for linux <br><br>zip jpg.zip *.jpg #zip格式的压缩，需要先下载zip for linux<br></code></pre></td></tr></table></figure><p><strong>更多解压命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar –xvf file.tar #解压 tar包 <br><br>tar -xzvf file.tar.gz #解压tar.gz<br><br>tar -xjvf file.tar.bz2 #解压 tar.bz2 <br><br>tar –xZvf file.tar.Z #解压tar.Z <br><br>unrar e file.rar #解压rar <br><br>unzip file.zip #解压zip<br></code></pre></td></tr></table></figure><h1 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h1><blockquote><p> 参考：<a href="https://www.linuxprobe.com/soft-and-hard-links.html">软链接和硬链接的区别</a><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[软链接和硬链接的区别](https://www.linuxprobe.com/soft-and-hard-links.html)">[6]</span></a></sup></p></blockquote><p>我们知道文件都有文件名与数据，这在 <a href="https://www.linuxprobe.com/">Linux</a> 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。而有一种方法可以快速的寻找到数据元，那就是软硬链接，链接实际上就是一种文件共享的方式。</p><p>那么软链接和硬链接的区别在哪呢？<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[linux中硬链接与软链接的区别](http://www.178linux.com/53101)">[7]</span></a></sup></p><ol><li><strong>首先，两者作用的对象不同：</strong></li></ol><ul><li>硬链接，只能应用于文件，而不能应用于目录，而且不能跨文件系统（即分区）；</li><li>软（符号）链接，可以应用于文件，而且可以应用于目录和可跨文件系统（分区）。</li></ul><ol start="2"><li><strong>其次，两者的作用原理不同：</strong></li></ol><ul><li>硬链接中，假如说A文件是B文件的硬连接文件，那么A和B的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的，硬链接中一个inode号可以对应多个文件。如果删除其中任何一个文件，另外一个文件还能连接数据块，还是有效的文件，只是对应的inode节点号减少，其它并无影响。只有inode节点号减少到0，数据块才会被系统回收。</li><li>而在软链接中，假如说A文件是B文件的软连接文件，则A和B的inode节点号不同，每创建一个新的软链接，就会有一个新的节点号。而A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是“主从”关系，如果B被删除了，A仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</li></ul><ol start="3"><li><strong>语法不同：</strong></li></ol><ul><li>硬链接的语法：<code>ln  filename  [linkname ]</code></li><li>软链接的语法：<code>ln  -s  filename  [linkname]</code></li></ul><hr><p>最后总结一下：</p><ul><li>硬链接：与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块；</li><li>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问数据时，将用数据块中指向的文件路径进行替换。</li></ul><h1 id="其它shell技巧"><a href="#其它shell技巧" class="headerlink" title="其它shell技巧"></a>其它shell技巧</h1><h2 id="输入相似文件名"><a href="#输入相似文件名" class="headerlink" title="输入相似文件名"></a>输入相似文件名</h2><p>用花括号括起来的字符串之间再用逗号连接，可以实现自动扩展，非常有用。花括号中的每个字符都可以和之后（或之前）的字符串进行组合拼接，注意花括号和其中的逗号不可以用空格分隔，否则会被认为是普通的字符串对待。示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> &#123;one,two,three&#125;file</span><br>onefile twofile threefile<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> &#123;one,two,three&#125;&#123;1,2,3&#125;</span><br>one1 one2 one3 two1 two2 two3 three1 three2 three3<br></code></pre></td></tr></table></figure><p>这个技巧有什么实际用处呢？最简单实用的就是给 cp,mv,rm 等命令扩展参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> /search/code/file&#123;,.bak&#125;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给 file 复制一个叫做 file.bak 的副本</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rm</span> file&#123;1,3,5&#125;.txt</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除 file1.txt file3.txt file5.txt</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mv</span> *.&#123;c,cpp&#125; src/</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将所有 .c 和 .cpp 为后缀的文件移入 src 文件夹</span><br></code></pre></td></tr></table></figure><h2 id="命令快捷键"><a href="#命令快捷键" class="headerlink" title="命令快捷键"></a>命令快捷键</h2><table><thead><tr><th align="left">命令</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">ctrl+c</td><td align="left">强制终止当前命令</td></tr><tr><td align="left">ctrl+l</td><td align="left">清屏</td></tr><tr><td align="left">ctrl+a</td><td align="left">光标移动到命令行首</td></tr><tr><td align="left">ctrl+e</td><td align="left">光标移动到命令行尾</td></tr><tr><td align="left">ctrl+u</td><td align="left">从光标所在的位置删除到行首</td></tr><tr><td align="left">ctrl+z</td><td align="left">把命令放入后台</td></tr><tr><td align="left">ctrl+r</td><td align="left">在历史命令中搜索</td></tr><tr><td align="left">!n</td><td align="left">替换成第n条历史命令</td></tr><tr><td align="left">!!</td><td align="left">替换成上一条命令</td></tr><tr><td align="left">!字符</td><td align="left">替换成最后一条以该字符串开头的命令</td></tr></tbody></table><h2 id="命令连接符"><a href="#命令连接符" class="headerlink" title="命令连接符"></a>命令连接符</h2><ol><li><p><strong>; 分号</strong>：没有任何逻辑关系的连接符。当多个命令用分号连接时，各命令之间的执行成功与否彼此没有任何影响，都会一条一条执行下去。</p></li><li><p><strong>|| 逻辑或</strong>：当用此连接符连接多个命令时，前面的命令执行成功，则后面的命令不会执行。前面的命令执行失败，后面的命令才会执行。</p></li><li><p><strong>&amp;&amp; 逻辑与</strong>：当用此连接符连接多个命令时，前面的命令执行成功，才会执行后面的命令，前面的命令执行失败，后面的命令不会执行，与 || 正好相反。</p></li><li><p><strong>| 管道符</strong>：当用此连接符连接多个命令时，前面命令执行的正确输出，会交给后面的命令继续处理。若前面的命令执行失败，则会报错，若后面的命令无法处理前面命令的输出，也会报错</p></li></ol><h2 id="复制文本内容"><a href="#复制文本内容" class="headerlink" title="复制文本内容"></a>复制文本内容</h2><p>有时候不好在终端界面里，用鼠标操作选中并复制文件里的文本内容，可以用下面的命令来复制文件里的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">方法1，利用重定向</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pbcopy &lt; file.txt</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">方法2，利用管道</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> file.txt | pbcopy</span><br></code></pre></td></tr></table></figure><h1 id="Bonus-系统启动过程"><a href="#Bonus-系统启动过程" class="headerlink" title="Bonus: 系统启动过程"></a>Bonus: 系统启动过程</h1><blockquote><p>参考阮一峰大佬的这篇博客：<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的</a><sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="[计算机是如何启动的](http://www.ruanyifeng.com/blog/2013/02/booting.html)">[8]</span></a></sup></p></blockquote><h2 id="1-BIOS"><a href="#1-BIOS" class="headerlink" title="1.BIOS"></a>1.BIOS</h2><ul><li>计算机通电后，第一件事就是读取刷入ROM芯片的开机程序，这个程序叫做(Basic Input&#x2F;Output System)</li></ul><h2 id="2-硬件自检"><a href="#2-硬件自检" class="headerlink" title="2.硬件自检"></a>2.硬件自检</h2><ul><li>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test)</li><li>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</li></ul><h2 id="3-启动顺序"><a href="#3-启动顺序" class="headerlink" title="3. 启动顺序"></a>3. 启动顺序</h2><ul><li>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</li><li>这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备</li><li>BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）</li><li>BIOS按照”启动顺序”，把控制权转交给排在第一位的储存设备。</li><li>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</li><li>这最前面的512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR）</li></ul><h2 id="4-主引导记录的结构"><a href="#4-主引导记录的结构" class="headerlink" title="4. 主引导记录的结构"></a>4. 主引导记录的结构</h2><ul><li><p>“主引导记录”只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。</p><ul><li><p>（1） 第1-446字节：是用来记录系统的启动信息的,调用操作系统的机器码</p></li><li><p>（2） 第447-510字节(64个字节)：分区表（Partition table），分区表的作用，是将硬盘分成若干个区</p></li><li><p>（3） 第511-512字节：主引导记录签名（0x55和0xAA）</p></li></ul></li></ul><h2 id="5-分区表"><a href="#5-分区表" class="headerlink" title="5. 分区表"></a>5. 分区表</h2><ul><li>磁盘分区是使用分区编辑器在磁盘上划分几个逻辑部分</li><li>磁盘一旦划分成多个分区，不同类的目录与文件可以存储进不同的分区内</li><li>“主引导记录”因此必须知道将控制权转交给哪个区</li><li>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”<ul><li>（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</li><li>（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。</li><li>（3） 第5个字节：主分区类型，比如FAT32、NTFS等。</li><li>（4） 第6-8个字节：主分区最后一个扇区的物理位置。</li><li>（5） 第9-12字节：该主分区第一个扇区的逻辑地址。</li><li>（6） 第13-16字节：主分区的扇区总数。</li></ul></li></ul><h2 id="6-硬盘启动"><a href="#6-硬盘启动" class="headerlink" title="6. 硬盘启动"></a>6. 硬盘启动</h2><ul><li>计算机的控制权就要转交给硬盘的某个分区了</li><li>四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做”卷引导记录”（Volume boot record，缩写为VBR）</li><li>“卷引导记录”的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</li></ul><h2 id="7-操作系统"><a href="#7-操作系统" class="headerlink" title="7. 操作系统"></a>7. 操作系统</h2><ul><li>控制权转交给操作系统后，操作系统的内核首先被载入内存。</li><li>以Linux系统为例，先载入<code>/boot</code>目录下面的<code>kernel</code>。内核加载成功后，第一个运行的程序是<code>/sbin/init</code>。它根据配置文件（Debian系统是&#x2F;etc&#x2F;initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代</li><li>然后，<code>init</code>线程加载系统的各个模块，比如窗口程序和网络程序，直至执行<code>/bin/login</code>程序，跳出登录界面，等待用户输入用户名和密码。</li></ul><hr><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/zxRPI/p/7872413.html">ctrl+z 以后怎么恢复挂起的进程</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.jianshu.com/p/745a4cb32c47">linux 远程主机后台运行任务 挂起脚本</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/UwgHGSSnJhiYnDISxGQXag">Linux开发小技巧</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.phpernote.com/linux/1431.html">linux中给 alias 添加自定义的参数</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/QyERReOEIBC5T4580ffVHw">linux总结</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://www.linuxprobe.com/soft-and-hard-links.html">软链接和硬链接的区别</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="http://www.178linux.com/53101">linux中硬链接与软链接的区别</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>除夕夜浅谈</title>
    <link href="/2022/01/31/2022-01/2022-01-31%20%E9%99%A4%E5%A4%95%E5%A4%9C%E6%B5%85%E8%B0%88/"/>
    <url>/2022/01/31/2022-01/2022-01-31%20%E9%99%A4%E5%A4%95%E5%A4%9C%E6%B5%85%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p>哈哈，这还是第一次在除夕夜写点东西呢，也算是创纪录吧。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202201312130421.jpeg"></p><p>主要前一周刚把学校里的作业忙完，然后这一周就本性暴露，开始摆烂躺平，疯狂沉迷游戏，肆意地挥霍时间，明明之前都制定好假期计划，要加强自我的，可恶，难道，wa ta shi，又要重蹈覆辙吗？</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202201312139874.jpeg"></p><p>明天大年初一，新的一年，新的开始，就算伤痕累累，就算跌倒失败，我也要前进，我也要战斗，ta ta kai, yi zi mo ta ta kai !</p><p>至于今晚的剩余时间，晚上年夜饭也喝了酒，就好好休息吧，看看bilibili的拜年纪，再把天降之物的剧场版给补了，睡个好觉，明天再出发~</p><p>最后，祝大家新春快乐，虎年大吉~</p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202202010930000.jpeg" alt="虎年" style="zoom:67%;" />]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++指针那些事</title>
    <link href="/2022/01/17/2022-01/2022-01-17%20C++%E6%8C%87%E9%92%88%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/01/17/2022-01/2022-01-17%20C++%E6%8C%87%E9%92%88%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>指针真的让人又爱又恨，每当自己认为已经参悟一二，现实总是狠狠地打了我脸，不是忘了这个，就是忘了那个。因此趁这个机会，再温习回顾下C&#x2F;C++里指针的相关语法知识，并记录下来以便日后复习。</p><h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="指针基本概念"><a href="#指针基本概念" class="headerlink" title="指针基本概念"></a>指针基本概念</h2><p>在C语言中，每定义一个变量，系统就会为变量分配一块内存，而内存是有地址的。C语言中，采用运算符 &amp; 来获取变量的地址。</p><p><strong>指针是一种特殊类型的变量，用于存储变量的地址</strong>。当指针变量赋值之后，就可以使用运算符 * （解引用运算符），取得指针所指向地址的值，简单用法如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span>* p;  <span class="hljs-comment">// 定义一个指针p，类型为 int;</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<span class="hljs-comment">// 定义一个 int 变量</span><br><br>p = &amp;b;<span class="hljs-comment">//将 p 指向 b</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;变量 num 的地址为 &quot;</span> &lt;&lt; p &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;变量 num 的地址为 &quot;</span> &lt;&lt; (&amp;num) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;变量 num 的值为&quot;</span> &lt;&lt; num &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;变量 num 的值为&quot;</span> &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">// *p 表示指针p中存储的地址所对应的值；</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：在 C++ 创建指针时，计算机将会分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存 ，为数据分配的空间是一个独立的空间，不可省略，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *pt;<span class="hljs-comment">// 定义一个指向 int 类型的指针 pt;</span><br>*pt = <span class="hljs-number">23</span>;<span class="hljs-comment">// 错误，指针 pt 未指向任何地址，</span><br></code></pre></td></tr></table></figure><p>所以需要谨记一点，在对指针应用解引用运算符(*) 之前，将指针初始化为一个确定的，适当的地址。 </p><h2 id="空指针与野指针"><a href="#空指针与野指针" class="headerlink" title="空指针与野指针"></a>空指针与野指针</h2><p>空指针：没有赋值的指针变量（没有指向内存变量的地址），对空指针进行操作会造成程序的Core dump（段错误）。如下代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>* p = <span class="hljs-number">0</span>;<br>*p = <span class="hljs-number">10</span>;<span class="hljs-comment">// 运行报错</span><br></code></pre></td></tr></table></figure><p>野指针：指针指向内存已释放，但指针的值不会被清零，对野指针操作的结果不可预知。如下代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">delete</span> p ;<br><span class="hljs-keyword">if</span> (p !=  <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-comment">// 已经释放了对应内存空间，但指针的值还没有清零，此时成为野指针</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;not nullptr&quot;</span> &lt;&lt; endl;<br>&#125;<br>p = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">// 释放指针后，应当手动置指针为nullptr</span><br></code></pre></td></tr></table></figure><h2 id="sizeof的坑"><a href="#sizeof的坑" class="headerlink" title="sizeof的坑"></a>sizeof的坑</h2><p>sizeof(x) ，当 x 为指针变量时，求得的是指针类型的大小；当 x 为数组名时，求得的是数组的大小（数组元素个数 * 数组元素类型大小）。</p><p><strong>注意</strong>：当数组作为函数的参数进行传递时，数组自动退化为同类型的指针。参考下面示例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_size</span><span class="hljs-params">(<span class="hljs-type">int</span> data[])</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(data);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> data1[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> size1 = <span class="hljs-built_in">sizeof</span>(data1);    <span class="hljs-comment">// 20 （输出的是数组大小)</span><br>    <br>    <span class="hljs-type">int</span>* data2 = data1;<br>    <span class="hljs-type">int</span> size2 = <span class="hljs-built_in">sizeof</span>(data2);    <span class="hljs-comment">// 8 (64位机器） 输出的是指针大小</span><br>    <br>    <span class="hljs-type">int</span> size3 = <span class="hljs-built_in">get_size</span>(data1);  <span class="hljs-comment">// 8 (64位机器）</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h1><ul><li>数组名用法上 类似于一个指针常量，指向数组首元素的地址</li><li>对于指针p， p+1 的跨度，即移动p一次增加的字节数大小，等于指针p所指元素类型的大小<ul><li>对于int *p，增加4字节</li><li>对于double *p ，增加8字节</li><li>对于int (* p)[3)，增加 3 * 4 &#x3D; 12 字节，因为p指向的是一个数组，整个数组的大小为3、*4 &#x3D; 12字节</li><li>对于int* * p，增加8字节（64位系统），因为p指向的是一个int*指针，而指针大小为8字节</li></ul></li><li>对于new的使用，通常是和指针结合在一起，对于 Type* p （Type代表某种类型），通常new是有两种用法<ul><li><code>Type* p = new Type( )</code>，只分配单个Type的内存，new返回的也是这个Type的内存地址<ul><li>获取对应元素，通常使用 *p，但是 p[0] 也是同样的效果；使用 p[1] 的话，会访问超出了我们分配的内存，可能带来不可预知的后果</li></ul></li><li><code>Type* p = new Type[n]</code>，分配n个 Type的内存，new返回的是Type数组首元素的地址<ul><li>获取对应元素，通常使用 p[i]，获取下标为 i 的元素</li></ul></li></ul></li></ul><hr><p>这样的话有这样一个疑惑，如下方图片中标红区域，可以有申请一个int的大小，申请一个指针的大小，如何单独申请一个数组对象？</p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202201221755705.png" alt="" style="zoom: 50%;" /></center><p>似乎并没有相对应的方式，因为申请一个数组的空间已经用 <code>int* p = new int[3]</code> 表达了，其实这个问题有点类似钻牛角尖，或者说自以为有这样的对称规律在。但在实际使用中并不推荐使用new 和 delete，对于数组的需求，使用vector&lt; T&gt; 就行了；这里只是为了探讨研究语法问题。</p><h1 id="指针常量与常量指针"><a href="#指针常量与常量指针" class="headerlink" title="指针常量与常量指针"></a>指针常量与常量指针</h1><p><strong>指针常量</strong>：指针类型的常量。表示这个指针变量用const修饰后成了常量，变量的值不能改变即不能指向其他地址，但是指针所指向地址里的值是可以修改的。同时注意这是个常量，所以在定义的时候要初始化。</p><p><strong>常量指针</strong>：指针变量指向的类型为常量类型，即指针指向地址里的值不可以修改。</p><p>具体示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> * <span class="hljs-type">const</span> p1 = &amp;a;<span class="hljs-comment">// p1是指针常量</span><br>*p1 = <span class="hljs-number">30</span>;   <span class="hljs-comment">// p1指向的地址是一定的，但其内容可以修改</span><br><span class="hljs-comment">// p1 = &amp;b;// p1指针常量不能指向其他变量的地址</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p2 = &amp;a; <span class="hljs-comment">// p2是常量指针</span><br><span class="hljs-comment">// int const *p2 = &amp;a; // 和上一行等价</span><br>p2 = &amp;b; <span class="hljs-comment">// p2可以指向其他地址，但是内容不可以改变</span><br><span class="hljs-comment">// *p2 = 10; // p2常量指针，所指向地址的值不可以修改</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p3 = &amp;a;<span class="hljs-comment">// p3既是指针常量又是常量指针</span><br><span class="hljs-comment">// p3 = &amp;b;// p3不能指向其他地址</span><br><span class="hljs-comment">// *p3 = 30;// p3所指向地址的值不能修改</span><br></code></pre></td></tr></table></figure><p>有时候指针常量和常量指针傻傻分不清，教大家一个小技巧，<strong>就是看 const  在 * 的哪一侧</strong>，如果const 在 * 左侧，表明const 靠近所指向的变量类型，即所指向的变量是个常量，也就是常量指针；如果 const 在 * 的右侧，表明 const 靠近指针变量名，所以这个指针变量是个常量，也就是指针常量。</p><h1 id="函数名与函数指针"><a href="#函数名与函数指针" class="headerlink" title="函数名与函数指针"></a>函数名与函数指针</h1><p>就像定义 int 变量时，会在内存里分配一个4字节的空间存储该变量，对应有一个地址；当定义了一个函数后，同样需要在内存中分配空间进行存储，调用函数就像使用变量一样需要一个地址来唯一的指向它，所以每个函数都需要一个地址来唯一标识自己，也就是所说的入口地址。</p><p>函数名标识映射该函数的入口地址，而函数指针是指向函数入口地址的指针变量（记住了函数名本身并不是一个指针类型）。</p><p>有了指向函数的指针变量后，可以用函数指针变量调用函数，就像用指针变量操作其他类型变量一样。函数指针主要有两个用途：调用函数和做函数的参数。</p><hr><p>我们都知道在调用函数的时候有函数名就够了，比如fun(2)，但编译器在编译的时候会进行所谓的”<strong>Function-to-pointer conversion</strong>“，也就是把函数名隐式转换成函数指针类型，也就是要通过函数指针来调用函数，所以如果你在调用函数的时候写成(&amp;fun)(2)也是一样能工作的，因为&amp;fun实际上就是返回一个函数指针。参照下面例子，只是这种写法很不常见，即使你不显式的写出&amp;的话编译器也会隐式的进行转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;fun&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fun=%p\n&quot;</span>,fun);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*fun=%p\n&quot;</span>,*fun);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;fun=%p\n&quot;</span>,&amp;fun);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*******fun=%p\n&quot;</span>,*******fun);<br><br>    <span class="hljs-built_in">void</span>(*p1)(<span class="hljs-type">int</span>)=fun;<span class="hljs-comment">// 函数指针p1，fun进行一次隐式转换</span><br>    <span class="hljs-built_in">void</span>(*p2)(<span class="hljs-type">int</span>)=*fun;<span class="hljs-comment">// fun进行了两次隐式转换</span><br>    <span class="hljs-built_in">void</span>(*p3)(<span class="hljs-type">int</span>)=&amp;fun;<span class="hljs-comment">// 显示转换成函数指针</span><br><span class="hljs-comment">//    void(*p4)(int)=&amp;&amp;fun; // 不可以，连续取两次地址，就变成了函数指针的指针类型</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p1=%p\n&quot;</span>, p1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p2=%p\n&quot;</span>, p2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p3=%p\n&quot;</span>, p3);<br>&#125;<br></code></pre></td></tr></table></figure><p>正如上面代码示例所示，其实即使你写成(* fun)(2)也是可以正常运行的，这是因为当编译器看到fun的时候发现它前面没有&amp;，<strong>也就是如果没有将函数名显示地转换成指针，那么他就会隐式地转换成指针</strong>，当转换完之后发现前面又有一个 * 这时候也就是要进行所谓的”解引用”操作，也就是取出 * 指针里的值，而那么值实际上也就函数名fun，这样一次隐式换然后再来一次解引用实际上相当于什么也没做，所以系统还会再进行一次隐式的”Function-to-pointer conversion”，所以即使你写成(************fun)(2)也会正常运行，和刚才的一个道理，只是多做了几次反复的转解操作而已，都是编译器自己完成的。</p><hr><p>后来又学习到了定义某个类的非静态成员函数指针的方式，真是又“涨姿势”了~ 例如<code>typedef void (MyClass:: *ClassFunc)(); </code>这是定义了<code>MyClass</code>类的非静态成员函数指针，即<code>ClassFunc</code>定义的变量只能接收<code>MyClass</code>的非静态成员函数。</p><p>而调用的方式也比较奇特，因为是绑定的是类的非静态成员函数，所以就需要该类的一个实例对象来进行调用，所以调用形式为<code>(m. *p)() 或 (p_m-&gt; *p )()</code>，其中分别是<code>m</code>为对象实例，<code>p_m</code>为对象指针，<code>p</code> 是 <code>ClassFunc</code> 的一个实例（即函数指针），加一个 * 可以理解为把指针转换成了函数名，这样就和正常调用成员函数的情况一致了（这是我个人的理解哈。。。）</p><p>更详细的测试代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;func&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;func2&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func3&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(MyClass:: *ClassFunc)</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 定义MyClass类的 非静态成员函数指针</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(* NormalFunc)</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">// 定义普通函数指针</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    MyClass m;<br>    MyClass* p_m = &amp;m;<br>    ClassFunc p = &amp;MyClass::func;<span class="hljs-comment">// 这里 &amp; 不能少，不清楚为什么这里没有隐式转换，可能是类成员函数特别一点？</span><br><br>    (m.*p)();           <span class="hljs-comment">// 正常调用</span><br>    (p_m-&gt;*p)();        <span class="hljs-comment">// 正常调用</span><br><br>    <span class="hljs-comment">// NormalFunc a = MyClass::func;        // 编译不通过</span><br>    NormalFunc b = MyClass::func2;          <span class="hljs-comment">// 编译通过，类的静态成员函数可以被普通函数指针接收</span><br>    NormalFunc c = func3;                   <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-built_in">b</span>();<br>    <span class="hljs-built_in">c</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="https://www.cnblogs.com/Esfog/archive/2012/04/23/2467249.html">C&#x2F;C++的函数名和函数指针的关系剖析 - Esfog - 博客园</a> </p><p>[2] <a href="https://www.jb51.net/article/54220.htm">数组名与数组指针、指针数组</a> </p><p>[3] <a href="https://juejin.cn/post/6923743288407097351">C++ 指针详讲、及指针与数组 - 掘金</a></p><p>[4] <a href="https://www.bilibili.com/video/BV16T4y1w7wm?p=7">解决全部C语言指针的问题_哔哩哔哩</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年终总结</title>
    <link href="/2021/12/31/2021-12/2021-12-31%202021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2021/12/31/2021-12/2021-12-31%202021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在是2021年12月31日19点45分，后天的这个时候我应该在考云计算，所以保险起见，我还是先去复习吧，年终总结就放到考完试再补上~</p><center><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20190816%2Fc1bb1f88cc334de5bfdb433c1766f830.png&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643543259&t=b6769fbb96552656e2b401a1e9d5feea" alt="" style="zoom:50%;" /></center><hr><p>今天是2022年1月2日，现在我已经考完了史诗级难度的算法分析与设计，以及差点没写完的云计算。等到我心情平复下来，也时候补交这份年终总结了。</p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202201022151747.jpeg" alt="看开了" style="zoom:40%;" /></center><h1 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h1><h2 id="实习经历简介"><a href="#实习经历简介" class="headerlink" title="实习经历简介"></a>实习经历简介</h2><p>从去年11月开始，我就去了字节实习，而截至今年开学9月份才离职，再除去中间请假一个多月回学校做毕设，算起来也快实习了9个月，不禁令人感叹时间真的过得太快了，下面我就简单介绍一下自己的实习经历吧。我所在部门是抖音国际版（也就是Tiktok）的广告中台Global Ads Infra，负责广告投放的相关业务，也算是比较核心的部门了，毕竟广告营收是流量变现的重要途经。</p><p>在实习期间，的确是学习到了不少广告的相关知识，从零开始了解相关业务，记得一开始碰到的广告相关的陌生名词有满满一页，对具体的广告投放流程也是云里雾里，不知所踪。到后来，待久了，也渐渐熟悉起来，明白了大致流程，大体的模块架构，当然也非常浅显，只是对各个功能模块了解个大概。从硬看源码，到增加功能点，进行测试，开AB测试实验，再到提交自己的PR通过Review，最终代码上线，这一过程下来也让我些许了解了大厂的项目开发流程。</p><p>然后再谈谈我个人的工作吧，一开始我是维护一个线上服务的监控系统，简单来说就是在线上服务里增加打点逻辑，然后再另一个程序里进行流处理，实时输出相关监控指标，不过因为代码使用scala写的，我也不是很熟，所以只是简单修改了一下逻辑，修复Bug。老实说，因为这个项目是2年前的项目了，大概快一年没人在维护了，所以感觉问题还是很大的，但我个人又因为实力不足，无法进行重构，就是那种知道有问题，但又给不出解决方案，可以说是菜鸡落泪了，所以最后这个项目也就是做到了能跑的效果。不过这个监控服务后来也没有被怎么重视，没有什么人用，所以也就这样了，因为后来有了更重要的需求要做。</p><p>之后主要负责的工作是搭建实验指标，为开发同学实验测试提供指标参考，测试新增功能是否存在异常。具体来说，我就是收集各个服务Owner的需求，在对应服务的代码里增加相关逻辑，然后提交需求给实验指标平台，再让他们做完成实验平台上的开发工作。这个工作的主要难点，就在于要去看各个服务的代码，得稍微懂点其中运行流程和逻辑，然后再合适的地方加上数据打点，写的代码其实不多，还有就是处理逻辑需要写个Flink SQL，然后再把需求整理给文档提交给实验平台的同学。这个过程是收集需求，看代码了解逻辑，以及和其他部门的同学打交道，对接工作需求，虽然重复性工作挺多，但也有一定的收获。</p><p>最后的话，是对一个线上服务做了小优化，主要在mentor的指导下，优化了Go语言里Map序列化的问题，略微降低了在线服务机器的CPU和内存使用率。这个工作对我来说，感觉受益匪浅，学习到了怎么去进行测试，性能优化看哪些指标，怎么看，最后出了一份方案报告，虽然也比较简单吧，但也受到了大家的肯定，对我来说，感觉还是很不错的，就是那种你做的工作切实有效，是肉眼可见的，而没有白费，就感觉实现了自己的一点价值。</p><h2 id="实习收获与感受"><a href="#实习收获与感受" class="headerlink" title="实习收获与感受"></a>实习收获与感受</h2><p>总的来说，这份实习经历我认为还是非常宝贵的，无论是mentor还是其他同事，都十分友善，也都很有能力，给了我不少帮助和指导。不过实习期间，代码写的不多，文档倒是写了不少……所以我感觉自己的代码能力或许没有提升多少，但是眼界和视野是拓展开阔了，接触了解到项目的开发流程，学习如何与人合作沟通交流，思维方式也发生了改变，开始重视时间规划，估算工作量，关注工作产出。还有一个很大的收获就是学习使用飞书了，到现在，飞书也成了我的笔记主力，提升了我不少学习效率。</p><p>还有特别深的感触就是，感觉自己真的好菜，很多地方都不会，不懂，没啥突出的能力，跟正式员工真的差距很大，觉得自己在学校里虽然考试能拿高分，但是到了实际开发中，自己的能力真的是远远不足，没有过硬的代码能力，也没有什么架构思维，可能也就基础马马虎虎吧。也正是如此，让我下定决心，回到学校后，一定要去把这些欠缺的能力都给补起来。</p><h2 id="自我反思与总结"><a href="#自我反思与总结" class="headerlink" title="自我反思与总结"></a>自我反思与总结</h2><p>在实习的头两个月还好，还保持着一种比较高昂的斗志，但是之后可能是热情散去了，就陷入了一种懒散的状态，每天相当于是打卡上班实习，按部就班完成自己的工作任务，也没有想着再多去学习新技术啥的，可能就导致我成长得比较慢（自我感觉）。</p><p>在实习期间，我还染上了一大恶习，那就是熬夜玩手机、玩电脑。曾经我也认为超过12点不睡觉就是罪大恶极，对身体会造成极大危害，会给自己带来极大的负罪感。但是在实习独居期间，各种熬夜到2、3点，甚至好几次熬夜到6点多睡，10点起上班，记得情况最严重的一次，当时整个人脑袋昏昏沉沉的，到了公司一点状态都没有，工作效率极差。而熬夜带来的连锁反应就是，睡眠不足，晚起不吃早饭，与我之前的作息大相径庭，也造成了我实习期间状态不佳，都没充沛的精神，还谈何学习和工作呢？再加上每逢周末必点外卖，不太注意饮食，导致那段期间身体状况不容乐观，明显可以感觉到不如从前。</p><p>总结来说，该反思的有两点，一个是心态上，实习期间还是缺乏一种积极学习的态度，或者说当时也没有明确的目标，不知道要学什么，可以学什么，每天就只是完成工作任务，没有花更多的时间来拓展学习，的确该好好反思反思。另一个就是身体上，如果连自己的身体照顾不好，那还谈什么其他的呢？身体是革命的本钱，同时良好的健康状态也才能更好地支撑工作学习，提高效率，以后真的是需要保持健康的生活作息，多运动，多健身。</p><h1 id="研究生"><a href="#研究生" class="headerlink" title="研究生"></a>研究生</h1><p>今年下半年，我成为了北京大学软件与微电子学院的研究生。老实说，没有太多实感，就像是被一股潮流推至此地。简单谈谈在软微的学习生活吧，软微地方很小，我住的5号楼离食堂和宿舍都很近，下个楼拐个弯就到了，很方便。软微的食堂比较小，菜式也比较固定，几个月下来，我的早饭基本上就是肉饼、素饼、土豆饼、酱香饼、培根煎鸡蛋、豆浆这五样里排列组合，不过我对吃饭也没过高的要求，所以也都还能接受吧。</p><p>软微的课程，感觉总体上和 本科差别不大吧，比较大的区别可能就是，成了研究生之后，自学的时间占了大量的课后时间，除了一些核心课需要考试考核，其他多数课程是类似于大作业的形式进行考查。在软微，你会遇到大佬，遇到<del>卷王</del>（废寝忘食的人），遇到像我这样的佛系的人，也可以说是各具特色了。或许是之前有过实习经历吧，和许多能人、专家共事过，所以虽然也知道自己和别人的差距很大，倒也没有太大的心理压力了，一步一步脚印嘛，慢慢来吧，抗压这一块我一直可以的（哈哈，躺平就直说~）。</p><p>此外，我又重视其自己的健康了。开学以来，我就在积极锻炼了，在宿舍里做Keep，室外跑步，入冬之后就只剩下室内运动了。但不幸的时候，12月初腰部出了点问题，久坐之后感到疼，可能是腰肌劳损了，后来去看了医生，开了药膏和药丸，告诫我之后不能久坐，每坐一小时，就需要起来活动一会儿。也是因为这个原因，我的健身计划也不得已搁置了，不过也算是给我敲响了警钟，我的身体真的没有我想象中那么乐观了，各位朋友，也要多多保重自己的身体啊。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>再来谈谈这一年来的生活吧，年初因为疫情原因没有选择回家过年，人生第一次在外地和驰哥一起在过春节，记得初一还是初二，吃的还是泡面哈哈。年后又是近3个月的实习，然后就请假一个多月，回学校做毕设去了。在最后短暂的日子里，和大学同学们相拥这最后的时光，毕竟毕业之后，再次相见不知何年何月了，但相信总会有重逢的一天，就让我们在那一天到来之前，各自努力成为更好的自己吧~</p><p>毕业之后，在家呆了一星期之后又回公司实习去了。再此后，就是9月份研究生开学，正式拉开了我研究生生活的序幕。还记得当时上学前，立下一个flag，10月前必脱单，或许是看到周围身边的人都脱单而感到焦虑了，或许是感到寂寞了，或许是认为再不谈一场校园恋爱以后再也没有机会。但结果来说，我失败了。然后，然后就没有后文了。或许真的是单身太久了，不知道心动到底是怎样一种感觉，不知道喜欢一个人你该去怎么行动，不知道怎么去爱一个人。想想自身的原因，长相一般，身高一般，不太会装扮，生活常识也有欠缺，同时还是个看动漫的宅男，还带有略微的中二，还喜欢打游戏，除了稍微，一丢丢对学习上点心外，似乎没有别的什么特别之处，这样的人设的确吸引不了别人啊。不过后来我也看开了，再遇到她之前，我还是继续努力，多多提升自己吧，成为更优秀的人。</p><p>接着谈谈游戏吧，这一年主要玩的还是英雄联盟，每周六晚更是成了开黑时段，也就玩玩大乱斗了，与其说是玩游戏，或许更多的是享受和朋友吹水时刻吧。此外还用模拟器玩了女神异闻录p5以及八方旅人，感觉都是不错的游戏。以后的话，打算是等有钱了，整上台式机，ps主机，Switch，大屏显示器，不过可能到了那个时候可能反而没有玩游戏的心思了，想玩的时候玩不了，能玩的时候不想玩了或者还是玩不了，这么想来，还是有些许的悲伤呢。</p><p>还能说点什么呢，哦，对了，那就是我感觉自己还是没有长大，或者说不够成熟，对于人情世故不太擅长，不擅交际，对生活的一些常识或者说是细节还不了解，感觉自己的心态还是孩子一样，不愿去思考更多的东西，或者说不想去承担某些责任，只是任由生活推着自己往前走，而不是自己挑起担子往前跑，当然也有做努力在改变，但似乎远远不够。就像是周围的朋友都有了大人模样，而我还是那个沉浸在自己世界里的少年。我希望自己能长大，但也畏惧着长大。我很焦虑，但又很佛系，就像是薛定谔的猫一般，处在一个叠加态。</p><p>再谈谈一些个人的体会感悟吧：</p><ol><li>身体健康是第一位。</li><li>多关爱自己的父母。</li><li>多珍视自己的朋友。</li><li>学会换位思考。</li><li>一日三省吾身。</li><li>学无止境，终身学习。</li></ol><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>最后自然是设定来年的目标啦，这里简略地列出了一些目标：</p><ol><li>搭建好自己的博客网站；</li><li>持续写博客，尽量保持每周一篇，目标全年50篇以上；</li><li>写番剧回顾，回顾自己的看番历史，也算是给自己热爱这么久的二次元一个总结交代吧。可以的话再剪辑一些片段，最后做一个AMV或者MAD出来；</li><li>C++ 开发学习，包括语法和项目（比如写一个网站，服务器）；stackflow上解决C++ 问题，检验自己的知识成果，目标Reputation 过500；</li><li>算法强化，刷题，目标Leecode 300题；</li><li>书籍阅读</li></ol><ul><li>计算机相关书籍 10本；;</li><li>文学类小说等 5本；</li><li>其他杂项（金融理财、传记、为人处世等）3~5本；</li></ul><ol start="7"><li>健身，目标拥有腹肌；增强上肢力量，增强背部、核心力量，目标引体向上做10个以上；</li><li>参加一次大型比赛并获奖，满足毕业资格；</li><li>日语继续学习，可以做到基本的听和说。</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>写写停停，缝缝补补，最后是在2022年1月7日回家的高铁上，完成了这篇年度总结，突然感觉自己又行了呢，哈哈。希望在新的一年了，自己能有更大的成长吧，也衷地祝愿各位成为更好的自己~</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>年度总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的最佳日志实践</title>
    <link href="/2021/12/25/2021-12/2021-12-25%20%E6%88%91%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5/"/>
    <url>/2021/12/25/2021-12/2021-12-25%20%E6%88%91%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文译自：<a href="https://tuhrig.de/my-logging-best-practices/">https://tuhrig.de/my-logging-best-practices/</a></p></blockquote><p>如果你是一名后端开发者，那么日志就相当于你的应用的窗口。不像前端，除了日志消息外没有太多别的东西。接下来将介绍一些我个人写日志时的指导思想。</p><h1 id="Log-After-not-before"><a href="#Log-After-not-before" class="headerlink" title="Log After, not before"></a>Log After, not before</h1><p>回想以下以前，每艘船都会有一本航海日志，就像日记一样，记录着每天发生的重要事情。就像一本传统的航海日志，我们应该记录已经发生的事情，而不是我们将要做的事情。</p><p>举一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// don&#x27;t do that</span><br>log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Making request to REST API&quot;</span>)<br>restClient.<span class="hljs-built_in">makeRequest</span>()<br> <br><span class="hljs-comment">// do that</span><br>restClient.<span class="hljs-built_in">makeRequest</span>()<br>log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Made request to REST API&quot;</span>)<br></code></pre></td></tr></table></figure><p>第一个 log 声明并没有给出太多信息。当读到它的时候，你并不知道REST调用是否成功。而为了知道是否调用成功，你必须寻找是否存在异常。当你读到这条log，但是却没有找到相应的 exception 异常，你将会困惑一整天。</p><blockquote><p>这里感觉没太翻译明白，可以对照原文看：The first log statement doesn’t tell much. When reading it, you will not know if the REST call was successful or not. To do so you must look for the absence of an exception. And if you read this log but miss the subsequent exception you will be confused for the rest of the day (trust me).</p></blockquote><p>第二个 log 方式则好了许多。它清楚地表明了刚刚的操作成功了。如果REST调用失败了，你将看不到这条 log，而是会有一个 exception。</p><p>我将对所有 <strong>INFO</strong> 日志遵守这条规则，然后对于 <strong>DEBUG</strong> 来说会生成 exceptions。</p><h1 id="Separate-parameters-and-messages"><a href="#Separate-parameters-and-messages" class="headerlink" title="Separate parameters and messages"></a>Separate parameters and messages</h1><p>一个典型的 log 小心包含两种类型的数据，一种是手写的消息，来声明接下来的消息内容。另一种类型数据则是一系列包含在之前操作中的参数。你应该区分这两部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// don&#x27;t do that</span><br>restClient.<span class="hljs-built_in">makeRequest</span>()<br>log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Made request to &#123;&#125; on REST API.&quot;</span>, url)<br> <br><span class="hljs-comment">// do that</span><br>restClient.<span class="hljs-built_in">makeRequest</span>()<br>log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Made request to REST API. [url=&#123;&#125;]&quot;</span>, url)<br></code></pre></td></tr></table></figure><p>第一种 log 消息有一些缺点。它是难以解析的，比如他对于 Grok pattern</p><p>来说。所以在我们的日志工具中，自动抽取 IDs 或者其他参数就会变得更困难。并且它也是难以阅读的。想象一下，一个非常长的 URL 在末端带有一系列参数。该条 log 消息的一半就超过了你的屏幕。同时，这个 log 也是难以扩展的。如果你想添加另一个参数（比如使用的 HTTP 方法）你就必须重写整个句子。</p><p>第二个版本就没有以上的缺点。它是非常容易解析的，因为它有清晰的结构。你在句子的前部分就能看到整个句子的内容。并且也十分容易扩展，只需要在列表里添加另一个参数。</p><h1 id="Distinguish-between-WARNING-and-ERROR"><a href="#Distinguish-between-WARNING-and-ERROR" class="headerlink" title="Distinguish between WARNING and ERROR"></a>Distinguish between WARNING and ERROR</h1><p>显然，有多种级别的 log 是有它存在的原因的，你应该适当地使用它们。在 <strong>WARNING</strong> 和 <strong>ERROR</strong> 之间存在明显的区别。</p><p>如果你做一些操作并且切实生效了，但是依然存在一些问题，这就是 WARNING。当如果你做了一些操作，它并没有生效，那就是一个 ERROR。</p><p>再来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    restClient.<span class="hljs-built_in">makeRequest</span>()<br>    log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Made request to REST API. [url=&#123;&#125;]&quot;</span>, url)<br>&#125; <span class="hljs-built_in">catch</span>(e: UnauthorizedException) &#123;<br>    log.<span class="hljs-built_in">warn</span>(<span class="hljs-string">&quot;Request to REST API was rejected because user is unauthorized. [url=&#123;&#125;, result=&#123;&#125;]&quot;</span>, url, result)<br>&#125; <span class="hljs-built_in">catch</span>(e: Exception) &#123;<br>    log.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;Request to REST API failed. [url=&#123;&#125;, exception=&#123;&#125;]&quot;</span>, url, exception)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 REST 调用可能有三种输出情况：</p><ul><li>它可以正常工作。那就会有一个 INFO 输出。</li><li>当它失败了，遇到了一个预期外的异常，那就是一个 ERROR。</li><li>当它导致了一些预期内的异常，那就是 WARNING。</li></ul><p>所以在 WARNING 的例子中，你做了一些事情，但你没有完美地做好。而在 ERROR 中，你并没有做事情。</p><p>另外注意，一个 WARNING（当然 ERROR 也是）是一个调用动作。如果没有人需要对此做出反应或者要做些什么，那么你也就不必去 log 输出 WARNING。</p><h1 id="INFO-is-for-business-DEBUG-for-technology"><a href="#INFO-is-for-business-DEBUG-for-technology" class="headerlink" title="INFO is for business, DEBUG for technology"></a>INFO is for business, DEBUG for technology</h1><p>INFO 日志应该看起来像一本书，它告诉你发生了什么，而不是如何发生的。这意味着 INFO 更适合于业务逻辑消息，相比于技术细节来说。技术相关的消息应该使用 DEBUG。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">INFO  | User registered <span class="hljs-keyword">for</span> newsletter. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br>INFO  | Newsletter send to user. [user=<span class="hljs-string">&quot;Thomas&quot;</span>]<br>INFO  | User unsubscribed from newsletter. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br></code></pre></td></tr></table></figure><p>上面 INFO 类型的日志，从我们业务逻辑的视角告诉你发生了什么。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">DEBUG | Saved user to newsletter list. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br>DEBUG | Send welcome mail. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br>INFO  | User registered <span class="hljs-keyword">for</span> newsletter. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br>DEBUG | Started cron job to send newsletter of the day. [subscribers=24332]<br>INFO  | Newsletter send to user. [user=<span class="hljs-string">&quot;Thomas&quot;</span>]<br>INFO  | User unsubscribed from newsletter. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br></code></pre></td></tr></table></figure><p>每个业务用例都会导致一条 INFO 日志输出。此外，会有 DEBUG 日志来给出更多细节信息，来描述处理过程。</p><h1 id="Much-more"><a href="#Much-more" class="headerlink" title="Much more"></a>Much more</h1><p>当然，对于好的日志来说还有许多值得做的。你还需要考虑 tracing, log aggregation and metrics 。但当提及如何书写时，我非常推荐上面的规则。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算的“奇淫技巧”</title>
    <link href="/2021/12/18/2021-12/2021-12-18%20%E4%BB%8B%E7%BB%8D%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2021/12/18/2021-12/2021-12-18%20%E4%BB%8B%E7%BB%8D%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>原文来源：<a href="https://catonmat.net/low-level-bit-hacks">https://catonmat.net/low-level-bit-hacks</a></p></blockquote><p>介绍一些位运算的技巧，比如对应计算一个二进制整数中 1 bit的个数，不是通过循环遍历每一bit 是否为1，而是可以选择一些 tricky 的位运算来完成。</p><p>先来介绍一下本文中所使用的一些位运算操作符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">&amp;    -  bitwise and  位与<br>|    -  bitwise or     位或<br>^    -  bitwise xor    异或<br>~    -  bitwise not    取反<br>&lt;&lt;   -  bitwise shift left    左移<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;   -  bitwise <span class="hljs-built_in">shift</span> right  右移</span><br></code></pre></td></tr></table></figure><p>在这篇文章中，表示的数字均为 8 bit 有符号整数（但是上述这些操作是可以在任意长度的有符号整数上执行的），并用 ‘x’ 来表示，而位运算计算后的结果用 ‘y’ 来表示。 其中 ‘x’ 的每一bit，使用 b<del>7</del>, b<del>6</del>, b<del>5</del>, b<del>4</del>, b<del>3</del>, b<del>2</del>, b<del>1</del>, b<del>0</del> 来表示，b<del>7</del> 是权重最高位（在符号数里就是符号位），b<del>0</del> 是权重最小的位。</p><p>接下来会先基本的bit hacks 介绍，然后逐渐深入到更高效的方法。</p><h1 id="1-检验一个整数的奇偶性"><a href="#1-检验一个整数的奇偶性" class="headerlink" title="1. 检验一个整数的奇偶性"></a>1. 检验一个整数的奇偶性</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">if</span> ((x &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>  x <span class="hljs-keyword">is</span> even<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>  x <span class="hljs-keyword">is</span> odd<br>&#125;<br></code></pre></td></tr></table></figure><p>相信很多人都已经看到过上述的技巧，其最基本的思想就是如果一个整数是奇数，那么它的最低位 b<del>0</del> 就为1。通过 将 ‘x’ 和 1 进行 <strong>AND-ing</strong> 操作，忽略其他bits，只关注 b<del>0</del> 即可，如果结果为0 表示 ‘x’ 是偶数，结果为1 表示 ‘x’ 是奇数。</p><p>举个例子，比如数字43，二进制表示为00101011，通过与 1 进行 <strong>AND-ing</strong> 操作，清除更高位的数值而只保留 b<del>0</del> ，最终剩余结果为 1 就表示整数为奇数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    <span class="hljs-number">00101011</span><br>&amp;   <span class="hljs-number">00000001</span>   (note: <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> the same <span class="hljs-keyword">as</span> <span class="hljs-number">00000001</span>)<br>    --------<br>    <span class="hljs-number">00000001</span><br></code></pre></td></tr></table></figure><p>再举一个偶数的例子98，其二进制表示为1100010。在 <strong>AND-ing</strong> 操作后，最终结果为0，因此98是一个偶数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    <span class="hljs-number">01100010</span><br>&amp;   <span class="hljs-number">00000001</span><br>    --------<br>    <span class="hljs-number">00000000</span><br></code></pre></td></tr></table></figure><h1 id="2-检验第n位-bit-是否置1"><a href="#2-检验第n位-bit-是否置1" class="headerlink" title="2. 检验第n位 bit 是否置1"></a>2. 检验第n位 bit 是否置1</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">if</span> (x &amp; (<span class="hljs-number">1</span>&lt;&lt;n)) &#123;<br>  n-th bit <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>  n-th bit <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">set</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在先前的第一个例子，我们看到了通过 <code>（x &amp; 1）</code>来检验第一位 b0 是否置1，这个技巧可以通过改善实现检验第n位是否置1。主要做法就是将 1 左移n个位置，然后做相同的<strong>AND</strong> 操作，将除了第n位的其他bits清0。</p><p>下面演示了当你将 1 左移不同位数的结果：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-number">1</span>         <span class="hljs-number">00000001</span>    (same <span class="hljs-keyword">as</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>)<br><span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>      <span class="hljs-number">00000010</span><br><span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>      <span class="hljs-number">00000100</span><br><span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>      <span class="hljs-number">00001000</span><br><span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>      <span class="hljs-number">00010000</span><br><span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>      <span class="hljs-number">00100000</span><br><span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>      <span class="hljs-number">01000000</span><br><span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>      <span class="hljs-number">10000000</span><br></code></pre></td></tr></table></figure><p>现在，我们将 ‘x’ 与  左移n位的 数字1 进行 AND 操作，就可以保留 ‘x’上第n位bit （对于 b0 来说是第0位）而将其他bit 清零。所以如果最终结果为0，表明对应bit 是0，最终结果不为0，表明对应bit置为1。</p><p>接下来给出一些例子，比如说 122 的第3rd bit 是否置为1，我们可以通过<code>122 &amp; (1&lt;&lt;3)</code>来实现，具体来说如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    <span class="hljs-number">01111010</span><br>&amp;   <span class="hljs-number">00001000</span><br>    --------<br>    <span class="hljs-number">00001000</span><br></code></pre></td></tr></table></figure><p>可以看到最终结果不为0，因此122 对应的 3rd bit 是置为1的。</p><p>注意：在本文中，bit 的位数下标从0开始，也就是第0位bit，第1位bit ，…， 第7位 bit。</p><h1 id="3-将第n位-bit-置-1"><a href="#3-将第n位-bit-置-1" class="headerlink" title="3. 将第n位 bit 置 1"></a>3. 将第n位 bit 置 1</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">y = x | (<span class="hljs-number">1</span> &lt;&lt; n)<br></code></pre></td></tr></table></figure><p>这个 bit hack 结合了左移 (1&lt;&lt;n) 和 <strong>OR</strong> 运算的技巧，<code>y = x | (1&lt;&lt;n)</code>通过和一个第n位 置1 的数值进行 <strong>OR</strong> 运算就可以使得 ‘x’ 的第n位 置1。因为和 0 进行 OR-ing 数值保持不变，和 1 进行 OR-ing 对应bit变为1（如果不是1的话）。</p><p>同样给出一个例子，对于数120，我们希望将其 2nd bit 置为1，如下所示</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    <span class="hljs-number">01111000</span>    (<span class="hljs-number">120</span> <span class="hljs-keyword">in</span> binary)<br>|   <span class="hljs-number">00000100</span>    (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>)<br>    --------<br>    <span class="hljs-number">01111100</span><br></code></pre></td></tr></table></figure><h1 id="4-将第n位-bit-置-0"><a href="#4-将第n位-bit-置-0" class="headerlink" title="4. 将第n位 bit 置 0"></a>4. 将第n位 bit 置 0</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">y = x &amp; ~(<span class="hljs-number">1</span>&lt;&lt;n)<br></code></pre></td></tr></table></figure><p>这个bit hack 主要通过<code> y = x &amp; ~(1&lt;&lt;n)</code>实现，<code>~(1&lt;&lt;n)</code>起到的作用是将除了第n位置0，其余位置1，比如下面这样：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#">~<span class="hljs-number">1</span>        <span class="hljs-number">11111110</span>  (same <span class="hljs-keyword">as</span> ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>))<br>~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>)   <span class="hljs-number">11111101</span><br>~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>)   <span class="hljs-number">11111011</span><br>~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>)   <span class="hljs-number">11110111</span><br>~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>)   <span class="hljs-number">11101111</span><br>~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>)   <span class="hljs-number">11011111</span><br>~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>)   <span class="hljs-number">10111111</span><br>~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>)   <span class="hljs-number">01111111</span><br></code></pre></td></tr></table></figure><p>再通过 AND-ing 操作，就可以使得将 ‘x’ 的第n位置0，因为 AND-ing 中有个 bit 为0，结果 bit 就为0。下面给出数127，将第4位 bit 置0的例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    <span class="hljs-number">01111111</span>    (<span class="hljs-number">127</span> <span class="hljs-keyword">in</span> binary)<br>&amp;   <span class="hljs-number">11101111</span>    (~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>))<br>    --------<br>    <span class="hljs-number">01101111</span><br></code></pre></td></tr></table></figure><h1 id="5-反转第n位-bit"><a href="#5-反转第n位-bit" class="headerlink" title="5. 反转第n位 bit"></a>5. 反转第n位 bit</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">y</span> = x ^ (<span class="hljs-number">1</span>&lt;&lt;n)<br></code></pre></td></tr></table></figure><p>这个bit hack 主要实现方式为<code>y = x ^ (1&lt;&lt;n)</code>，结合了左移和XOR 运算。<code>(1&lt;&lt;n)</code>将对应的第n位置1，而通过 XOR 运算，如果 ‘x’ 第n位为0，就会变为1，如果第n位为1，就会变为0，从而实现反转的效果。</p><p> 下面给出一个例子，将 01110101 的第5位进行反转：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    <span class="hljs-number">01110101</span><br>^   <span class="hljs-number">00100000</span><br>    --------<br>    <span class="hljs-number">01010101</span><br></code></pre></td></tr></table></figure><h1 id="6-将最右边的1-bit置为0"><a href="#6-将最右边的1-bit置为0" class="headerlink" title="6. 将最右边的1-bit置为0"></a>6. 将最右边的1-bit置为0</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">y</span> = x &amp; (x-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>该方式主要通过<code>y = x &amp; (x-1)</code>来实现。比如对于一个整数 001010<strong>1</strong>0（最右边的1用黑体标出），当将最后边的1-bit置为0后，就变成了001010<strong>0</strong>0（对应位变成了0）。</p><p>这里给出更多的例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#">    <span class="hljs-number">01011000</span>    (x)<br>&amp;   <span class="hljs-number">01010111</span>    (x<span class="hljs-number">-1</span>)<br>    --------<br>    <span class="hljs-number">01010000</span><br><br>    <span class="hljs-number">10000000</span>    (x = <span class="hljs-number">-128</span>)<br>&amp;   <span class="hljs-number">01111111</span>    (x<span class="hljs-number">-1</span> = <span class="hljs-number">127</span> (<span class="hljs-keyword">with</span> overflow))<br>    --------<br>    <span class="hljs-number">00000000</span><br><br>    <span class="hljs-number">11111111</span>    (x = all bits <span class="hljs-number">1</span>)<br>&amp;   <span class="hljs-number">11111110</span>    (x<span class="hljs-number">-1</span>)<br>    --------<br>    <span class="hljs-number">11111110</span><br><br>    <span class="hljs-number">00000000</span>    (x = no rightmost <span class="hljs-number">1</span>-bits)<br>&amp;   <span class="hljs-number">11111111</span>    (x<span class="hljs-number">-1</span>)<br>    --------<br>    <span class="hljs-number">00000000</span><br></code></pre></td></tr></table></figure><p>这是如何实现的呢，主要有两个可能的场景：</p><ol><li>该整数值存在一个最右边的1-bit。在这种情况下，当该数值减去1后，会将该二进制数的最右边的1-bit置为0，同时其右边所有低位的0变成1（就是一个减法得到的结果）。这个减法操作得到的结果，相当于已经把最右边的1-bit置0，然后再通过和原始值进行AND-ing 操作，就可以把低位的1都置为0。</li><li>当该二进制数不存在一个最右边的 1-bit（全为0）。那么在这种情况下，减1后会下溢，即所有 bit 置为 1 ，那么再和原始值（全0）进行AND-ing操作得到的也还是0。</li></ol><h1 id="7-只保留最右边的-1-bit"><a href="#7-只保留最右边的-1-bit" class="headerlink" title="7. 只保留最右边的 1-bit"></a>7. 只保留最右边的 1-bit</h1><p class='note note-info'>y = x & (-x)</p><p>该方法通过<code> y = x &amp; (-x)</code>实现，将只保留 x 的最右边的 1-bit ，把其他位都置为0。比如对于 01010<strong>1</strong>00 (最右侧 1 用黑体标出)，得到的结果为 00000<strong>1</strong>00。</p><p>这里再给出更多的例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C#">    <span class="hljs-number">01110000</span>  (x)<br>&amp;   <span class="hljs-number">10010000</span>  (-x)<br>    --------<br>    <span class="hljs-number">00010000</span><br><br>    <span class="hljs-number">00000001</span>  (x)<br>&amp;   <span class="hljs-number">11111111</span>  (-x)<br>    --------<br>    <span class="hljs-number">00000001</span><br><br>    <span class="hljs-number">10000000</span>  (x = <span class="hljs-number">-128</span>)<br>&amp;   <span class="hljs-number">10000000</span>  (-x = <span class="hljs-number">-128</span>)<br>    --------<br>    <span class="hljs-number">10000000</span><br><br>    <span class="hljs-number">11111111</span>  (x = all bits one)<br>&amp;   <span class="hljs-number">00000001</span>  (-x)<br>    --------<br>    <span class="hljs-number">00000001</span><br><br>    <span class="hljs-number">00000000</span>  (x = all bits <span class="hljs-number">0</span>, no rightmost <span class="hljs-number">1</span>-bit)<br>&amp;   <span class="hljs-number">00000000</span>  (-x)<br>    --------<br>    <span class="hljs-number">00000000</span><br></code></pre></td></tr></table></figure><p><strong>接下来探讨其实现原理。主要就是依赖于在计算机中， -x （对应的负数）跟 ~x+1 （按位取反后加1） 是一样的。</strong></p><p>不妨设 x 最右边的 1-bit 为b<del>i</del>，以下标 i 为界，将 b<del>i</del> 左侧的 bits 位设为 b<del>i+1</del>, …, b<del>n</del>，将 b<del>i</del> 右侧的所有 bits 位设为 b<del>i-1</del>, b<del>i-2</del> , … , b<del>0</del> （位于右侧的全为 0 ，因为 b<del>i</del> 是最右侧的 1 ）。</p><p>现在当我计算 -x ，首先做取反操作 <del>x ，也就是将 b</del>i~ 置为0， b<del>i-1</del>…b<del>0</del> 都置为 1，将 b<del>i+1</del> … b<del>n</del> 等位进行反转。然后做加 1 操作。因为 b<del>i-1</del>…b<del>0</del> 都为1，所以加 1 后会想 b<del>i</del> 进位（因为 b<del>i</del> 是第一个 0 bit ）。</p><p>此时我们不难发现，对于 -x ，b<del>i+1</del> … b<del>n</del> 等位反转了， b<del>i</del> 依然保持不变，b<del>i-1</del>…b<del>0</del> 也依然全为 0 。所以现在将 x 与 -x 进行 AND-ing 操作，就可以使得 b<del>i+1</del> … b<del>n</del> 置为 0 ，b<del>i</del> 保持 1， b<del>i-1</del>…b<del>0</del> 也全为 0 。只有一个 bit 保留了下来，就是最右边的 1-bit 。</p><h1 id="8-将最右边-1-bit-右侧的所有低位-bit-置-1"><a href="#8-将最右边-1-bit-右侧的所有低位-bit-置-1" class="headerlink" title="8. 将最右边 1-bit 右侧的所有低位 bit 置 1"></a><strong>8. 将最右边 1-bit 右侧的所有低位 bit 置 1</strong></h1><p class='note note-info'>y = x | (x-1)</p><p>具体实现就是 <code>y = x | (x-1)</code> 。这个翻译过来有点拗口，给个例子就能理解了，给出数 010<strong>1</strong>0000 ，执行后就得到 010<strong>11111</strong>，原来最右边 1-bit 右边的低位都置为1 。接下来看更多的一些例子。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C#">    <span class="hljs-number">10111100</span>  (x)<br>|   <span class="hljs-number">10111011</span>  (x<span class="hljs-number">-1</span>)<br>    --------<br>    <span class="hljs-number">10111111</span><br><br>    <span class="hljs-number">01110111</span>  (x)<br>|   <span class="hljs-number">01110110</span>  (x<span class="hljs-number">-1</span>)<br>    --------<br>    <span class="hljs-number">01110111</span><br><br>    <span class="hljs-number">00000001</span>  (x)<br>|   <span class="hljs-number">00000000</span>  (x<span class="hljs-number">-1</span>)<br>    --------<br>    <span class="hljs-number">00000001</span><br><br>    <span class="hljs-number">10000000</span>  (x = <span class="hljs-number">-128</span>)<br>|   <span class="hljs-number">01111111</span>  (x<span class="hljs-number">-1</span> = <span class="hljs-number">127</span>)<br>    --------<br>    <span class="hljs-number">11111111</span><br><br>    <span class="hljs-number">11111111</span>  (x = <span class="hljs-number">-1</span>)<br>|   <span class="hljs-number">11111110</span>  (x<span class="hljs-number">-1</span> = <span class="hljs-number">-2</span>)<br>    --------<br>    <span class="hljs-number">11111111</span><br><br>    <span class="hljs-number">00000000</span>  (x)<br>|   <span class="hljs-number">11111111</span>  (x<span class="hljs-number">-1</span>)<br>    --------<br>    <span class="hljs-number">11111111</span><br></code></pre></td></tr></table></figure><p>这个方法的实现原理跟方法6很像，所以这里就不再证明了。</p><h1 id="9-保留最右边的-0-bit"><a href="#9-保留最右边的-0-bit" class="headerlink" title="9. 保留最右边的 0-bit"></a><strong>9. 保留最右边的 0-bit</strong></h1><p class='note note-info'>y = ~x & (x+1)</p><p>该方法的实现为<code> y = ~x &amp; (x+1)</code> 。该方法与方法7正好相反，它是找到最右侧的 0-bit，将其他位都置为0，将该 bit 置为 1 。距离来说，给定数 10101<strong>0</strong>11，经过处理后的结果为，00000<strong>1</strong>00。再给出更多的例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C#">    <span class="hljs-number">01110111</span>  (x)<br>    --------<br>    <span class="hljs-number">10001000</span>  (~x)<br>&amp;   <span class="hljs-number">01111000</span>  (x+<span class="hljs-number">1</span>)<br>    --------<br>    <span class="hljs-number">00001000</span><br><br>    <span class="hljs-number">00000001</span>  (x)<br>    --------<br>    <span class="hljs-number">11111110</span>  (~x)<br>&amp;   <span class="hljs-number">00000010</span>  (x+<span class="hljs-number">1</span>)<br>    --------<br>    <span class="hljs-number">00000010</span><br><br>    <span class="hljs-number">10000000</span>  (x = <span class="hljs-number">-128</span>)<br>    --------<br>    <span class="hljs-number">01111111</span>  (~x)<br>&amp;   <span class="hljs-number">10000001</span>  (x+<span class="hljs-number">1</span>)<br>    --------<br>    <span class="hljs-number">00000001</span><br><br>    <span class="hljs-number">11111111</span>  (x = no rightmost <span class="hljs-number">0</span>-bit)<br>    --------<br>    <span class="hljs-number">00000000</span>  (~x)<br>&amp;   <span class="hljs-number">00000000</span>  (x+<span class="hljs-number">1</span>)<br>    --------<br>    <span class="hljs-number">00000000</span><br><br>    <span class="hljs-number">00000000</span>  (x)<br>    --------<br>    <span class="hljs-number">11111111</span>  (~x)<br>&amp;   <span class="hljs-number">00000001</span>  (x+<span class="hljs-number">1</span>)<br>    --------<br>    <span class="hljs-number">00000001</span><br></code></pre></td></tr></table></figure><p><strong>接下来给出证明</strong>。与之前类似，不妨设最右边的 0-bit 设置为 b<del>i</del> ，将 b<del>i</del> 左侧的 bits 位设为 b<del>i+1</del>, …, b<del>n</del>，将 b<del>i</del> 右侧的所有 bits 位设为 b<del>i-1</del>, b<del>i-2</del> , … , b<del>0</del> （位于右侧的全为 1 ，因为 b<del>i</del> 是最右侧的 0 ）。</p><p>那么对于 <del>x 来说，将所有位进行反转，包括最右侧的 0-bit，b</del>i~ 也从 0 变成了 1 。</p><p>对于 x+1 来说，因为 b<del>i-1</del>, b<del>i-2</del> , … , b<del>0</del> 全为1，加 1 之后会向 b<del>i</del> 进位，因此 b<del>i</del> 也变成了 1，b<del>i-1</del>, b<del>i-2</del> , … , b<del>0</del> 都变成了0，而高位  b<del>i+1</del>, …, b<del>n</del> 保持不变。</p><p>此时再将 <del>x 与 x+1 进行 AND-ing 操作，就只有 b</del>i~ 位保留下来，其他位均为 0 。</p><h1 id="10-将最右侧的-0-bit-置为1"><a href="#10-将最右侧的-0-bit-置为1" class="headerlink" title="10. 将最右侧的 0-bit 置为1"></a><strong>10. 将最右侧的 0-bit 置为1</strong></h1><p class='note note-info'>y = x | (x+1)</p>该方法实现为 `y = x | (x+1)`。主要就是将最右侧的 0-bit 置为1，例如对于数 10100**0**11 经过运算后，得到结果 10100**1**11。给出更多的例子：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C#">    <span class="hljs-number">10111100</span>  (x)<br>|   <span class="hljs-number">10111101</span>  (x+<span class="hljs-number">1</span>)<br>    --------<br>    <span class="hljs-number">10111101</span><br><br>    <span class="hljs-number">01110111</span>  (x)<br>|   <span class="hljs-number">01111000</span>  (x+<span class="hljs-number">1</span>)<br>    --------<br>    <span class="hljs-number">01111111</span><br><br>    <span class="hljs-number">00000001</span>  (x)<br>|   <span class="hljs-number">00000010</span>  (x+<span class="hljs-number">1</span>)<br>    --------<br>    <span class="hljs-number">00000011</span><br><br>    <span class="hljs-number">10000000</span>  (x = <span class="hljs-number">-128</span>)<br>|   <span class="hljs-number">10000001</span>  (x+<span class="hljs-number">1</span>)<br>    --------<br>    <span class="hljs-number">10000001</span><br><br>    <span class="hljs-number">11111111</span>  (x = no rightmost <span class="hljs-number">0</span>-bit)<br>|   <span class="hljs-number">00000000</span>  (x+<span class="hljs-number">1</span>)<br>    --------<br>    <span class="hljs-number">11111111</span><br><br>    <span class="hljs-number">00000000</span>  (x)<br>|   <span class="hljs-number">00000001</span>  (x+<span class="hljs-number">1</span>)<br>    --------<br>    <span class="hljs-number">00000001</span><br></code></pre></td></tr></table></figure><p> 正确性也非常好理解。x+1 的操作将原来 x 的最右侧的 0-bit， b<del>i</del> 置为1，b<del>i-1</del>, b<del>i-2</del> , … , b<del>0</del> 都变成了0，而高位  b<del>i+1</del>, …, b<del>n</del> 保持不变。此时再和 x 做 OR-ing 运算，就可以使得原来 x 的最右侧 0-bit  b<del>i</del> 置为 1。</p><h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>一个简单的C语言函数，实现打印一个数字的低8位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">int_to_bin</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>  <span class="hljs-type">char</span> str[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">7</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>    str[i] = (num&amp;<span class="hljs-number">1</span>)?<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;<br>    num &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>椭圆曲线公钥恢复算法与SM2编程实现</title>
    <link href="/2021/12/13/2021-12/2021-12-13%20%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95%E4%B8%8ESM2%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/12/13/2021-12/2021-12-13%20%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95%E4%B8%8ESM2%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="椭圆曲线公钥恢复算法"><a href="#椭圆曲线公钥恢复算法" class="headerlink" title="椭圆曲线公钥恢复算法"></a>椭圆曲线公钥恢复算法</h1><p>在以太坊中，交易消息中不包含“from”字段（即交易发起者的地址），这是因为交易发起者的公钥可以直接从ECDSA签名中计算出来。而一旦你有公钥，就可以很容易地计算出对应的地址。恢复签名者公钥的过程称为公钥恢复，对应的算法即为公钥恢复算法。</p><p>接下来描述以太坊中公钥恢复算法的过程。</p><p>首先根据给定 ECDSA签名算法 中计算的值 <strong>r</strong> 和 <strong>s</strong>，我们可以计算得到两个可能的公钥。我们根据签名中的 <strong>x</strong> 坐标 <strong>r</strong> 值计算两个椭圆曲线点 <strong>R</strong> 和 **R’**。对于 r 值，计算它关于 n 的逆元 $r^{-1}$，其中 n 是椭圆曲线的阶数。最后计算 e ，它是消息的散列值。然后可以得到两个可能的公钥：<br>$$<br>K_1 &#x3D; r^{-1} (sR - eG)<br>$$<br>$$<br>K_2 &#x3D; r^{-1} (sR’ - eG)<br>$$</p><p>其中:</p><ul><li><p>K<del>1</del> 和 K<del>2</del> 是签名者公钥的两种可能性</p></li><li><p>r^-1^是签名的 r 值的逆元</p></li><li><p>s 是签名的 s 值</p></li><li><p>R 和 R’ 是临时公钥 Q 的两种可能性</p></li><li><p>e 是消息散列的最低位</p></li><li><p>G 是椭圆曲线生成点</p></li></ul><p>为了使计算更有效率，在以太坊交易签名里包括一个前缀值 v，它告诉我们两个可能的R值中哪一个是真正临时的公钥。如果 v 是偶数，那么R是正确的值。如果 v 是奇数，那么选择R’。这样，我们只需要计算R的一个值。这也就是以太坊交易中签名数据的（v, r, s）。</p><h2 id="椭圆曲线上点的压缩"><a href="#椭圆曲线上点的压缩" class="headerlink" title="椭圆曲线上点的压缩"></a>椭圆曲线上点的压缩</h2><p>在上述过程，有一个地方可能还没有解释清楚，那就是为什么一个 x 坐标会对应有两个椭圆曲线上的点？其实这里用到了椭圆曲线上点的压缩和解压缩方法。</p><p>根据椭圆曲线方程，我们只需要知道 x 坐标，就可以通过方程计算出 y 坐标，这样就不用同时保存x，y的值，减少了存储和带宽。但是如果只知道x，带入方程会求出两个y，一正一负，对应两个不同的点，所以还必须有一个标志来区别实际使用的是哪个。在以太坊中就采用了压缩公钥格式，具体格式为：</p><ul><li>前缀02 + x （当y为偶数）</li><li>前缀03 + x （当y为奇数）</li></ul><p>为什么y一定是一奇一偶呢，刚刚不是说一正一负吗？</p><p>假设 y 是方程的一个解，那么 -y 也是方程的一个解，但在模运算的规则下，<code>-y ≡ p - y (mod p)</code>，所以 p-y 也是方程的解，y-p 也是方程的解，但是在mod p 的有限域中，取值范围是[0, p-1]，没有负数，所以 -y 和 y-p 在椭圆曲线上取不到，最终得到就是两个解 y 和 p-y，因为p是大素数，所以 y 和 p-y 一定是一奇一偶。</p><p>在<a href="http://www.oscca.gov.cn/sca/xxgk/2010-12/17/1002386/files/b791a9f908bb4803875ab6aeeb7b4e03.pdf">《SM2椭圆曲线公钥密码算法》</a>中也谈及了椭圆曲线上点的压缩和解压缩方法，如下图所示：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202112132204090.(null)" alt="椭圆曲线上点的压缩与解压缩"></p><h2 id="椭圆曲线签名过程"><a href="#椭圆曲线签名过程" class="headerlink" title="椭圆曲线签名过程"></a>椭圆曲线签名过程</h2><p>在推导椭圆曲线公钥算法之前，还需要先回顾了解下椭圆曲线的签名过程。</p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202112132204793.(null)" alt="" style="zoom:67%;" /><ol><li>随机选择一个临时私钥 k 值，范围在 [1, n-1]，其中 n 为椭圆曲线的阶数</li><li>计算临时公钥 kG &#x3D; (x , y)</li><li>计算 r 值， r &#x3D; x mod n，如果 r 为0则返回第1步重新选择私钥 k</li><li>计算消息散列值，e &#x3D; H(m)</li><li>计算 s 值，$s &#x3D; k^{-1} (e + dr) \ mod \ n$，其中 d 是签名者的私钥，如果算得 s 为0则返回第一步重新选择 k</li><li>最终得到签名 (r, s)</li></ol><p>对应签名的验证过程如下：</p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202112132204418.(null)" alt="椭圆曲线签名的验证过程" style="zoom:67%;" /><ol><li>检验 r, s 是否满足取值范围 [1, n-1]</li><li>计算消息散列值， e  &#x3D; H(m)</li><li>计算 s 的逆元，$w &#x3D; s^{-1} \ mod\  n$</li><li>计算 $u_1 &#x3D; ew \ mod \ n，u_2 &#x3D; rw \ mod \ n$</li><li>计算 $X &#x3D; (x, y) &#x3D; u_1G + u_2Q$。 其中G是生成元，Q是签名者的公钥。如果X为无穷远点则验签失败。</li><li>计算 v &#x3D; x mod n</li><li>如果 v &#x3D; r 则验签成功，否则失败</li></ol><p>椭圆曲线签名和验证的正确性证明如下所示：</p><p>$$<br>k ≡ s^{-1}(e + dr) ≡ s^{-1}e + s^{-1}rd ≡we + wrd ≡ u_1 + u_2d (mod \ n)<br>$$</p><p>$$<br>X &#x3D; u_1G + u_2Q &#x3D; (u_1+u_2d)G &#x3D; kG<br>$$</p><p>即验签时计算的X与签名时的临时公钥是相等的，对应的 x 坐标也相等，所以验签时判断 v 值是否等于 r 值即可。</p><h2 id="椭圆曲线公钥恢复算法推导"><a href="#椭圆曲线公钥恢复算法推导" class="headerlink" title="椭圆曲线公钥恢复算法推导"></a>椭圆曲线公钥恢复算法推导</h2><p> 好的，前序准备都已经完成，现在来推导公钥恢复算法，这里主要用到了签名过程中的相关计算。</p><p>设临时公钥为R，即R &#x3D; kG</p><p>$$<br>s &#x3D; k^{-1} (e + dr) \ mod \ n  \quad ⇒ \quad k &#x3D; s^{-1} (e + dr) \ mod \ n<br>$$</p><p>$$<br>kG &#x3D; s^{-1} (e + dr) \ G  \quad ⇒ \quad R &#x3D; s^{-1}(eG+rQ) \quad ⇒ \quad Q &#x3D; r^{-1}(sR-eG)<br>$$</p><p>因为通过 r 值可以计算逆元 r^-1^，s 值已知，消息散列e和生成元G已知，临时公钥 R 可以通过 r（对应公钥的x坐标）利用椭圆曲线上点的解压缩方法求解，因此公钥 Q 是可以被计算出来的。</p><p>在 <a href="http://www.secg.org/sec1-v2.pdf">椭圆曲线标准</a> 中也描述了普通椭圆曲线公钥恢复算法的实现，如下图所示。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202112132204527.(null)" alt="椭圆曲线标准中定义的公钥恢复算法"></p><h1 id="SM2公钥恢复算法编程实现"><a href="#SM2公钥恢复算法编程实现" class="headerlink" title="SM2公钥恢复算法编程实现"></a>SM2公钥恢复算法编程实现</h1><p>因为SM2公钥签名算法和以太坊上椭圆曲线的签名算法不太一样，所以需要先了解SM2的签名过程，然后再推导SM2对应的公钥恢复算法。</p><h2 id="SM2签名与验证过程"><a href="#SM2签名与验证过程" class="headerlink" title="SM2签名与验证过程"></a>SM2签名与验证过程</h2><p>根据官方的 <a href="http://www.oscca.gov.cn/sca/xxgk/2010-12/17/1002386/files/b791a9f908bb4803875ab6aeeb7b4e03.pdf">SM2 椭圆曲线公钥密码算法</a> 可以找到SM2算法的签名过程。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202112132204885.(null)" alt="SM2签名计算过程"></p><ul><li>设待签名的消息为M，为了获取消息M的数字签名(r,s)，作为签名者的用户A应实现以下运算步骤：</li></ul><ol><li>置  $\overline{M} &#x3D; Z_A || M$</li><li>计算消息散列值，$e &#x3D; H(\overline{M})$，并将e的数据类型转换为整数</li><li>用随机数发生器产生随机数 k，取值范围 [1, n-1]</li><li>计算椭圆曲线上的点（也就是临时公钥），$(x_1,y_1) &#x3D; kG$，并将$x_1$数据类型转换为整数</li><li>计算 $r &#x3D; (e+x_1) \ mod \ n$，若 r &#x3D; 0 或 r+k &#x3D; n 则 返回第3步，重新选择k</li><li>计算 $s &#x3D; ((1 + d_A)^{-1} \ · \ (k-r\ ·\ d_A ) ) \ mod \ n$，若s &#x3D; 0 则返回第3步</li><li>将r、s类型转换为字符串，得到消息M的签名(r, s)</li></ol><p>SM2数字签名的算法流程图如下所示。</p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202112132204893.(null)" width="60%" height="60%" align="middle" > </center><p><strong>SM2验证过程</strong></p><ul><li>为了检验收到消息M’及其数字签名(r’,s’)，作为验证者的用户B应实现以下运算步骤：</li></ul><ol><li>检验 r’ 是否在 [1, n-1] 范围内</li><li>检验 s’ 是否在 [1, n-1] 范围内</li><li>置$\overline{M}’ &#x3D; Z_A \ || \  M’$</li><li>计算消息散列值，$e &#x3D; H(\overline{M}’)$，并将e的数据类型转换为整数</li><li>将 r’ , s’ 数据类型转换为整数，计算 $t &#x3D; (r’ + s’) \ mod \ n$</li><li>计算椭圆曲线点 $(x_1’, y_1’) &#x3D; [s’]G + [t]P_A$</li><li>计算$R &#x3D; (e’ + x_1’) \ mod \ n$，检验 R &#x3D; r’ 是否成立，如果成立则验证通过，否则验证不通过</li></ol><p>SM2数字签名的验证过程如下图所示。</p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202206020848485.png" width="60%" height="60%" align="middle" > </center><h2 id="SM2公钥恢复算法"><a href="#SM2公钥恢复算法" class="headerlink" title="SM2公钥恢复算法"></a>SM2公钥恢复算法</h2><p>跟椭圆曲线中方法类似，从SM2签名算法的相关计算中，可以推导出对应的公钥恢复算法 。</p><p>$$s &#x3D; ((1 + d_A)^{-1} \ · \ (k-r\ ·\ d_A ) ) \ mod \ n \quad ⇒  $$</p><p>$$\quad k&#x3D; (1+d_A)s + rd_A &#x3D; (s + (s+r)d_A) \ mod \ n$$</p><p>设 $R &#x3D; kG \quad\quad t &#x3D; r+s$，</p><p>$$kG &#x3D; (s+(s+r)d_A)G \quad ⇒ \quad R &#x3D; sG+tP_A \quad ⇒ \quad P_A &#x3D; t^{-1}(R-sG)$$</p><p>因为r，s值可以计算得到t，进而得到t的逆元 $t^{-1}$，R 可以通过$x_1 &#x3D; r - e \ mod \ n$，并利用椭圆曲线的压缩方法计算得到。s和G也都已知，因此，是可以计算得到公钥$P_A$</p><h2 id="代码结构说明"><a href="#代码结构说明" class="headerlink" title="代码结构说明"></a>代码结构说明</h2><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202112132204132.(null)" width="30%" height="30%" align="middle" > </center>附件代码结构如上图所示：<ul><li>cryptopp：该目录是开源库CryptoPP 的文件目录</li><li>test：测试文件目录，存放测试类TestCrypto，主要测试CryptoPP的相关API，模拟椭圆曲线的签名、验证以及公钥恢复算法；还有就是测试自定义实现的SM2 的签名、验证以及公钥恢复算法</li><li>util：该目录下，util类是cryptopp方法的封装，SM2是自定义实现类</li><li>main.cpp：实现测试函数</li></ul><h2 id="编程实现说明"><a href="#编程实现说明" class="headerlink" title="编程实现说明"></a>编程实现说明</h2><p>当了解了算法原理之后，实现起来就比较容易了，只要根据公式进行编程即可。在实现上借助了开源的CryptoPP库，来支持密码学里中原语操作，比如有限域上的计算，椭圆曲线上点的运算等。代码上主要是实现了一个<code>SM2</code>类，定义了签名，验证和公钥恢复算法，具体的代码实现这里不再展示，可见代码附件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 借助CryptoPP开源库 实现 SM2算法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SM2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 签名：输入的消息和输出的签名数据  均为字节格式，签名是由(r,s)各32字节拼接得到的</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sign</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;message, std::string &amp;signature)</span></span>;<br>    <span class="hljs-comment">// 验证：输入的消息和签名均为字节格式，输出为bool值</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Verify</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;message, <span class="hljs-type">const</span> std::string &amp;signature)</span></span>;<br>    <span class="hljs-comment">// 公钥恢复算法，输入消息，签名（r,s），y值是否为奇数， 输出pubKey 字节格式，由(x,y) 各32字节拼接而成</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RecoverPublicKey</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;message, <span class="hljs-type">bool</span> isOdd,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> Integer &amp;r, <span class="hljs-type">const</span> Integer &amp;s, std::string &amp;pubKey)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">private</span>:</span><br><span class="hljs-function">    std::shared_ptr&lt;ECP&gt; ecp;</span>                   <span class="hljs-comment">// SM2 对应的椭圆曲线</span><br>    std::shared_ptr&lt;Integer&gt; p;<br>    std::shared_ptr&lt;Integer&gt; a;<br>    std::shared_ptr&lt;Integer&gt; b;<br>    std::shared_ptr&lt;Integer&gt; privateKey;        <span class="hljs-comment">// 私钥</span><br>    std::shared_ptr&lt;ECPPoint&gt; publicKey;        <span class="hljs-comment">// 公钥，以Point表示</span><br>    std::shared_ptr&lt;ECPPoint&gt; generator;        <span class="hljs-comment">// 生成元 点</span><br>    std::shared_ptr&lt;Integer&gt; n;                 <span class="hljs-comment">// 生成元 对应的阶数</span><br>    std::string ZA;                             <span class="hljs-comment">// 杂凑值，字节形式 ：ZA = H256(ENTL_A ∥ ID_A ∥ a ∥ b ∥ xG ∥ yG ∥ xA ∥ yA)</span><br><br>    <span class="hljs-comment">// 默认构造函数，使用官方参数</span><br>    <span class="hljs-built_in">SM2</span>();<br>    <span class="hljs-comment">// 初始化曲线参数，使用官方参数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 计算杂凑值 ZA</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeZA</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>测试代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 测试 SM2 类</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestCrypto::Test_SM2</span><span class="hljs-params">()</span> </span>&#123;<br>    SM2 sm2;<br>    std::string message = <span class="hljs-string">&quot;message digest&quot;</span>;<br>    std::string signature;<br>    Integer k = Util::<span class="hljs-built_in">StringToInteger</span>(<span class="hljs-string">&quot;59276E27D506861A16680F3AD9C02DCCEF3CC1FA3CDBE4CE6D54B80DEAC1BC21&quot;</span>);<br>    sm2.<span class="hljs-built_in">Sign</span>(message, signature, k);<br><br>    Integer r = Util::<span class="hljs-built_in">StringToInteger</span>(Util::<span class="hljs-built_in">HexEncode</span>(signature.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>)));<br>    Integer s = Util::<span class="hljs-built_in">StringToInteger</span>(Util::<span class="hljs-built_in">HexEncode</span>(signature.<span class="hljs-built_in">substr</span>(<span class="hljs-number">32</span>,<span class="hljs-number">32</span>)));<br><br>    <span class="hljs-comment">// 打印输出，对照真实数据</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————————测试SM2 签名算法——————————————&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;真实 r:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;F5A03B0648D2C4630EEAC513E1BB81A15944DA3827D5B74143AC7EACEEE720B3&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;计算 r:&quot;</span> &lt;&lt; Util::<span class="hljs-built_in">HexEncode</span>(signature.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>)) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;真实 s:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;B1B6AA29DF212FD8763182BC0D421CA1BB9038FD1F7F42D4840B69C485BBC1AA&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;计算 s:&quot;</span> &lt;&lt; Util::<span class="hljs-built_in">HexEncode</span>(signature.<span class="hljs-built_in">substr</span>(<span class="hljs-number">32</span>,<span class="hljs-number">32</span>)) &lt;&lt; endl;<br><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————————测试SM2 验证签名——————————————&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;message: &quot;</span> &lt;&lt; message &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;r: &quot;</span> &lt;&lt; Util::<span class="hljs-built_in">IntegerToString</span>(r) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;s: &quot;</span> &lt;&lt; Util::<span class="hljs-built_in">IntegerToString</span>(s) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;签名验证结果: &quot;</span> &lt;&lt; boolalpha &lt;&lt; sm2.<span class="hljs-built_in">Verify</span>(message, signature ) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————————测试SM2 公钥恢复算法——————————————&quot;</span> &lt;&lt; endl;<br><br>    std::string pubKey;<br>    sm2.<span class="hljs-built_in">RecoverPublicKey</span>(message,<span class="hljs-literal">false</span>, r, s,pubKey);<br>    <span class="hljs-function">ECP::Point <span class="hljs-title">P</span><span class="hljs-params">(Util::StringToInteger(Util::HexEncode(pubKey.substr(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>))),</span></span><br><span class="hljs-params"><span class="hljs-function">                 Util::StringToInteger(Util::HexEncode(pubKey.substr(<span class="hljs-number">32</span>,<span class="hljs-number">32</span>))))</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;真实公钥 P.x:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;09F9DF311E5421A150DD7D161E4BC5C672179FAD1833FC076BB08FF356F35020&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;恢复公钥 P.x:&quot;</span> &lt;&lt; Util::<span class="hljs-built_in">IntegerToString</span>(P.x) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;真实公钥 P.y:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;CCEA490CE26775A52DC6EA718CC1AA600AED05FBF35E084A6632F6072DA9AD13&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;恢复公钥 P.y:&quot;</span> &lt;&lt; Util::<span class="hljs-built_in">IntegerToString</span>(P.y) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试数据来自：<a href="https://blog.csdn.net/beebeeyoung/article/details/91063358">SM2 自检数据</a></p><p>测试结果如下所示：</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202112132204273.(null)" alt="测试结果输出"></p><p class="note note-primary">代码上传至Github仓库：https://github.com/2017zhangyuxuan/Learn-Blockchain</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.oscca.gov.cn/sca/xxgk/2010-12/17/1002386/files/b791a9f908bb4803875ab6aeeb7b4e03.pdf">SM2 椭圆曲线公钥密码算法</a></p><p><a href="https://blog.csdn.net/beebeeyoung/article/details/91063358">SM2 自检数据</a></p><p><a href="http://www.gmbz.org.cn/main/viewfile/2018010802371372251.html">SM2 官方参数定义</a>  </p><p><a href="https://github.com/inoutcode/ethereum_book/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0.asciidoc#%E7%AD%BE%E5%90%8D%E5%89%8D%E7%BC%80%E5%80%BCv%E5%92%8C%E5%85%AC%E9%92%A5%E6%81%A2%E5%A4%8D">以太坊：签名前缀值（v）和公钥恢复</a></p><p><a href="https://www.cryptopp.com/docs/ref/class_integer.html">CryptoPP 官方文档</a></p><p><a href="http://www.secg.org/sec1-v2.pdf">椭圆曲线标准</a> </p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SM2</tag>
      
      <tag>椭圆曲线密码算法</tag>
      
      <tag>公钥恢复算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题04】椭圆曲线密码算法在比特币中的应用</title>
    <link href="/2021/11/27/2021-11/2021-11-27%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9804-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E5%9C%A8%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2021/11/27/2021-11/2021-11-27%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9804-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E5%9C%A8%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>不同于以太坊的账户模型，比特币采用的是UTXO模型，比特币的所有权是通过<em>数字密钥、比特币地址和数字签名</em>来确定的。数字密钥实际上并不存储在网络中，而是由用户生成之后，存储在一个叫做<em>钱包</em>的文件或简单的数据库中。用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问互联网。</li><li>密钥是成对出现的，由私钥和公钥所组成。公钥就像银行的帐号，而私钥就像银行卡的密码或支票的签名。比特币的用户很少会直接看到数字密钥。一般情况下，它们存储在钱包文件内，由比特币钱包软件进行管理。</li><li>在比特币交易的支付环节，收款人的公钥由数字指纹表示，称为<em>比特币地址</em>，就像支票上收款人名称 （即“付给谁的账户”）。一般情况下，比特币地址由公钥生成并与之对应。然而，并非所有比特币地址都代表公钥； 也可以代表其他支付对象，譬如脚本。这样一来，比特币地址就可以抽象成资金接收者，使得交易更灵活，就像纸质支票：可以支付到个人账户或公司账户，也可以支付账单和现金。比特币地址是密钥被用户能够看到的唯一形式，因为这个地址就是需要告诉别人的。</li><li>以上是对比特币和密码学应用的简单概述，而本篇文章将重点关注椭圆曲线密码算法在比特币中的应用，将从与之密切相关的密钥与地址、钱包、交易三部分介绍相关内容。</li></ul><h1 id="密钥与地址"><a href="#密钥与地址" class="headerlink" title="密钥与地址"></a>密钥与地址</h1><ul><li>在比特币系统中，我们用公钥密码学技术创建一个密钥对，用于控制对比特币的访问。密钥对包括一个私钥，和由其衍生出的唯一的公钥。公钥用于接收比特币，而私钥用于支付时进行交易签名。</li><li>比特币正是使用椭圆曲线密码算法作为其公钥密码学的基础。</li></ul><h2 id="私钥与公钥与地址"><a href="#私钥与公钥与地址" class="headerlink" title="私钥与公钥与地址"></a>私钥与公钥与地址</h2><p>一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。私钥（<em>k</em>）是一个数字，通常是随机选出的。基于私钥，我们就可以使用椭圆曲线乘法这个单向密码函数产生一个公钥（<em>K</em>）。基于公钥（<em>K</em>），我们就可以使用一个单向密码哈希函数生成比特币地址（<em>A</em>）。私钥、公钥和比特币地址之间的关系如下图所示。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111271547812.(null)" alt="私钥、公钥和比特币地址之间的关系"></p><h2 id="私钥"><a href="#私钥" class="headerlink" title="私钥"></a>私钥</h2><ul><li><p>私钥就是一个随机选出的数字而已。拥有和控制了私钥，就相当于控制了该私钥对应的比特币地址中的所有资金。通过证明比特币交易中资金的所有权，私钥可以生成花费该笔资金的签名。</p></li><li><p><em><strong>从一个随机数生成私钥</strong></em> 是生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源。生成一个比特币私钥在本质上与“在1到2^256^之间选一个数字”无异。只要选取的结果是不可预测或不可重复的，那么选取数字的具体方法并不重要。比特币软件使用操作系统底层的随机数生成器来产生256位的熵（随机性）。</p></li><li><p>更准确地说，私钥可以是1和n-1之间的任何数字，其中n是一个常数（n&#x3D;1.158 * 10^77^，略小于2^256^），并被定义为由比特币所使用的椭圆曲线的阶（比特币使用的是 <strong>secp256k1</strong> 标准所定义的一种特殊的椭圆曲线和一系列数学常数。该标准由美国国家标准与技术研究院 （NIST）建立）。要生成这样的一个私钥，我们随机选择一个256位的数字，并检查它是否小于n-1。从编程的角度来看，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。如果运算结果小于n，我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。</p></li><li><h2 id="公钥"><a href="#公钥" class="headerlink" title="公钥"></a>公钥</h2></li></ul><p>以一个随机生成的私钥<em>k</em>为起点，将其乘以曲线上一个预定的点，叫做<em>生成点G</em>得到曲线上的另一点，这就是相应的公钥 <em>K</em>。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的：</p><p>$$<br>K &#x3D; k * G<br>$$<br>其中<em>k</em>是私钥，<em>G</em>是生成点，在该曲线上所得的点<em>K</em>是公钥。因为所有比特币用户的生成点是相同的，一个私钥<em>k</em>乘以<em>G</em>将得到相同的公钥<em>K</em>。<em>k</em>和<em>K</em>之间的关系是固定的，但只能单向运算，即从<em>k</em>得到<em>K</em>。这就是可以把比特币地址（<em>K</em>的衍生） 与任何人共享而不会泄露私钥（<em>k</em>）的原因。</p><p>实现了椭圆曲线乘法，我们就可以用随机产生的私钥<em>k</em>和与生成点<em>G</em>相乘得到公钥<em>K</em>。下面给出一个简单例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash">k = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD <br>K = k * G<br><br>公钥K被定义为一个点 K = (x, y) ，其中：<br>x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A <br>y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB<br></code></pre></td></tr></table></figure><h2 id="比特币地址"><a href="#比特币地址" class="headerlink" title="比特币地址"></a>比特币地址</h2><p>比特币地址可由公钥经过单向哈希算法得到。密码学哈希算法是一种单向函数，接收任意长度的输入产生指纹或哈希。哈希函数在比特币中被广泛使用 ：比特币地址、脚本地址以及在挖矿中的工作量证明算法。由公钥生成比特币地址时使用的算法是Secure Hash Algorithm (SHA)和the RACE Integ rity Primitives Evaluation Message Digest (RIPEMD)，具体来说是SHA256和RIPEMD160。</p><p>以公钥 <em>K</em> 为输入，计算其SHA256哈希值，并以此结果计算RIPEMD160 哈希值，得到一个长度为160位（20字节）的数字：</p><p>$$<br>A &#x3D; RIPEMD160(SHA256(K))<br>$$<br>公式中，<em>K</em>是公钥，<em>A</em>是生成的比特币地址。</p><p>通常用户见到的比特币地址是经过“<strong>Base58Check</strong>”编码的（参见下面的“Base58Check Encoding”一图），这种编码使用了58个字符（Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。Base58Check编码也被用于比特币的其它地方，例如比特币地址、私钥、加密的密钥和脚本哈希中，用来提高可读性和录入的正确性。</p><center class="half">     <img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111271513682.(null)" width="300"></img>    <img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111271513117.(null)" width="400"></img></center><hr><ul><li><strong>WIF(Wallet import format)</strong> 钱包导入格式，(也被称为电子钱包的导出格式)是一种私有的 ESCDSA (椭圆曲线签名算法) 秘钥，意在使私钥更容易复制，私钥的各种形式如下表所示。</li></ul><table><thead><tr><th>Type</th><th>Prefix</th><th>Description</th></tr></thead><tbody><tr><td>Raw</td><td>None</td><td>32字节</td></tr><tr><td>Hex</td><td>None</td><td>64位Hex编码</td></tr><tr><td>WIF</td><td>5</td><td>使用Base58Check进行编码</td></tr><tr><td>WIF-compressed</td><td>K or L</td><td>使用Base58Check进行编码，但在编码前增加后缀0x01</td></tr></tbody></table><table><thead><tr><th align="left">Format</th><th>Private key</th></tr></thead><tbody><tr><td align="left">Hex</td><td>1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</td></tr><tr><td align="left">WIF</td><td>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</td></tr><tr><td align="left">WIF-compressed</td><td>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</td></tr></tbody></table><ul><li>公钥也可以用多种不同格式来表示，通常分为非压缩格式或压缩格式公钥这两种形式。</li><li>我们从前文可知，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256位的数字。其中一个256位数字是公钥的x坐标，另一个256位数字是y坐标。前缀04是是非压缩格式公钥， 压缩格式公钥是以02或者03开头。</li><li>正如前面所说，一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程来得到y坐标。这可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256位。这样每笔交易需要的字节数就会减少许多，随着时间推移，就能保存更多的交易数据。</li><li>未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。为什么会有两个前缀：当<strong>我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是偶数或者奇数</strong>。因此，为了区分y坐标的两种可能值，在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以让软件能够根据x坐标，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上点的完整坐标。下图阐释了公钥压缩的过程：</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111271547830.(null)"  height="50%" width="50%" align="center"> </img></p><p class="note note-primary"> 注意：实际上“压缩格式私钥”是一种名称上的误导，因为当私钥使用WIF压缩格式导出时，不但没有压缩，反而比“非压缩格式”私钥长出一个字节。这个多出来的一个字节是私钥被加了后缀01，用以表明该私钥是来自于一个较新的钱包，只能被用来生成压缩公钥。私钥并没有压缩的，也不能被压缩。“压缩私钥”实际上表示“只能生成压缩公钥的私钥”，而“非压缩私钥”用来表明“只能生成非压缩公钥的私钥”。为避免更多误解，应该只可以说导出格式 是“WIF压缩格式”或者“WIF”，而不能说这个私钥是“压缩”的。</p><h1 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h1><ul><li>广义上，钱包是一个应用程序，为用户提供交互界面。钱包控制用户资金访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。</li><li>狭义上，“钱包”是指用于存储和管理用户密钥的数据结构。</li><li>在这一小节中，我们将更关注钱包是密钥容器的这一角度，探索椭圆曲线算法在其中的应用。</li></ul><h2 id="HD分层钱包"><a href="#HD分层钱包" class="headerlink" title="HD分层钱包"></a>HD分层钱包</h2><p>根据钱包包含的多个密钥之间是否有关系，主要分为两种类型：</p><ul><li><p>第一种类型是<em>非确定性钱包（nondeterministic wallet）</em>，其中每个密钥都是从随机数独立生成的。密钥彼此无关。</p></li><li><p>第二种类型是确定性钱包（deterministic wallet），其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包中使用了许多不同的密钥推导方法。最常用的推导方法是使用树状结构，称为分层确定性（hierarchical deterministic）钱包或HD钱包。</p><ul><li>相比随机（不确定性）密钥，HD钱包有两个主要的优势。第一，树状结构可以被用来表达附加的组织含义，比如子密钥的特定分支用来接收交易收入款项，另一个分支用来负责接收对外付款的找零。密钥的分支也可以用于公司设置，将不同的分支分配给部门、子公司、特定功能或会计类别。</li><li>HD钱包的第二个好处是，用户可以创建一系列公钥，而不需要访问对应的私钥。这样，HD钱包就能用在不安全的服务器上，或者仅作为接收用途，它为每个交易发布不同的公钥。公钥不需要被预先加载或者提前衍生，服务器也不需要有用来支付的私钥。</li></ul></li></ul><hr><p>HD钱包密钥的生成过程如下图所示：通过记助词和 Salt 生成Root Seed种子，再通过HMAC-SHA512（单向哈希），输出512位bits，其中左256位作为主私钥（通过椭圆曲线密码算法可生成主公钥，采用的是压缩公钥格式264bits），右256位作为主链码。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111271513500.(null)" width="70%" height="70%" alight="center"> </img></p><blockquote><p>HD钱包的种子生成过程，并没有涉及椭圆曲线密码算法，因此这里不再展开介绍，具体过程可参考：<br><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch05.md#523-%E4%BB%8E%E5%8A%A9%E8%AE%B0%E8%AF%8D%E7%94%9F%E6%88%90%E7%A7%8D%E5%AD%90">HD分层钱包 种子生成过程</a></p></blockquote><h2 id="衍生子秘钥"><a href="#衍生子秘钥" class="headerlink" title="衍生子秘钥"></a>衍生子秘钥</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111271513760.(null)" width="60%" height="60%" aligh="center"> </img></p><ul><li>子秘钥的衍生推导如上图所示：父公钥 + 父链码 + 索引作为输入， 输出512bits，右256bits作为子链码；左256bits 与 父秘钥结合得到子秘钥</li><li>衍生得到的子私钥，推断不出兄弟姐妹的私钥；如果没有子链码，也无法推断出孙密钥</li><li>可以得到如下的推导公式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">child_private_key == (parent_private_key + lefthand_hash_output) % G<br>child_public_key  == point( (parent_private_key + lefthand_hash_output) % G )<br>child_public_key  == point(child_private_key) == parent_public_key + point(lefthand_hash_output)<br></code></pre></td></tr></table></figure><ul><li><p>可以看到，子公钥的推导有两种方式，一个是通过私钥推导，一个是直接通过公钥推导</p></li><li><p>正如我们之前看到的，密钥衍生函数可以被用来创造密钥树上任何层级的子密钥，基于以下三个输入量：密钥，链码以及想要的子密钥的索引。</p><p>密钥以及链码这两个重要的部分被结合之后，就叫做</p><p><em>扩展密钥（extended key）</em></p><p>。术语“扩展密钥”也被认为是“可扩展的密钥”，因为这种密钥可以用来衍生子密钥。</p><ul><li>扩展密钥编码用的 Base58Check使用特殊的版本号，Base58编码字符前缀分别为“xprv”和“xpub”</li></ul></li></ul><center class="half">     <img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111271513936.(null)" width="300"></img>    <img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=MDYwZjYzODI5NTFjOThiYTQ3MzZiM2JhMjAyNWIxNTBfazRleGFLaGlDbFVMOHlsZzllb01uelhQVkJ3SUo5RnJfVG9rZW46Ym94Y256d2Z4M2ZhWWR1NDZmeEtiV2hJOHRlXzE2Mzc5OTcyMDk6MTYzODAwMDgwOV9WNA" width="300"></img></center><ul><li>上面左图为常规衍生，直接使用父公钥衍生子公钥，这样推导的好处就是不用访问私钥，就能衍生扩展出子公钥，用于收款，可以用在安全性较弱的web服务器上<ul><li>但是这种常规的扩展方式存在的问题是，当一个攻击者得到父公钥和对应的链码时，他可以衍生扩展出之后所有的子公钥和对应链码，如果此时再获得子私钥，那么就可以推导出这个子私钥之后所有的私钥（孙私钥等），甚至可能会推导出父私钥</li></ul></li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">child_private_key == <span class="hljs-comment">(parent_private_key + lefthand_hash_output)</span> <span class="hljs-meta">%</span> G<br></code></pre></td></tr></table></figure><ul><li>右图为强化衍生，不使用父公钥，直接用父私钥 + 父链码 + 索引 作为输入，得到输出（这样就算子公钥和子链码暴露了，也不能推导出父私钥）<ul><li>简单来说，如果想利用xpub的便捷来衍生公钥的分支，又不想冒泄露链码的风险， 就该从强化父密钥，而不是常规父密钥衍生。最好的方式是，为了避免主密钥泄露，主密钥所衍生的第一层级的子密钥总是通过强化衍生得来。</li></ul></li></ul><h1 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h1><ul><li>比特币交易是比特币系统中最重要的部分。比特币中的其他一切都是为了确保交易可以被创建、在网络上传播、验证，并最终添加到全局交易分类账本（区块链）中。比特币交易的本质是数据结构，这些数据结构是对比特币交易参与者价值传递的编码。比特币区块链是一本全局复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。</li><li>交易主要的功能就是实现比特币的转移，而其实现过程就用到了密码学技术。支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名（每次交易的签名都不同，但都由同一个私钥生成）。针对展示的公钥和签名，比特币网络中的所有人都可以验证该交易有效并予以接受，从而确认支付者对该交易中的比特币的所有权。</li><li>这一小节中，将介绍交易的基本数据结构，关注比特币交易过程的实现，并聚焦密码学技术的使用。</li></ul><h2 id="交易的输出"><a href="#交易的输出" class="headerlink" title="交易的输出"></a>交易的输出</h2><p>每一笔比特币交易都会创造输出，并被比特币正本记录下来。几乎所有的输出，除了一个例外（见“数据输出操作符”（OP_RETURN）），都能创造称为UTXO的比特币块，然后被整个网络识别，供所有者在未来交易中使用。</p><p>交易输出包含两部分：</p><ul><li><p>一定量的比特币，面值为“聪”（satoshis） ，是最小的比特币单位；</p></li><li><p>确定花费输出所需条件的加密难题（cryptographic puzzle），这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥 (scriptPubKey)。</p><ul><li>只有出示对应的解锁脚本，成功执行锁定脚本（相当于进行签名验证的过程），才能花费这笔输出</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-attr">&quot;vout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0.01500000</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;scriptPubKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0.08450000</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;scriptPubKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><h2 id="交易的输入"><a href="#交易的输入" class="headerlink" title="交易的输入"></a>交易的输入</h2><p>交易的输入包含四个元素：</p><ul><li><p>一个交易ID，引用包含将要消费的UTXO的交易</p></li><li><p>一个输出索引（vout），用于标识来自该交易的哪个UTXO被引用（第一个为零）</p></li><li><p>一个 scriptSig（解锁脚本），满足UTXO的消费条件，解锁用于支出</p></li><li><p>一个序列号，用于指定这笔输入的生效时间</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-attr">&quot;vin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;txid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;vout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;scriptSig&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;sequence&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4294967295</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>在上述交易的输入中提到了一个关键元素解锁脚本，实际上这就是应用了椭圆曲线密码算法的数字签名。在比特币的ECDSA算法的实现中，被签名的“消息”是交易，或更确切地说是交易中特定数据子集的哈希值。签名密钥是用户的私钥，结果就是签名：</p><p>$$<br>Sig &#x3D; F_{sig}(F_{hash}(m),  d_A)<br>$$</p><ul><li><p><em>dA</em> 是签名私钥</p></li><li><p><em>m</em> 是交易（或其部分数据）</p></li><li><p><em>Fhash</em> 是散列函数</p></li><li><p><em>Fsig</em> 是签名算法</p></li><li><p><em>Sig</em> 是结果签名</p></li></ul><p>函数<em>Fsig</em> 产生由两个值组成的签名Sig，通常称为R和S：</p><p>$$<br>Sig &#x3D; （R，S）<br>$$<br>现在已经计算了两个值R和S，它们就使用一种称为<em>可分辨编码规则Distinguished Encoding Rules</em>或<em>DER</em>的国际标准编码方案，序列化为字节流，正如我们在交易输入的JSON字符串中看到的那样。</p><hr><p><strong>签名序列化（DER）</strong></p><p>我们再来之前在交易输入中展示的一个解锁脚本，其中以下DER编码签名：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">3045022100884</span>d<span class="hljs-number">142</span>d<span class="hljs-number">86652</span>a<span class="hljs-number">3</span>f<span class="hljs-number">47</span>ba<span class="hljs-number">4746</span>ec<span class="hljs-number">719</span>bbfbd<span class="hljs-number">040</span>a<span class="hljs-number">570</span>b<span class="hljs-number">1</span>deccbb<span class="hljs-number">6498</span><span class="hljs-keyword">c</span><span class="hljs-number">75</span><span class="hljs-keyword">c</span><span class="hljs-number">4</span>ae<span class="hljs-number">24</span>cb<span class="hljs-number">02204</span>b<span class="hljs-number">9</span>f<span class="hljs-number">039</span>ff<span class="hljs-number">08</span>df<span class="hljs-number">09</span>cbe<span class="hljs-number">9</span>f<span class="hljs-number">6</span>addac<span class="hljs-number">960298</span>cad<span class="hljs-number">530</span>a<span class="hljs-number">863</span>ea<span class="hljs-number">8</span>f<span class="hljs-number">53982</span><span class="hljs-keyword">c</span><span class="hljs-number">09</span>db<span class="hljs-number">8</span>f<span class="hljs-number">6e381301</span><br></code></pre></td></tr></table></figure><p>该签名是用户钱包生成的R和S值的序列化字节流，证明对应用户拥有授权花费该输出的私钥。 序列化格式包含以下9个元素：</p><ul><li><p><em>0x30</em>表示DER序列的开始</p></li><li><p><em>0x45</em> - 序列的长度（69字节）</p></li><li><p><em>0x02</em> - 一个整数值</p></li><li><p><em>0x21</em> - 整数的长度（33字节）</p></li><li><p><em>00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb</em> - R值</p></li><li><p><em>0x02</em> - 接下来是一个整数</p></li><li><p><em>0x20</em> - 整数的长度（32字节）</p></li><li><p><em>4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813</em> - S值</p></li><li><p>后缀（<em>0x01</em>）指示使用的哈希的类型（SIGHASH_ALL）</p></li></ul><hr><p><strong>验证签名</strong></p><ul><li>要验证签名，必须有签名（<em>R</em>和<em>S</em>）、序列化交易和公钥（对应于用于创建签名的私钥）。本质上，签名的验证意味着“只有生成此公钥的私钥的所有者，才能在此交易上产生此签名。”</li><li>签名验证算法采用消息（交易或其部分的哈希值）、签名者的公钥和签名（R和S值），如果签名对该消息和公钥有效，则返回 TRUE 值。</li></ul><h2 id="交易脚本"><a href="#交易脚本" class="headerlink" title="交易脚本"></a>交易脚本</h2><p>正如之前内容提到的，锁定脚本和解锁脚本正是组成数字签名和签名验证过程的关键数据。</p><ul><li>锁定脚本：锁定脚本是一个放置在交易输出上面的花费条件——它指定了今后花费这笔输出必须要满足的条件。 由于锁定脚本往往含有一个公钥或比特币地址（公钥哈希值），在历史上它曾被称为<em>脚本公钥scriptPubKey</em>。</li><li>解锁脚本：解锁脚本是这样一个脚本，它“解决”或满足由锁定脚本放置在输出上的条件，并允许使用输出。解锁脚本是每一笔比特币交易输入的一部分，而且往往含有一个由用户的比特币钱包（通过用户的私钥）生成的数字签名。由于解锁脚本常常包含一个数字签名，因此它曾被称作<em>脚本签名ScriptSig</em>。</li><li>当结合锁定脚本和解锁脚本，在堆栈中执行脚本，如果堆栈中最后剩余的结果为“TRUE”，表明解锁脚本中签名跟锁定脚本中的公钥哈希是相匹配的，即用于签名的私钥跟公钥是匹配的。其中，签名验证的这个验证操作正是锁定脚本中 “<strong>OP_CHECKSIG</strong>” 所执行的，即比对消息（交易或其部分的哈希值）、签名者的公钥和签名（R和S值）。</li></ul><hr><p><strong>脚本执行</strong></p><ul><li>在最初版本的比特币客户端中，解锁脚本和锁定脚本按顺序连起来执行。出于安全因素考虑，在2010年发生了改变，因为存在一个漏洞，允许格式错误的解锁脚本将数据推送到堆栈并损坏锁定脚本。而在当前的方案中，脚本是单独执行的，在两次执行之间传输堆栈，如下所述。<ul><li>首先，使用堆栈执行引擎执行解锁脚本。如果解锁脚本在执行过程中未报错（例如：没有留下“dangling”操作码），则复制主堆栈，并执行锁定脚本。如果从解锁脚本中复制而来的堆栈数据执行锁定脚本的结果为“TRUE”，那么解锁脚本就成功地满足了锁定脚本所设置的条件，因此，该输入是一个能使用该UTXO的有效授权。如果合并脚本执行后的结果是”TRUE“以外的任何结果，输入都是无效的，因为它不能满足UTXO中所设置的使用该笔资金的条件。</li></ul></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111271513603.(null)" alt="结合scriptSig和scriptPubKey执行脚本"></p><p class="note note-info"> 具体脚本在堆栈中的执行过程，可参考：<a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch06.md#644-p2pkhpay-to-public-key-hash">P2PKH 脚本执行流程</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>比特币系统中大量使用了密码学技术，例如使用椭圆曲线密码算法生成密钥和公钥，以及交易中的数字签名和验证，确保比特币的所有者在进行转账操作。密码学实现了比特币的许多有趣特性，包括去中心化信任和控制、所有权认证和基于密码学证明的安全模型。可以说，密码学是比特币实现的一大基石。</p><p class="note note-success"> 更多比特币知识可参考我的这个Github项目：<a href="https://github.com/2017zhangyuxuan/Learn-Blockchain">比特币系统 C++ 实现</a></p><h1 id="参考资料附录"><a href="#参考资料附录" class="headerlink" title="参考资料附录"></a>参考资料附录</h1><p><a href="https://github.com/tianmingyun/MasterBitcoin2CN">《精通比特币》中文电子书</a> </p><p><a href="https://zhuanlan.zhihu.com/p/21298725">比特币（地址、私钥）压缩与非压缩的区别</a></p><p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch05.md#523-%E4%BB%8E%E5%8A%A9%E8%AE%B0%E8%AF%8D%E7%94%9F%E6%88%90%E7%A7%8D%E5%AD%90">HD分层钱包 种子生成过程</a></p><p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch06.md#644-p2pkhpay-to-public-key-hash">P2PKH 脚本执行流程</a></p><p><a href="https://bitcoin.stackexchange.com/questions/72657/signature-verification-in-python-using-compressed-public-key">Signature verification in python using compressed public key</a></p><p><a href="https://medium.com/@bitaps.com/exploring-bitcoin-signing-the-p2pkh-input-b8b4d5c4809c">Exploring Bitcoin: signing the P2PKH input</a></p><p><a href="https://www.jianshu.com/p/a560e0605ff2">比特币私钥，公钥和地址的关系</a></p><p><a href="https://live.blockcypher.com/">在线搜索交易记录、区块信息（各种数字货币）</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
      <tag>ECDSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SM4算法介绍与代码实现</title>
    <link href="/2021/11/13/2021-11/2021-11-13%20SM4/"/>
    <url>/2021/11/13/2021-11/2021-11-13%20SM4/</url>
    
    <content type="html"><![CDATA[<h1 id="SM4算法介绍"><a href="#SM4算法介绍" class="headerlink" title="SM4算法介绍"></a>SM4算法介绍</h1><h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111131454563.(null)" alt="SM4加密过程"></p><ul><li>首先左侧描述了SM4加密的整体流程：</li></ul><ol><li>输入的一个消息分组为128bits，划分成4个小块，每个小块32bits</li><li>这四个小块经过32轮加密处理</li><li>加密处理后，再经过一次Permutation置换，得到最终加密结果</li></ol><ul><li>右侧描述其中一轮的加密过程，其他轮函数加密过程是类似的，只是轮密钥不同：</li></ul><ol><li>X_3 先后跟 X_2 、X_1 进行异或  —— ①</li><li>① 得到的结果再与轮密钥 RK_i 进行异或  —— ②</li><li>② 得到的记过为32bits，再分成4组8bits，每一组8bits 使用相同的S-Box进行替换，得到新的8bits   —— ③</li><li>③ 得到的4组8bits重新拼接得到32bits，将这32bits复制成5份输入，第1份循环左移2位，第2份循环左移10位，第3份循环左移18位，第4份循环左移24位，第5份不改动直接输出 —— ④</li><li>④ 的得到的5份输出的32bits与X_0 一起进行异或 —— ⑤</li><li>最终得到输出 X’_3 就是 ⑤ 的输出，其他输出X’_0 &#x3D; X_1 ， X’_1 &#x3D; X_2， X’_2 &#x3D; X_3</li></ol><p>用公式进行描述如下所示，其中S代表使用S-box进行替换，L表示线性函数执行循环左移的操作</p><p>$$<br>X’_0 &#x3D; X_1  \<br>X’_1 &#x3D; X_2\<br>X’_2 &#x3D; X_3<br>$$</p><p>$$<br>X’_3 &#x3D;X_0⊕ L( S (X_3 ⊕ X_2 ⊕ X_1 ⊕ RK_i))<br>$$<br>$$<br> A&#x3D;(a_0,a_1,a_2,a_3), B&#x3D;(b_0,b_1,b_2,b_3)  \ (b_0,b_1,b_2,b_3) &#x3D; S(A)&#x3D; (Sbox(a_0),Sbox(a_1),Sbox(a_2),Sbox(a_3))<br>$$<br>$$<br>B&#x3D;(b_0,b_1,b_2,b_3), C (32bits) \ C &#x3D; L(B) &#x3D; B ⊕ (B&lt;&lt;2) ⊕(B&lt;&lt;10) ⊕(B&lt;&lt;18)⊕(B&lt;&lt;24)<br>$$</p><p class='note note-success'>  通过观察SM4加密过程可以看到，在一轮加密中，有3个输出完全等同于3个输入，只有一个输出需要经过一些复杂操作，即计算X'_3，所以在进行解密时，只需要计算原来的X_0，而这可以通过现有的输出得到的（具体操作见下面的解密过程）。</p><h2 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h2><ul><li>在了解了SM4一轮的加密过程后，不难得出一轮的解密过程，如下图所示</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111131519980.png" alt="SM4解密过程"></p><ul><li>同样左侧描述了SM4解密的整体流程：</li></ul><ol><li>输入的一个密文C为128bits，划分成4个小块，每个小块32bits</li><li>对这四个小块经过一次Permutation置换</li><li>对置换结果进行32轮类似的解密处理，得到最终的明文输出</li></ol><ul><li>具体描述一轮的解密过程，进行32轮类似的解密操作，其中X’_0对应加密过程中的输入X_1，X’_1对应输入X_2，X’_2对应输入X_3，所以重点计算得到原来输入的X_0，下面直接用公式来表示计算过程</li></ul><p>$$<br>X_1 &#x3D; X’_0     \qquad X_2 &#x3D; X’_1 \qquad X_3 &#x3D; X’_2<br>$$</p><p>$$<br>X_0 &#x3D;X’_3⊕ L( S (X’_2 ⊕ X’_1 ⊕ X’_0 ⊕ RK_i))<br>$$</p><p><strong>其中L线性函数跟S-box置换 都跟加密过程中一致；但需要注意的是解密过程中，轮密钥的使用次序是（31, 30, …, 1,0），跟加密过程使用的轮密钥次序正好是相反的</strong></p><h2 id="轮密钥生成"><a href="#轮密钥生成" class="headerlink" title="轮密钥生成"></a>轮密钥生成</h2><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111131454839.(null)" alt="轮密钥生成"></p><ul><li>轮密钥生成过程如上图所示，其中K代表的是16字节的密钥，公式里的S用的和加密过程中相同的Sbox</li></ul><h1 id="C-实现SM4加密与解密"><a href="#C-实现SM4加密与解密" class="headerlink" title="C++实现SM4加密与解密"></a>C++实现SM4加密与解密</h1><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><ol><li>使用C++实现SM4算法的加密和结果，实现包括ECB、CBC两种加密模式。并提供命令⾏接⼝对⼆进制⽂件 进⾏加&#x2F;解密。 </li><li>实现对png图像文件的加密，只对图像数据部分进行加密，使得对加密png文件后仍能以png格式打开</li></ol><h2 id="命令行格式说明"><a href="#命令行格式说明" class="headerlink" title="命令行格式说明"></a>命令行格式说明</h2><ul><li>生成的二进制可执行文件为 AppliedCryptography，共有以下几种可选配置<ul><li>-enc：进行加密操作</li><li>-dec：进行解密操作</li><li>-mode：指定加密&#x2F;解密操作，其后跟着ecb或者cbc（如果没有指定，默认为ecb模式）</li><li>-png：指定输入和输出文件为png格式（对png文件做特殊处理，只加密数据块部分）；如果指定了，请保证文件的后缀名以.png格式结尾</li><li>-in：输入文件的路径，请使用相对路径</li><li>-out：输出文件的路径，请使用相对路径</li><li>-key：指定密钥，默认为”123456”</li><li>-iv：指定初始化向量，默认为”123456”</li><li>-test：如果指定了，执行测试函数</li></ul></li></ul><p class='note note-warning'>1. 配置的命令请用小写 <br>2. 一些配置之后请紧跟对应的参数值 <br>3. 输入和输出的路径请用相对路径 <br></p><ul><li>参考的测试命令如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">测试cbc模式加密png文件</span><br>./AppliedCryptography -enc -mode cbc -png -in logo.png -out test.png -iv 123456 -key 123456<br>./AppliedCryptography -dec -mode cbc -png -in test.png -out dec_test.png -iv 123456 -key 123456<br><span class="hljs-meta prompt_"># </span><span class="language-bash">测试ecb加密文件</span><br>./AppliedCryptography -enc -mode ecb -in test.txt -out ecb_test.txt -iv 123456 -key 123456<br>./AppliedCryptography -dec -mode ecb -in ecb_test.txt -out dec_test.txt -iv 123456 -key 123456<br></code></pre></td></tr></table></figure><h2 id="代码结构说明"><a href="#代码结构说明" class="headerlink" title="代码结构说明"></a>代码结构说明</h2><p>首先说明进行代码目录的说明，如下图所示：</p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111131454890.(null)" width="40%" height="40%" ></center><p align="middle"><font size="2" color="grey">代码目录结构</font></p><ul><li>项目使用CMake 构建，build目录是构建目录，build&#x2F;output&#x2F;bin下是对应可执行文件的输出目录，build&#x2F;output&#x2F;bin&#x2F;test 目录下存放测试用的相关文件</li><li>Cmake-build-debug：使用CLion 编译构建时生成的目录</li><li>FirstWork：主要目录，sm4对应源代码是算法的具体实现；test对应的是测试相关方法，主要用于测试算法的正确性</li><li>hash-library：一个简单的第三方库，封装了hash操作和hex编码和解码等操作</li><li>util：其中util是一个工具类，主要封装了一些辅助函数</li><li>main.cpp：程序入口，主要实现了解析命令行参数，执行对应的操作</li></ul><h2 id="实现相关说明"><a href="#实现相关说明" class="headerlink" title="实现相关说明"></a>实现相关说明</h2><ul><li><p>在<code>sm4.h</code>和<code>sm4.cpp</code>中实现了SM4算法，具体实现逻辑只要是拆分成多个子函数</p><ul><li>L线性函数和Sbox替换函数实现</li><li>轮密钥生成</li><li><code>SM4EncRound</code>和<code>SM4DecRound</code>实现一轮的加密和解密</li><li><code>Encryption</code>和<code>Decryption</code>实现128bits输入的加密和解密</li><li><code>EncFile</code>和<code>DecFile</code>实现文件的加密和解密</li><li><code>EncPNG</code>和<code>DecPNG</code>实现对png格式文件的加密和解密</li></ul></li><li><p>需要注意的是，png图片文件，有自己的固定格式，主要为头部8字节固定签名，加其他数据块的结构，所以解析时要得到真正的数据块（IDAT)，对这一部分进行加密，这样才能加密后依然能够以png方式打开，具体的PNG格式参考：<a href="https://blog.csdn.net/einsteinlike/article/details/41803193">PNG格式说明</a></p></li><li><p>测试函数主要有4个</p><ul><li><code>TestAll()</code> ：进行所有测试</li><li><code>TestEncDec()</code>： 测试SM4 单次加解密128bits</li><li><code>TestEncDecFileECB()</code>： 测试SM4 加密和解密文件 ECB模式</li><li><code>TestEncDecFileCBC()</code>： 测试SM4 加密和解密文件 CBC模式</li><li><code>TestEncDecPNG()</code>： 测试SM4 加密和解密PNG图片</li></ul></li></ul><p class='note note-info'>  代码已上传Github仓库：https://github.com/2017zhangyuxuan/AppliedCryptography <br></p><p class='note note-danger'>  但是当前代码还存在问题是，大端和小端的问题没有彻底解决，如果对比一些官方实现，加密结果是不同的，因为时间原因没有能排查出来，只能作罢。所以仅仅是提供一些思路。</p><center><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/hexo_img/菜狗.jpeg" width="40%" height="40%" align="middle" ></center><h1 id="参考附录"><a href="#参考附录" class="headerlink" title="参考附录"></a>参考附录</h1><p>SM4算法原理 ：<a href="https://blog.csdn.net/bird_tp/article/details/105988468">https://blog.csdn.net/bird_tp/article/details/105988468</a>  </p><p>SM4 实现参考：<a href="https://cryptopp.com/docs/ref/class_s_m4_1_1_base.html#details">https://cryptopp.com/docs/ref/class_s_m4_1_1_base.html#details</a></p><p><a href="https://blog.csdn.net/weixin_39672443/article/details/110806799">png文件头_图片格式知识PNG_weixin_39672443的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/einsteinlike/article/details/41803193">PNG格式说明</a> </p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SM4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题03】隔离见证、闪电网络</title>
    <link href="/2021/11/13/2021-11/2021-11-13%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9803-%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81%E3%80%81%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/11/13/2021-11/2021-11-13%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9803-%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81%E3%80%81%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近通读了一遍《精通比特币》，对比特币中运行机制和实现原理有了初步的认识和了解。其中隔离见证和闪电网络是此前学习中遇到到两个困惑点，现在也大致有所了解，故而本篇文章就来谈谈我的个人理解，基本上是对书里关键知识点的提炼和总结，下方也给出了电子书连接。如有任何错误，欢迎批评指出~</p><p class='note note-info'><a href=https://github.com/tianmingyun/MasterBitcoin2CN>精通比特币电子书链接</a>  </p><h1 id="隔离见证"><a href="#隔离见证" class="headerlink" title="隔离见证"></a>隔离见证</h1><p>隔离见证提出的背景：随着比特币火热发展，网络上的交易量越来越大，而由于区块大小受限，一个区块能打包的交易数量是有一定限制的，而出块速度限定在10分钟一次，这就导致无法满足交易吞吐量的增长。那么隔离见证提出，挑战了交易结构，使得一个区块可以容纳更多的交易，从而提高了交易吞吐量，当时隔离见证还有别的好处，可以去看书中内容<a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch07.md#781-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81">隔离见证的好处</a>。当然提高比特币性能（比如提高交易吞吐量）的方法还有很多，这里不再展开。</p><p class='note note-primary'>隔离见证相关BIP方案:<br>  <a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">BIP-141 隔离见证的定义</a>  <br>    <a href="https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki">BIP-144 隔离见证网络序列化</a></p><h2 id="关键知识"><a href="#关键知识" class="headerlink" title="关键知识"></a>关键知识</h2><ul><li>在比特币环境中，数字签名是见证的<em>一种类型</em>，但更广义来说，见证是指能够满足对UTXO施加的条件并解锁该UTXO以供消费的任何解决方案。术语“见证”是“解锁脚本”或“scriptSig”的更一般的术语。</li><li>在引入隔离见证之前，交易中的每一个输入后面紧跟着的就是解锁它的见证数据。见证数据作为每个输入的一部分嵌入到交易中。术语<em>隔离见证</em>（简称<em>segwit</em>）只是指把特定输出的签名或解锁脚本隔离开。“单独的scriptSig”或“单独的签名”就是它最简单的形式。</li><li>乍一看，隔离见证似乎只是对交易构造方式的改变，属于交易级特性，但事实并非如此。其实，隔离见证是对单独的UTXO花费方式的更改，因此可以说是每个输出层面的特性。</li><li>当交易使用UTXO时，必须提供一个见证。在传统的UTXO中，锁定脚本要求见证数据<em>内嵌</em>在花费UTXO的交易的输入部分。但是，隔离见证UTXO指定了一个锁定脚本，该脚本可以用输入之外的见证数据（隔离）满足。</li><li><strong>隔离见证是一个软分叉</strong></li></ul><h2 id="TXID-和-WTXID"><a href="#TXID-和-WTXID" class="headerlink" title="TXID 和 WTXID"></a>TXID 和 WTXID</h2><ul><li>隔离见证的最大好处之一就是<strong>消除了第三方交易延展性</strong>。</li><li>在隔离见证之前，交易可以通过第三方巧妙地修改其签名，在不改变任何基本属性（输入，输出，金额）的情况下更改其交易ID（哈希）。这为拒绝服务DOS攻击，以及对有缺陷的钱包软件的攻击创造了机会，这些软件假定未经证实的交易哈希是不可变的。</li><li>通过引入隔离见证，交易有两个标识符txid和wtxid。传统的txid是序列化交易的双SHA256哈希，没有见证数据。交易的wtxid是具有见证数据的交易的新序列化格式的双SHA256哈希。</li><li>传统txid的计算方式与非隔离见证交易完全相同。但是，由于隔离见证交易在每个输入中都有空的scriptSig，不存在可由第三方修改的交易部分。因此，在隔离交易中，即使交易未经确认，txid也是不能被第三方修改的。</li></ul><blockquote><p><strong>提示</strong> 隔离见证交易有两个ID：txid和wtxid。txid是没有见证数据的交易的哈希，wtxid是包含见证数据的哈希。所有输入都是隔离见证输入的交易，不受第三方交易延展性影响。</p></blockquote><hr><ul><li>TXID的生成和传统方式一致：是对version, txins, txouts, nLocktime序列化后的数据，进行两次SHA256哈希</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[nVersion]</span><span class="hljs-selector-attr">[txins]</span><span class="hljs-selector-attr">[txouts]</span><span class="hljs-selector-attr">[nLockTime]</span><br></code></pre></td></tr></table></figure><ul><li>WTXID的生成：对version, marker, flag, txins, txouts, witness, nLocktime序列化后的数据，进行两次SHA256哈希</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[nVersion]</span><span class="hljs-selector-attr">[marker]</span><span class="hljs-selector-attr">[flag]</span><span class="hljs-selector-attr">[txins]</span><span class="hljs-selector-attr">[txouts]</span><span class="hljs-selector-attr">[witness]</span><span class="hljs-selector-attr">[nLockTime]</span><br></code></pre></td></tr></table></figure><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111131049973.png" alt="TXID与WTXID的生成"></p><h2 id="隔离见证的数据到底放在哪里"><a href="#隔离见证的数据到底放在哪里" class="headerlink" title="隔离见证的数据到底放在哪里"></a>隔离见证的数据到底放在哪里</h2><p>在了解隔离见证的大致原理后，我其实还是存在一个疑惑：既然说见证相当于是原来的签名数据（解锁脚本），与原来的交易数据隔离开，那么这些见证数据到底放在哪里了？</p><ul><li><p>通过<a href="https://www.jianshu.com/p/eef8e260b9f7">比特币探究之隔离见证</a> 这篇文章，了解到原来的签名数据放到了见证数据中，见证数据在CTxIn 是一个新的字段，但是只有在交易被序列化网络传输时才参与，呼应上文计算TXID时，witness是不需要序列化的；</p></li><li><p>通过<a href="https://boinnex.com/what-is-segwit/">外文- Segwit如何工作的</a> 这篇文章，进一步了解到在生成区块时，输入的见证数据同样构成一棵Merkle Tree，并把root放到了区块中的币基交易的output的锁定脚本中，具体原文描述如下图。</p></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111131137534" alt="ScriptPubKey of Witness in coinbase "></p><h1 id="闪电网络"><a href="#闪电网络" class="headerlink" title="闪电网络"></a>闪电网络</h1><p>闪电网络其实也是一种提高比特币交易性能的方法，简单来说，就是将大量交易放到比特币区块链之外进行。在具体介绍闪电网络是如何工作运行前，还需要先介绍状态通道，支付通道，HTLC哈希时间锁合约等概念。</p><h2 id="状态通道和支付通道"><a href="#状态通道和支付通道" class="headerlink" title="状态通道和支付通道"></a>状态通道和支付通道</h2><p>基本概念：</p><ul><li><em>支付通道Payment channels</em>是在比特币区块链之外，双方交换比特币交易的无信任机制。</li><li>实际上，<em>通道channel</em> 一词是一个比喻。状态通道是区块链外，由双方之间的交换状态代表的虚拟构想。实际上没有“通道”，底层数据传输机制也并不是通道。我们使用通道这个术语来表示链外双方之间的关系和共享状态。</li><li>支付通道是更广泛的<em>状态通道state channel</em>概念的一部分，状态通道代表了链外状态的变化，通过最终在区块链上结算得到保障。支付通道是一种状态通道，其中被改变的状态是虚拟货币余额。</li></ul><hr><p>《精通比特币》中对支付通道的描述感觉过于复杂，这里用Bitcoin Developer Guide里的微支付通道来举例说明，在之前博客[【比特币专题02】Developer Guide导读](<a href="https://2017zhangyuxuan.github.io/2021/10/11/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9802-Developer">https://2017zhangyuxuan.github.io/2021/10/11/2021-10-11比特币专题02-Developer</a> Guide&#x2F;) 也有介绍。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111131147856.(null)" alt="微支付通道"></p><ul><li>其工作原理大体上可以这样描述：A给B打工，B首先使用A和B的签名，使用P2SH的方式，发送一定金额到脚本地址，并将该交易立即传播到比特币网络上；然后B创造第二个交易，并用到刚刚A的签名，其输入是第一个交易的脚本地址，输出是B的地址（相当于全额返回给B），然后给这个交易加上Locktime，比如说一天后才能广播这个交易。然后A给B工作一部分内容后，A要求B先支付这份工作量的薪水，那么B就创建一份新的交易，从原来全额给B变成分出一部分金额给A，这个新的交易拷贝给A，这样A就可以广播这个新的交易从而获得薪水。（实际上A只需要在locktime过期前，广播最后版本的交易即可）<ul><li>B创建的第一笔交易和第二笔交易，可以理解为《精通比特币》中的<em>注资交易funding transaction</em>或<em>锚点交易anchor transaction</em>：通过在区块链上锁定共享状态的交易，在交易两方之间建立了一个状态通道。在支付通道的示例中，锁定的状态即为通道的初始余额（以货币计）</li><li>随后双方交换已签名的交易，这被称为<em>承诺交易commitment transactions</em>。承诺交易会改变初始状态。这些交易是有效的交易，因为它们<em>可以</em>被任何一方提交进行结算，但是在通道关闭之前，每一方都会将其在链下保留。</li><li>最后，通道可以协商关闭，即向区块链提交最后的<em>结算交易settlement transaction</em>，或者由任何一方单方面提交最后承诺交易到链上。</li></ul></li><li>为什么采用支付通道这样的方式呢，因为A诉求是及时支付薪水，但是因为量小，B不能每次都立即创造一个交易即刻支付，这样的交易费的成本太高了。所以利用这样的方式，既确保了A的薪水是及时得到确认的，又可以使得只需一个交易就一次性支付薪水</li><li>实际上，更改交易金额的输出，这个权利是在B的，因为B有A的签名但A没有B的签名，A拿的是经过B签名后的交易副本（这个交易被B签名过了，所以是有效的）。所以A能实时确保自己对应工作量的薪水能及时支付，就算中途B跑路了，也只是损失一小部分工作量的薪水，之前的薪水都可以得到支付。而对B来说，如果A没有工作，那B也能在locktime 过期后拿回自己的钱（不过这样就需要等待一个locktime的时间）</li></ul><h2 id="HTLC哈希时间锁合约"><a href="#HTLC哈希时间锁合约" class="headerlink" title="HTLC哈希时间锁合约"></a>HTLC哈希时间锁合约</h2><p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch12.md#1255-%E5%93%88%E5%B8%8C%E6%97%B6%E9%97%B4%E9%94%81%E5%90%88%E7%BA%A6htlc">HTLC 哈希时间锁合约</a> 原文中介绍得比较详细了，这里简单总结一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过密钥R生成哈希值H</span><br>H = Hash(R)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">实现HTLC的脚本可能如下所示：</span><br>IF<br>Payment if you have the secret R<br>    HASH160 &lt;H&gt; EQUALVERIFY<br>ELSE<br>    # Refund after timeout.<br>    &lt;locktime&gt; CHECKLOCKTIMEVERIFY DROP<br>    &lt;Payer Public Key&gt; CHECKSIG<br>ENDIF<br></code></pre></td></tr></table></figure><ul><li>任何知道密钥R，其哈希值等于H的人，都可以通过行使IF语句的第一个子句来兑换该输出。</li><li>如果密钥R没有被透露，HTLC中写明了，在一定数量的区块之后，付款人可以使用IF语句中的第二个子句申请退款。</li></ul><h2 id="闪电网络运行"><a href="#闪电网络运行" class="headerlink" title="闪电网络运行"></a>闪电网络运行</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111131152708.(null)"></div><div class="group-image-wrap"><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202111131152805.(null)"></div></div></div><p align="middle"><font size="2" color="grey">左图：支付通道初始状态；右图：闪电网络运行流程</font></p><p>接下来说明一下，闪电网络是如何工作：</p><ul><li>在这个例子中，我们有五个参与者：Alice, Bob, Carol, Diana, and Eric。这五名参与者已经彼此之间开设了支付通道。Alice和Bob有支付通道。Bob连接Carol，Carol连接到Diana，Diana连接Eric。为了简单起见，我们假设每个通道每个参与者都注资2个比特币资金，每个通道的总容量为4个比特币，也就是如左图所示的初始状态</li><li>Alice想要支付给Eric1个比特币。但是，Alice并没有直接连接Eric的支付通道。创建支付通道需要注资交易，而这笔交易必须首先提交给比特币区块链。Alice不想建立一个新的支付通道还要支出更多的手续费。那么就可以通过闪电网络来进行支付。</li></ul><ol><li>Alice通过路由发现了一条从Alice到Eric的一条支付路由，由多个支付通道组成。此时Alice和Eric可以进行通信，Eric生成一个密钥R，并进行hash，将哈希值H发送给Alice。</li><li>Alice构造一个HTLC，支付1.003BTC到哈希H（多出来的0.003BTC是给路由上3个节点的费用），并可以在10区块内得到退款。Alice将此HTLC提供给Bob，从和Bob之间的通道余额中扣除1.003比特币，并将其提交给HTLC。该HTLC具有以下含义：<em>“如果Bob知道密钥，Alice将其通道余额的1.003支付给Bob，或者如果超过10个区块后，则退还入Alice的余额”</em>。</li><li>Bob构造一个新的HTLC，支付1.002BTC到哈希H，如果Carol知道了密钥R，可以去取走HTLC中的1.002BTC，然后Bob也可以取走Alice提供的1.003BTC，相当于赚取了0.001BTC；如果Carol不能提供密钥，Bob也可以在9个区块时间内取回1.002BTC</li><li>Carol向Diana提供1.001BTC的HTLC，同上面一样</li><li>Dinana向Eric提供1.0BTC的HTLC</li><li>Eric知道密钥，向Diana出示了密钥R，因此取走了HTLC中的1.0BTC</li><li>Diana从Eric知道了密钥R，再向Carol出示密钥R，获得了1.001BTC，此时在Eric和Diana中支付通道中，Diana余额只有1.0BTC了，但在Carol和Diana的支付通道中，Diana余额为3.001BTC，对比原来的2+2，赚取了0.001BTC</li><li>Carol向Diana支付了1.001BTC，再从Bob处赚取了1.002BTC，赚取了0.001BTC</li><li>Bob向Carol支付了1.002BTC，从Alice处赚取了1.003BTC，赚取了0.001BTC</li><li>最终Alice支付了1.003BTC，实际上1BTC转账给了Eric，0.003支付给了路由上的其他节点</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CryptoPP C++库学习使用</title>
    <link href="/2021/11/01/2021-11/2021-11-01%20CryptoPP%E5%BA%93%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/11/01/2021-11/2021-11-01%20CryptoPP%E5%BA%93%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>参考书籍：《深入浅出CryptoPP密码学库》<br>crypto++  密码学库 ：<a href="https://github.com/weidai11/cryptopp">https://github.com/weidai11/cryptopp</a><br>电子书下载 ：<a href="https://gitee.com/locomotive_crypto">https://gitee.com/locomotive_crypto</a>    </p></blockquote><p>最近在学习比特币相关技术，在比特币系统中使用大量哈希加密、签名验证等操作，为了用代码来模拟实现比特币的运行过程，学习一个支持密码原语操作的第三方库是非常有必要的。</p><p>最为知名的密码学相关开源库应该是OpenSSL了，但是由于官网是一堆英文，学习起来太吃力，后来机缘巧合下发现了CryptoPP这个库，而且还有专门的中文书籍来讲解使用，因此就决定学习CryptoPP库，本篇论文也是基于《深入浅出CryptoPP密码学库》阅读，整理出关键章节内容，供大家参考学习。</p><p class='note note-info'>1. CryptoPP库的安装使用这里不再详细说明，请大家自行搜索网上教程  <br>2. 后来看到OpenSSL也有一个中文手册学习网站，也推荐给大家https://www.openssl.net.cn/</p><h1 id="string-和-SecByteBlock类型互换"><a href="#string-和-SecByteBlock类型互换" class="headerlink" title="string 和 SecByteBlock类型互换"></a>string 和 SecByteBlock类型互换</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// SecByteBlock 转 string</span><br><br>SecByteBlock iv; ... <span class="hljs-comment">// C++-style cast </span><br><br>std::string token = std::<span class="hljs-built_in">string</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(iv.<span class="hljs-built_in">data</span>()), iv.<span class="hljs-built_in">size</span>());<br><br><br><br><span class="hljs-comment">// string 转 SecByteBlock</span><br><br>std::string str; ... <span class="hljs-comment">// C++-style cast </span><br><br><span class="hljs-function">SecByteBlock <span class="hljs-title">sbb</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> byte*&gt;(str.data()), str.size())</span></span>;<br></code></pre></td></tr></table></figure><h1 id="第四章-初识CryptoPP库"><a href="#第四章-初识CryptoPP库" class="headerlink" title="第四章 初识CryptoPP库"></a>第四章 初识CryptoPP库</h1><h2 id="Hex编解码字符串"><a href="#Hex编解码字符串" class="headerlink" title="Hex编解码字符串"></a>Hex编解码字符串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filters.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hex.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 第一种编码方式</span><br><br>    HexEncoder hex;<br><br>    string str = <span class="hljs-string">&quot;I like&quot;</span>;<br><br>    string hexstr;<br><br>    hex.<span class="hljs-built_in">Detach</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(hexstr));<br><br>    hex.<span class="hljs-built_in">Put</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;byte*&gt;(&amp;str[<span class="hljs-number">0</span>]),str.<span class="hljs-built_in">size</span>());  <span class="hljs-comment">// 注意是会追加写入的</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;str:&quot;</span> &lt;&lt; str &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;hexstr:&quot;</span> &lt;&lt; hexstr &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// 第二种编解码写法  Source -&gt; Filter -&gt; Sink  这是一种Pipeline的方式</span><br><br>    string encode,decode;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">enc</span><span class="hljs-params">(str, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> HexEncoder(<span class="hljs-keyword">new</span> StringSink(encode)))</span></span>;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">dec</span><span class="hljs-params">(hexstr, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> HexDecoder(<span class="hljs-keyword">new</span> StringSink(decode)))</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;encode:&quot;</span>&lt;&lt;encode &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;decode:&quot;</span>&lt;&lt;decode &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第五章-随机数生成器"><a href="#第五章-随机数生成器" class="headerlink" title="第五章 随机数生成器"></a>第五章 随机数生成器</h1><p>主要可以关注GenerateBlock方法，生成指定字节长度的随机数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;osrng.h&gt;</span> <span class="hljs-comment">// 可以使用 AutoSeededRandomPool ，该随机器不用设置种子</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;rng.h&gt;</span> <span class="hljs-comment">//包含LC_RNG算法的头文件</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> <span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP; <span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Array_Size 64</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//定义一个LC_RNG随机数发生器对象，并设置其种子</span><br><br>    <span class="hljs-function">LC_RNG  <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生一个比特的随机数：&quot;</span> &lt;&lt; rng.<span class="hljs-built_in">GenerateBit</span>() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生一个字节的随机数：&quot;</span> &lt;&lt; rng.<span class="hljs-built_in">GenerateByte</span>() &lt;&lt; endl;<br><br>    byte output[Array_Size + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//定义一个缓冲区      </span><br><br><br><br>    <span class="hljs-comment">//产生Array_Size字节长度的随机数</span><br><br>    rng.<span class="hljs-built_in">GenerateBlock</span>(output, Array_Size);  <span class="hljs-comment">// 这里也可直接传入SecByteBlock</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生Array_Size长度的随机数（十六进制）：&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Array_Size; ++i)<br><br>    &#123;<span class="hljs-comment">//将获得的随机数转换成十六进制并输出</span><br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X&quot;</span>, output[i]);<br><br>    &#125;<br><br>    cout &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生一个100到1000之间的随机数：&quot;</span> &lt;&lt; rng.<span class="hljs-built_in">GenerateWord32</span>(<span class="hljs-number">100</span>, <span class="hljs-number">1000</span>) &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">//丢弃掉随机数发生器接下来产生的100个字节数据</span><br><br>    rng.<span class="hljs-built_in">DiscardBytes</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-type">int</span> arry[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><br>    rng.<span class="hljs-built_in">Shuffle</span>(arry, arry + <span class="hljs-number">10</span>); <span class="hljs-comment">//打乱数组arry中元素的顺序</span><br><br>    <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第六章-Hash函数"><a href="#第六章-Hash函数" class="headerlink" title="第六章 Hash函数"></a>第六章 Hash函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sha.h&gt;</span> <span class="hljs-comment">//使用SHA384</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;filters.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;hex.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> <span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP; <span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">try</span><br><br>    &#123;<br><br>        SHA256 sha; <span class="hljs-comment">//定义一个SHA256的类对象</span><br><br>        byte msg[] = <span class="hljs-string">&quot;I like cryptography very much&quot;</span>;<br><br><br><br>        <span class="hljs-comment">// 使用pipeline范式</span><br><br>        <span class="hljs-function">SecByteBlock <span class="hljs-title">tmp</span><span class="hljs-params">(msg, <span class="hljs-keyword">sizeof</span>(msg)<span class="hljs-number">-1</span>)</span></span>;<br><br>        string r;<br><br>        <span class="hljs-function">StringSource <span class="hljs-title">s1</span> <span class="hljs-params">(tmp, tmp.size(),<span class="hljs-literal">true</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HashFilter(sha,    <span class="hljs-comment">// 使用其他hash函数，更换一下类型即可</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HexEncoder(</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> StringSink(r))))</span></span>;<br><br>        cout &lt;&lt; r &lt;&lt; endl;<br><br>        r.<span class="hljs-built_in">clear</span>();  <span class="hljs-comment">// 清空一下，不然后面会追加</span><br><br><br><br>        <span class="hljs-comment">// 连续两次Hash256，再用Hex编码输出</span><br><br>        SHA256 sha2;<br><br>        <span class="hljs-function">StringSource <span class="hljs-title">s2</span> <span class="hljs-params">(<span class="hljs-string">&quot;I like cryptography very much&quot;</span>,<span class="hljs-literal">true</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HashFilter(sha,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HashFilter(sha2,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HexEncoder(</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> StringSink(r)))) )</span></span>;<br><br>        cout &lt;&lt; r &lt;&lt; endl;<br><br><br><br>        <span class="hljs-function">SecByteBlock <span class="hljs-title">digest</span><span class="hljs-params">(sha.DigestSize())</span></span>; <span class="hljs-comment">//申请内存空间以存放消息摘要</span><br><br>        <span class="hljs-comment">//CalculateDigest()相当于Update()+Final()</span><br><br>        <span class="hljs-comment">// Update用来向sha输入，Final计算hash值，同时重置hash函数内部状态</span><br><br>        sha.<span class="hljs-built_in">CalculateDigest</span>(digest, msg, <span class="hljs-built_in">sizeof</span>(msg) - <span class="hljs-number">1</span>);<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;digest2=&quot;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; sha.<span class="hljs-built_in">DigestSize</span>(); ++i)<br><br>        &#123;<span class="hljs-comment">//以十六进制输出Hash值</span><br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X&quot;</span>, digest[i]);<br><br>        &#125;<br><br>        cout &lt;&lt; endl;<br><br><br><br>        <span class="hljs-comment">//计算msg消息的Hash值</span><br><br>        <span class="hljs-type">bool</span> res;<br><br>        res = sha.<span class="hljs-built_in">VerifyDigest</span>(digest, <span class="hljs-comment">//可能抛出异常</span><br><br>                               msg, <span class="hljs-built_in">sizeof</span>(msg) - <span class="hljs-number">1</span>); <span class="hljs-comment">//去掉字符串最后的&#x27;\0&#x27;</span><br><br>        cout &lt;&lt; <span class="hljs-string">&quot;res = &quot;</span> &lt;&lt; boolalpha &lt;&lt;res &lt;&lt; endl;  <span class="hljs-comment">// 这里的boolalpha 是为了输出bool值true或者false</span><br><br><br><br>    &#125;<br><br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> Exception&amp; e)<br><br>    &#123;<span class="hljs-comment">//出现异常</span><br><br>        cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl; <span class="hljs-comment">//异常原因</span><br><br>    &#125;<br><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十一章-公钥密码学数学基础"><a href="#第十一章-公钥密码学数学基础" class="headerlink" title="第十一章 公钥密码学数学基础"></a>第十一章 公钥密码学数学基础</h1><h2 id="大整数-与-大素数生成"><a href="#大整数-与-大素数生成" class="headerlink" title="大整数 与 大素数生成"></a>大整数 与 大素数生成</h2><ul><li>可以再研究一下大整数的一些用法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;integer.h&gt;</span><span class="hljs-comment">//使用Integer</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span><span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;osrng.h&gt;</span><span class="hljs-comment">//使用AutoSeededRandomPool</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;nbtheory.h&gt;</span><span class="hljs-comment">//使用PrimeAndGenerator、VerifyPrime</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP;<span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    AutoSeededRandomPool rng; <span class="hljs-comment">// 定义随机数发生器对象</span><br><br>    <span class="hljs-comment">// 定义PrimeAndGenerator对象，利用随机数发生器rng产生素数p和q</span><br><br>    <span class="hljs-comment">// 要求产生的p是1024比特的素数，q是512比特的素数</span><br><br>    <span class="hljs-function">PrimeAndGenerator <span class="hljs-title">pag</span><span class="hljs-params">(<span class="hljs-number">1</span>, rng, <span class="hljs-number">1024</span>, <span class="hljs-number">512</span>)</span></span>;<br><br>    Integer p = pag.<span class="hljs-built_in">Prime</span>(); <span class="hljs-comment">// 获取素数p的值</span><br><br>    Integer q = pag.<span class="hljs-built_in">SubPrime</span>(); <span class="hljs-comment">// 获取素数q的值</span><br><br>    Integer r = (p - <span class="hljs-number">1</span>) / q / <span class="hljs-number">2</span>; <span class="hljs-comment">// 计算r的值，因为p=2*r*q+1，delta=1</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p(&quot;</span> &lt;&lt; p.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot;)：&quot;</span> &lt;&lt; p &lt;&lt; endl; <span class="hljs-comment">// 打印p的值及比特数</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;q(&quot;</span> &lt;&lt; q.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot;)：&quot;</span> &lt;&lt; q &lt;&lt; endl; <span class="hljs-comment">// 打印q的值及比特数</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;r(&quot;</span> &lt;&lt; r.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot;)：&quot;</span> &lt;&lt; r &lt;&lt; endl; <span class="hljs-comment">// 打印r的值及比特数</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">VerifyPrime</span>(rng, r, <span class="hljs-number">10</span>)) <span class="hljs-comment">// 验证r是否为素数</span><br><br>    &#123;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;r是素数&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 如果r为素数，则输出该信息</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">else</span><br><br>    &#123;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;r不是素数&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 如果r不为素数，则输出该信息</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十三章-数字签名"><a href="#第十三章-数字签名" class="headerlink" title="第十三章 数字签名"></a>第十三章 数字签名</h1><p>电子书给出的参考是ECNR数字签名算法</p><p><a href="https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA椭圆曲线 - Crypto++</a></p><p><a href="https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm">https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm</a> -》关于压缩公钥的实现可以参考 Compressed Point 这一部分</p><h2 id="私钥和公钥生成、保存"><a href="#私钥和公钥生成、保存" class="headerlink" title="私钥和公钥生成、保存"></a>私钥和公钥生成、保存</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;integer.h&gt;</span><span class="hljs-comment">//使用Integer</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span><span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;osrng.h&gt;</span><span class="hljs-comment">//使用AutoSeededRandomPool</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;eccrypto.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;oids.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;files.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filters.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hex.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;base32.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP;<span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ECDSA_Generate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 指定 private exponent  32字节随机数，生成对应的私钥</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    string exp = &quot;E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB&quot;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    HexDecoder decoder;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    decoder.Put((byte*)&amp;exp[0], exp.size());</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    decoder.MessageEnd();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Integer x;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    x.Decode(decoder, decoder.MaxRetrievable());</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    privateKey.Initialize(ASN1::secp256r1(), x);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br><br><br>    AutoSeededRandomPool prng;<br><br>    ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;<br><br><br><br>    privateKey.<span class="hljs-built_in">Initialize</span>( prng, ASN1::<span class="hljs-built_in">secp256k1</span>() );<br><br><br><br>    <span class="hljs-comment">/* 使用ByteQueue 方便将公私钥存储在内存中，如果要持久化到磁盘，可以使用FileSink</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ByteQueue queue;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    privateKey.Save(queue);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    privateKey.Load(queue);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br><br><br><br>    <span class="hljs-comment">// 验证密钥强度</span><br><br>    <span class="hljs-type">bool</span> result = privateKey.<span class="hljs-built_in">Validate</span>( prng, <span class="hljs-number">3</span> );<br><br>    cout &lt;&lt; boolalpha &lt;&lt; result &lt;&lt; endl;<br><br><br><br>    Integer p = privateKey.<span class="hljs-built_in">GetPrivateExponent</span>();<br><br>    cout&lt;&lt; <span class="hljs-string">&quot;len:&quot;</span> &lt;&lt; p.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot; Private Key:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    string priHexKey;<br><br>    <span class="hljs-function">HexEncoder <span class="hljs-title">encoder</span><span class="hljs-params">(<span class="hljs-keyword">new</span> StringSink(priHexKey))</span></span>;<br><br>    p.<span class="hljs-built_in">Encode</span>(encoder, <span class="hljs-number">32</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;priHexKey:&quot;</span>&lt;&lt;priHexKey.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; priHexKey &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// Save private key in PKCS #8 format</span><br><br>    <span class="hljs-function">FileSink <span class="hljs-title">fs1</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/private.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*binary*/</span> )</span></span>;<br><br>    privateKey.<span class="hljs-built_in">Save</span>( fs1 );<br><br><br><br>    <span class="hljs-comment">// Generate publicKey</span><br><br>    ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey publicKey;<br><br>    privateKey.<span class="hljs-built_in">MakePublicKey</span>(publicKey);<br><br>    <span class="hljs-type">const</span> ECP::Point&amp; q = publicKey.<span class="hljs-built_in">GetPublicElement</span>();<br><br>    <span class="hljs-type">const</span> Integer&amp; qx = q.x;<br><br>    <span class="hljs-type">const</span> Integer&amp; qy = q.y;<br><br>    string qxHex, qyHex;<br><br>    <span class="hljs-function">HexEncoder <span class="hljs-title">encoderx</span><span class="hljs-params">(<span class="hljs-keyword">new</span> StringSink(qxHex))</span></span>;<br><br>    <span class="hljs-function">HexEncoder <span class="hljs-title">encodery</span><span class="hljs-params">(<span class="hljs-keyword">new</span> StringSink(qyHex))</span></span>;<br><br>    qx.<span class="hljs-built_in">Encode</span>(encoderx, <span class="hljs-number">32</span>);<br><br>    qy.<span class="hljs-built_in">Encode</span>(encodery, <span class="hljs-number">32</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;len:&quot;</span> &lt;&lt; qx.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot; Public Point x:&quot;</span> &lt;&lt; qx &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;qxHex:&quot;</span> &lt;&lt; qxHex &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;len:&quot;</span> &lt;&lt; qy.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot; Public Point y:&quot;</span> &lt;&lt; qy &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;qyHex:&quot;</span> &lt;&lt; qyHex &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// Save public key in X.509 format</span><br><br>    <span class="hljs-function">FileSink <span class="hljs-title">fs2</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/public.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*binary*/</span> )</span></span>;<br><br>    publicKey.<span class="hljs-built_in">Save</span>( fs2 );<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="私钥和公钥的加载、签名和认证"><a href="#私钥和公钥的加载、签名和认证" class="headerlink" title="私钥和公钥的加载、签名和认证"></a>私钥和公钥的加载、签名和认证</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 头文件和上述一样</span><br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ECDSA_LOAD</span><span class="hljs-params">()</span></span>&#123;<br><br>    AutoSeededRandomPool prng;<br><br>    <span class="hljs-function">FileSource <span class="hljs-title">fs1</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/private.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span> )</span></span>;<br><br>    <span class="hljs-function">FileSource <span class="hljs-title">fs2</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/public.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span> )</span></span>;<br><br>    ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;<br><br>    ECDSA&lt;ECP, SHA256&gt;::PublicKey publicKey;<br><br>    <span class="hljs-comment">// 加载私钥， 私钥格式：PKCS #8</span><br><br>    privateKey.<span class="hljs-built_in">Load</span>( fs1 );<br><br>    publicKey.<span class="hljs-built_in">Load</span>(fs2);<br><br><br><br>    <span class="hljs-comment">// 用私钥进行签名</span><br><br>    ECDSA&lt;ECP, SHA256&gt;::<span class="hljs-function">Signer <span class="hljs-title">signer</span><span class="hljs-params">(privateKey)</span></span>;<br><br>    string message = <span class="hljs-string">&quot;Yoda said, Do or do not. There is no try.&quot;</span>;<br><br>    string signature;<br><br><br><br><br><br>    <span class="hljs-function">StringSource <span class="hljs-title">s</span><span class="hljs-params">( message, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">new</span> SignerFilter( prng,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                                      signer,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-keyword">new</span> StringSink( signature )</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                    ) <span class="hljs-comment">// SignerFilter</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>; <span class="hljs-comment">// StringSource</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;signature len:&quot;</span> &lt;&lt; signature.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; output:&quot;</span> &lt;&lt; signature &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// 将签名（包含R，S）转换成 DER 格式</span><br><br>    std::string derSign;<br><br>    <span class="hljs-comment">// Make room for the ASN.1/DER encoding</span><br><br>    derSign.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>+<span class="hljs-number">3</span>+<span class="hljs-number">3</span>+<span class="hljs-number">2</span>+signature.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-type">size_t</span> converted_size = <span class="hljs-built_in">DSAConvertSignatureFormat</span>(<br><br>            (byte*) (&amp;derSign[<span class="hljs-number">0</span>]), derSign.<span class="hljs-built_in">size</span>(), DSA_DER,<br><br>            (<span class="hljs-type">const</span> byte*) (signature.<span class="hljs-built_in">data</span>()), signature.<span class="hljs-built_in">size</span>(), DSA_P1363);<br><br>    derSign.<span class="hljs-built_in">resize</span>(converted_size);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;DER len:&quot;</span> &lt;&lt; derSign.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; DER:&quot;</span> &lt;&lt; derSign &lt;&lt; endl;<br><br>    string hexDER;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">toDER</span><span class="hljs-params">(derSign, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> HexEncoder(<span class="hljs-keyword">new</span> StringSink(hexDER)))</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;DER hex:&quot;</span> &lt;&lt; hexDER &lt;&lt; endl;<br><br><br><br>    <br><br>    <span class="hljs-comment">// 进行验证</span><br><br>    <span class="hljs-type">bool</span> result;<br><br>    ECDSA&lt;ECP, SHA256&gt;::<span class="hljs-function">Verifier <span class="hljs-title">verifier</span><span class="hljs-params">(publicKey)</span></span>;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">ss</span><span class="hljs-params">( signature+message, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-keyword">new</span> SignatureVerificationFilter(</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                             verifier,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">new</span> ArraySink( (byte*)&amp;result, <span class="hljs-keyword">sizeof</span>(result) )</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                     ) <span class="hljs-comment">// SignatureVerificationFilter</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>;<br><br><br><br>    <span class="hljs-comment">// 传统的C 方式 - 函数调用形式</span><br><br><span class="hljs-comment">//    result = verifier.VerifyMessage( (const byte*)message.data(), message.size(), (const byte*)signature.data(), signature.size() );</span><br><br>    <span class="hljs-keyword">if</span>(result)<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Verified signature on message&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">else</span><br><br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to verify signature on message&quot;</span> &lt;&lt; std::endl;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第三方库</tag>
      
      <tag>CryptoPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu-arm apt源配置</title>
    <link href="/2021/10/20/2021-10/2021-10-20%20Ubuntu-arm%20apt%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/10/20/2021-10/2021-10-20%20Ubuntu-arm%20apt%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><p>PC：M1 MacBook Air</p><p>虚拟机软件：Parallel Desktop 16.5</p><p>虚拟机操作系统：<a href="https://ubuntu.com/download/server/arm">Ubuntu Server 20.04 TLS</a></p><h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>首先就是随便搜索了一篇网上教程，来配置apt源，比如这篇</p><p><a href="https://blog.csdn.net/p1279030826/article/details/111640455">https://blog.csdn.net/p1279030826/article/details/111640455</a></p><p class='note note-info'>要注意自己的ubuntu版本和apt源设置的版本一致</p><p>但是然后呢，满怀期待执行<code>sudo apt-get update</code> 却报错了。。。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110201532536.png" alt="apt-get update报错 "></p><p>当时很郁闷啊，因为之前在windows虚拟机上配置的时候都好使的，怎么到你这就拉胯了呢？</p><p>后来在网上找各种资料、解决办法，有的说是网络的问题，有的说是DNS解析的问题，但经过各种尝试都没有效果，后来无奈放弃，就此作罢。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>但是天无绝人之路，当我第二次再次尝试配置的时候，终于让我找到了正确答案：<a href="https://zongxp.blog.csdn.net/article/details/90604966?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link">解决方案</a></p><p>重点就是后缀要加上-ports，这样对应的镜像源才是arm源，才能适配M1的mac系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">deb http://mirrors.aliyun.com/ubuntu-ports/ focal main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-proposed main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>​         </p><p>换源之后执行成功，nice！</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110201533176.png" alt="apt-get update成功"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总的来说踩了个坑，而究其原因，还是自己对这个apt配置参数没有理解到位，仅仅只是照猫画虎，复制教程，而没有领会其中的真意。同时对这个系统架构arm 和 x86的差异没有深刻认识，不同架构之间软件肯定是需要进行适配的，没有很清楚的认识到这一点。所以呢，学海无涯，我还差得远呢~</p><div align='center'><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110251023808.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" width="50%" height="50%" align="middle" ></div>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题01】白皮书导读</title>
    <link href="/2021/10/16/2021-10/2021-10-16%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9801-%E7%99%BD%E7%9A%AE%E4%B9%A6/"/>
    <url>/2021/10/16/2021-10/2021-10-16%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9801-%E7%99%BD%E7%9A%AE%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h1><p>论文地址：<a href="https://bitcoin.org/bitcoin.pdf">https://bitcoin.org/bitcoin.pdf</a></p><p>由于在“基于信任”模式下的交易，存在交易成本增加、限制了交易额的大小即阻断小额交易、商家欺诈行为等问题，本论文提出解决方案即比特币，这是一个P2P分布式的电子现金交易网络，依靠hash和加盖时间戳，以及工作量证明机制等手段，解决了双重支付问题，并在极大程度上保证了交易的有效性、正确性、抗伪性。论文中也详细介绍了实现所用到的技术、机制、原理等。</p><h1 id="主要收获"><a href="#主要收获" class="headerlink" title="主要收获"></a>主要收获</h1><p>个人感觉最大的收获就是对比特币的运行机制有了大体的认识，了解了整体流程，虽然可能一些技术的实现细节还是不够明朗。下面就是我对其中各个部分的认识和理解。</p><ul><li>在引言介绍部分，引出了比特币的产生背景，基于第三方机构的交易存在的种种问题，并提出比特币这一解决方案。然后接下来的各个章节介绍比特币涉及的主要关键技术。</li><li>Transactions部分描述了交易是如何被记录的，其中运用了Hash和公私钥，但仅仅记录是无法验证交易的有效性，即存在双重支出问题。</li><li>Timestamp Server部分描述了具体每个节点（服务器）的工作，即对形成的区块进行Hash，并加盖上时间戳，根据时序进行排列形成链。</li><li>Proof-of-Work部分描述了进一步说明Timestamp server的实现，即使用工作证明机制，通过找到满足条件的nonce来获得记账权，因为寻找这个nonce依靠CPU算力，CPU算力越高找到的概率越大，即one-CPU-one-vote规则，解决了多数决策中的代表问题。同时这样的方式，也保证了如果攻击者想要篡改某个区块，就先得把这个区块之后的区块都进行修改，而每个区块都是需要靠大量CPU算力来找到nonce，获得记账权进行修改，这样的成本是很大的。</li><li>Network部分则是描述了比特币网络的工作流程。其中提到的一个很重要的原则就是，所有人是默认最长链是最正确的。而正是有这一前提，才有了只要网络里超过51%的算力属于诚实节点，就能保证区块链里交易信息的正确性，因为诚实节点的算力超过一半，算得比攻击节点快，那么最长链肯定属于诚实节点一方。</li><li>Incentive部分说明的是激励机制，给予抢到记账权的节点一定的比特币，正是有这样的激励机制，各个节点才会愿意投入算力去争夺记账权，也才能是之前的工作量证明机制正常运行。还有一种就是以交易手续费的方式进行奖励。</li><li>Reclaiming Disk Space部分说明区块链可以通过Merkel Tree技术方法来压缩数据，减小空间存储。</li><li>Simplified Payment Verification部分则是说明了如何来检验交易的有效性，因为基于之前最长链总是正确的原则， 因此只要向网络上的节点进行询问，找到最长链就可以验证所有的有效交易记录。</li><li>Combining and Splitting Value部分描述的是形成交易的细节，是可以有多个输入的，而输出最多是两个。</li><li>Privacy部分则是说明比特币网络中的隐私相关问题。</li><li>Calculations部分用具体的数学计算来说明了，当一个攻击者在落后最长链Z个块的情况下，想要追上最长链的概率。结果表明，当落后的块数越多，追上的概率就越小，也就保证了区块链的安全性和稳定性。</li><li>Conclusion部分则是最后进行了总结。</li></ul><h1 id="存在疑问"><a href="#存在疑问" class="headerlink" title="存在疑问"></a>存在疑问</h1><ul><li><strong>问题1：怎么理解数字货币中的double-spending problem？</strong></li></ul><p>用数字货币交易时，是用先前的交易和下一个拥有者的公钥做Hash，然后用拥有者的私钥进行签名形成这一次交易，比如这次交易A支付给B 1个电子货币，然后A的余额只有1个电子货币，如果没有第三方机构进行监管，确认这个电子货币已经交易出去了，那么A可以继续拿这1个电子货币继续交易，而接受者也无法确认这1个电子货币是否真正的属于他。也就是说，没有第三方监管机构，也没有引入区块链P2P这个网络的话，相当于就没有办法确认交易的有效性，这里产生的交易仅仅起到一个记录的作用。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110162135282" alt="交易链示意图"></p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110162150429.png" alt="双重支出问题"></p><ul><li>进一步，那么比特币是怎么解决这个问题的呢？</li></ul><p>比特币建立起了一个用工作量证明机制的P2P网络，网络上的节点都可以进行记账（也就是记录交易信息），记账的方式是基于区块链技术，区块上记录着一段时间内的交易信息，然后按时序用链串联起来，就有了所有的交易信息；同时最长的区块链是被网络上的节点所共同认可是正确的，即相当于第三方监管的确认作用，证明某次交易有效。</p><p>用上面的例子继续说明A的余额只有一个，然后他又同时和B、C进行交易，这两条交易信息传播到网络上，各个节点进行记录。有节点先收到A给B一个比特币的消息，他们检查余额之后会自动忽略另外一条交易消息（这个检查应该是基于他们当前的链？）；同样，会有先收到A给C一个比特币消息的节点，在检查余额之后也会自动忽略另外一条消息。接下来算力最高的（CPU最多的）节点获得记账权，把他记录的区块加到主链上，然后网络上其他节点都会以主链上的交易信息为准。如果放入主链的交易信息是A转给B一个比特币，那么B将会获得比特币，交易的有效性得到确认；同理，如果放入主链的交易信息是A转给C一个比特币，那么C将会获得比特币。</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110162150837.png" alt="区块链解决双重支出问题"></p><ul><li><p><strong>问题2</strong>：不过这样又引出一个问题，这个主链是怎么确定下来，或者说找到的呢？是假设大部分节点都是有着相同的最长主链，然后直接在本地的区块链上加上最新的，然后把新产生的区块信息广播出去？然后再根据最长主链正确性的假设前提，其他节点根据该最长主链更新本地的区块链</p></li><li><p><strong>问题3</strong>：在上面的例子里，还有一个问题，怎么去检验一个交易里付款者的余额？或者说怎么找到该付款者之前的所有交易记录？用公私钥的话好像不太行，因为每次都可能变换。还是说这个账户是可以直接找到的，那隐私性是怎么保护？</p></li><li><p><strong>问题4：</strong>文中的网络部分提到了容错性，即有的网络节点可能会丢失之前的区块信息，那么这些节点该怎么找到当前的最长主链？</p><ul><li>我理解每次传播的区块都是最新的区块，节点会因此意识到自己丢失了区块信息（这个怎么意识到也是个问题，用最新区块里的的prev hash来验证？），那么怎么来获取丢失的区块信息呢？是从最新区块广播节点那拉取区块吗？</li></ul></li><li><p><strong>问题5</strong>：Merkel Tree剪枝压缩的具体实现</p></li><li><p><strong>问题6</strong>：论文通篇介绍了比特币的实现原理，那么比特币有什么问题，缺点呢？</p></li><li><p><strong>问题7</strong>：在存储部分提到，因为Merkel Tree的技术，存储并不是问题，那么有没有可能用优势来弥补劣势，像是空间换时间？</p></li></ul><h1 id="所思所感"><a href="#所思所感" class="headerlink" title="所思所感"></a>所思所感</h1><ul><li>比特币本身没有价值，但是却有着无比昂贵的价格，甚至有大量的电力、算力耗费在这上面，进行所谓的“挖矿”，从中获得真实的金钱财富，这对我来说有些不可思议，难以理解。我自身也说不太清楚，可能这是个哲学问题？一个从计算机里产生的电子货币，对现实世界没有实质性的价值或者说实用性，为什么却能被人们追捧，赋予了天价？把那些花费在找随机数、挖矿的电力和算力用在更需要的地方，会不会能创造有实际价值的事物？</li><li>通过阅读本篇论文，了解比特币大致的工作流程，实现原理，也认识到比特币最大的特点就是去中心化，没有了第三方机构，改变以往“基于信任”的交易模式，或许正是这种去中心化的、隐蔽的并且可靠的交易方式满足了一定人群的需求（可能并不正当），逃离政府监管，以我们的国情来说，这是不可接受的，对大部分人或许也不好理解。但是区块链这种技术，这种去中心化的网络不一定要落地在电子货币里，应该会有更广阔的应用场景，也需要我自己再学习了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题02】Developer Guide导读</title>
    <link href="/2021/10/11/2021-10/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9802-Developer%20Guide/"/>
    <url>/2021/10/11/2021-10/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9802-Developer%20Guide/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文阅读地址：<a href="https://developer.bitcoin.org/devguide/transactions.html">Bitcoin Developer Guide</a> </p><p>预计通读耗时：12小时（个人数据，仅供参考）</p><p>中文翻译：</p><p><a href="https://www.8btc.com/books/834/bitcoin-developer-guide/_book/5/5.html">比特币开发者指南-巴比特图书</a>  </p><p><a href="https://www.bookstack.cn/read/bitcoin_developer_guide/README.md">简介 - 《比特币开发者指南 | Bitcoin Developer Guide》 - 书栈网 · BookStack</a></p></blockquote><h1 id="章节概述"><a href="#章节概述" class="headerlink" title="章节概述"></a>章节概述</h1><p>此次阅读的内容是比特币Developer Guide，详细介绍了比特币中各种设计和技术细节。</p><ul><li>Block Chain：介绍比特币的结构基础区块链，包括工作量证明，块高与分叉，交易数据，共识规则改变引起分叉等内容。</li><li>Transaction：详细介绍了比特币中交易的相关内容，重点说明了交易的组成，交易中的UTXO的类型（使用何种支付方式P2PKH或者P2SH）。</li><li>Contracts：这里的合约跟以太坊的智能合约不太一样，感觉更像是来说明交易双方（针对人而不是交易）该如何进行交易，应该遵守哪些规则。主要介绍了托管和仲裁、微支付通道、Coinjoin（混币）</li><li>Wallet：钱包用来管理和花费UTXO，因为UTXO实际对应的是一个hash地址，因此钱包实际就是在管理公私钥，这部分内容也就更多在介绍公私钥的管理问题。</li><li>Payment Processing：这部分重点介绍如何使用比特币进行支付的相关问题。</li><li>Operating Modes：介绍比特币中全节点和SPV客户端。</li><li>P2P Network：这部分就是详细介绍了比特币运行在P2P网络中相关细节，包括对等节点的发现与链接，全节点的初始化，区块传播等。</li><li>Mining：介绍了单独挖矿和矿池挖矿两种挖矿（添加新的区块）方式。</li></ul><h1 id="重点内容"><a href="#重点内容" class="headerlink" title="重点内容"></a>重点内容</h1><blockquote><p>大部分是阅读各个模块时记录下的重点内容。</p></blockquote><h2 id="Block-Chain-区块链"><a href="#Block-Chain-区块链" class="headerlink" title="Block Chain 区块链"></a>Block Chain 区块链</h2><ul><li>Block chain里UTXO的作用，只能使用一次，这也解决了双花问题</li><li>Proof of work里也是充分利用了加密hash算法里随机的天然特性，hash number不可预知<ul><li>每2016块调整难度值，根据生成这2016块block的时间来调整，理想时间是1,209,600秒(two weeks).</li></ul></li><li>Transaction data：block里的第一个交易是一个coinbase交易（由生成的区块奖励和输入输出费用差组成），通常只有在100块之后，才能被花费使用，这么做的目的是因为分叉比较常见，防止因为分叉的原因导致原先的区块失效<ul><li>有个问题是，如何保证必须要在100块之后才能进行花费，是在创建block的时候，判断输入的UTXO所在的区块的深度超过100吗？</li></ul></li><li>共识规则改变：共识规则改变，会有两种不同的情形，分别导致硬分叉和软分叉，不是很能理解其中的含义，查阅相关资料有了进一步认识。（现在比特币的更新，基本就是软分叉）</li></ul><blockquote><p><strong>常见的理解是“硬分叉和老版本软件不兼容、软分叉和老版本兼容”</strong>，这个定义是<strong>不准确</strong>的，但是很多地方已经在用了。。<br><strong>硬分叉的定义是扩宽共识规则</strong>，允许做之前禁止的事情，以前无效的交易&#x2F;区块在硬分叉后会变成有效的；<strong>软分叉是收紧共识规则</strong>，禁止之前允许做的事情，以前有效的交易在软分叉后就无效了。<br><strong>软&#x2F;硬分叉是共识规则的改变，和链分叉&#x2F;链重组完全是两码事；这两对概念的关系类似于“红烧&#x2F;清蒸”与“烧糊&#x2F;夹生”。</strong>不当部署的软&#x2F;硬分叉都有可能导致链分叉&#x2F;链重组。<br>所以，可以想见：<br>硬分叉之后，几乎一定会产生让老节点拒绝接受的区块，所以，硬分叉会破坏前向兼容性；<br>软分叉之后，产生的新区块肯定是老节点也愿意接受的，前向兼容性得以保留。</p></blockquote><ul><li>Detecting forks 发现分叉：通过监控区块链工作量证明而发现硬分叉的代码；监控最近区块的版本号</li></ul><h2 id="Transaction交易"><a href="#Transaction交易" class="headerlink" title="Transaction交易"></a>Transaction交易</h2><ul><li><strong>P2PKH</strong> 即 pay to public key hash，向公钥哈希地址支付<ul><li>交易的输入使用一个TXID和output index number（对于output来说处在交易的哪个位置）来标识，然后还有一个签名脚本，验证该input对应的output包含的公钥脚本，用来证明这笔输入的钱的确是本人持有</li><li>交易的输出包含一个隐含的index number，以聪为单位的余额量，一个公钥脚本</li><li>Bob要使用Alice的支付给他的UTXO，Alice创建转账的Tx交易时需要用到Bob的公钥，因此Bob的公私钥是提前生成好的，使用ECDSA椭圆签名曲线生成；然后Bob将公钥hash，使用Base58编码地址版本编号、公钥哈希、错误校验码，然后传给Alice，Alice可以进行解码得到公钥hash，并添加到交易中，作为output中的pubkey script，来标识输出到哪个地址；</li><li>而当Bob需要使用这份UTXO，发布交易时，需要构造input，引用Alice创造的交易TX（即TXID和对应的output index number），还需要包含一个签名脚本(signature script），这个签名脚本用来验证这笔输入的确是Bob所有。这个签名脚本里包含了Bob的公钥和签名，而签名的数据包含了Alice创造的交易TXID和index number，输出给其他用户的pubkey script，输出的余额。而输出output，正如上述所说，包含一个隐含的index number，以聪为单位的余额量，一个公钥脚本。</li></ul></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110111350637.(null)"></p><ul><li><p><strong>P2SH</strong>：提出P2SH的目的主要是因为在之前的交易中，都是由发送者负责指定赎出币的条件。这样的话，如果赎出币的过程比较复杂，譬如要使用MULTISIG，那么对付钱的用户，也就是买家，就不够友好。使用P2SH的方式，可以由币的接收方设计好执行的脚本，然后不论脚本多么复杂，发送方只需要将币发送到一个20字节的哈希地址就行。</p><ul><li>有关资料参考：<a href="https://zhuanlan.zhihu.com/p/46072343">P2SH机制</a></li></ul></li><li><p>标准的公钥脚本类型：P2PKH、P2SH、Multisig、Pubkey、Null Data</p></li><li><p>交易中Locktime和Sequence numbers的说明</p><ul><li>Locktime, 也被称为nLockTime, 它定义了个最早时间，只有过了这个最早时间，这个transaction可以被发送到比特币网络。通常被设置为0，表示transaction一创建好就马上发送到比特币网络</li><li>Sequence numbers用来使签名者更新交易，如果sequence numbers设置成0xffffffff时，表明更新完成，就可以立即生效加入到比特币区块中，这个生效是不管Locktime是否过期。</li><li>另一种理解：<ul><li>LockTime ：绝对时间，用的是整个区块链的长度，或者时间戳来表达的。</li></ul></li></ul></li><li><p>Sequence Number : 相对时间，当前交易所引用的UTXO所在的块（也就是输入所在的块），后面追加了多少个块。</p></li><li><p>参考：<a href="https://zhuanlan.zhihu.com/p/43171481">深入浅出微支付通道</a></p></li></ul><h2 id="contract合约"><a href="#contract合约" class="headerlink" title="contract合约"></a>contract合约</h2><ul><li>结合之前的P2SH方式中，对multisig有了更进一步的理解。A向B买东西，A使用P2SH，把钱支付到一个脚本地址并使用2-of-3签名（此时比特币只属于这个脚本地址），当B发货了，A收到确认没问题了，那么使用A和B的签名就可以把脚本地址的UTXO转给B的地址。如何A反悔了，不肯提供签名，那么B可以找仲裁机构C，使用B和C的签名也能将脚本地址的UTXO转给B；同理B如果没有发货，A也能找C把钱转回给A。也就是说，相比P2PKH直接转账方式，P2SH相当于多了一步验证等待，验证成功了再转账到用户地址。</li><li>Micropayment Channel 微支付通道</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110111350785.(null)"></p><ul><li><p>其工作原理大体上可以这样描述：A给B打工，B首先使用A和B的签名，使用P2SH的方式，发送一定金额到脚本地址，并将该交易立即传播到比特币网络上；然后B创造第二个交易，并用到刚刚A的签名，其输入是第一个交易的脚本地址，输出是B的地址（相当于全额返回给B），然后给这个交易加上Locktime，比如说一天后才能广播这个交易。然后A给B工作一部分内容后，A要求B先支付这份工作量的薪水，那么B就创建一份新的交易，从原来全额给B变成分出一部分金额给A，这个新的交易拷贝给A，这样A就可以广播这个新的交易从而获得薪水。（实际上A只需要在locktime过期前，广播最后版本的交易即可）</p></li><li><p>为什么采用这样的方式呢，因为A诉求是及时支付薪水，但是因为量小，B不能每次都立即创造一个交易即刻支付，这样的交易费的成本太高了。所以利用这样的方式，既确保了A的薪水是及时得到确认的，又可以使得只需一个交易就一次性支付薪水</p></li><li><p>实际上，更改交易金额的输出，这个权利是在B的，因为B有A的签名但A没有B的签名，A拿的是经过B签名后的交易副本（这个交易被B签名过了，所以是有效的）。所以A能实时确保自己对应工作量的薪水能及时支付，就算中途B跑路了，也只是损失一小部分工作量的薪水，之前的薪水都可以得到支付。而对B来说，如果A没有工作，那B也能在locktime 过期后拿回自己的钱（不过这样就需要等待一个locktime的时间）</p></li><li><p>Coinjoin混币交易，增加隐匿性，保护隐私，当和其他输入输出混杂在一起时，别人就难以追踪输出记录了</p></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110111350075.(null)"></p><h2 id="Wallet钱包"><a href="#Wallet钱包" class="headerlink" title="Wallet钱包"></a>Wallet钱包</h2><ul><li>钱包程序主要可分为三个子程序，一个程序来发布公钥用于接收比特币，而另一个程序对交易做签名来花费比特币，还有一个网络程序用来跟P2P网络交互。更具体地说，一个完整的钱包程序应包括这些功能：生成私钥，生成对应的公钥，按照需要对公钥进行发布，监听以这些公钥作为输出的交易，创建交易并对其进行签名，广播已签名的交易。</li><li>Wallet file 是对私钥进行管理；描述了私钥和公钥的格式</li><li>参考：<a href="https://blog.csdn.net/omnispace/article/details/79816141">数字货币钱包 - 助记词 及 HD 钱包密钥原理_omnispace的博客-CSDN博客</a></li></ul><h2 id="Payment-Processing-支付处理"><a href="#Payment-Processing-支付处理" class="headerlink" title="Payment Processing 支付处理"></a>Payment Processing 支付处理</h2><ul><li>介绍四种支付比特币的方式和相关的具体细节，包括明文，bitcoin:URI，QR码，新的支付协议X.509</li><li>其中提到一种“Merge Avoidance合并规避”的方法来保护用户隐私，该方法大体的意思就是让减少各个账户连接在一起的次数（或者说减少输入的个数）。因为当你使用UTXO作为输入进行花费时，UTXO原先的owner就可以追溯这次交易的信息，输入的UTXO越多那么能追溯到这笔交易的人就越多，隐私就会受到影响。用官方的例子来说，你有100，200，500，900的UTXO，然后你现在需要支付300BTC，那么你该选用500的UTXO来进行支付（而不是选择100，200作为输入，体现了合并，规避风险）。</li></ul><h2 id="Operating-Modes运行模式"><a href="#Operating-Modes运行模式" class="headerlink" title="Operating Modes运行模式"></a>Operating Modes运行模式</h2><ul><li>比特币主要有两种运行模式：一个是全节点客户端（包含所有区块和交易信息），一个是SPV客户端（只保存区块头信息）。SPV客户端可以通过请求全节点拿到相应的区块信息，进行验证。然而SPV客户端有两个缺点，一个是可能会被全节点欺骗，解决办法是连接多个全节点，保证不要和诚实节点断开链接了；另一个是容易受到拒绝服务攻击，解决办法是布隆过滤器</li><li>参考：<a href="https://shuwoom.com/?p=857">布隆过滤器(Bloom Filter)、SPV和比特币 - shuwoom的博客</a></li></ul><h2 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h2><ul><li>因为共识规则不包括网络，所以有可选的网络和协议。这里用Bitcoin Core作为全节点代表，BitcoinJ作为SPV客户端代表。</li></ul><h3 id="Peer-Discovery"><a href="#Peer-Discovery" class="headerlink" title="Peer Discovery"></a>Peer Discovery</h3><ul><li>首先通过询问DNS seeds来获取对等网络其他有效运行的节点IP，和对等节点建立连接后，可以获取得到更多的网络节点IP。此外，在程序中会有一些固定的静态IP可以尝试连接，或者使用命令行工具尝试与指定IP连接。</li></ul><h3 id="Connecting-to-Peers"><a href="#Connecting-to-Peers" class="headerlink" title="Connecting to Peers"></a>Connecting to Peers</h3><ul><li>节点通过发送version消息连接到一个对等节点。消息version 包含了节点的版本信息、块信息和距离远程节点的时间。一旦这个消息被对等节点收到，它必须回复一个verack。如果它愿意建立对等关系，它将发送自己的version消息。</li><li>一旦建立对等关系，节点可以向远程节点发送getaddr和addr消息来获得其它的对等节点信息。为了维持与对等节点的连接，节点默认情况下每30分钟内会给对等节点至少发送一次信息。如果超过90分钟没有收到回复，节点会认为连接已经断开</li></ul><h3 id="Initial-Block-Download"><a href="#Initial-Block-Download" class="headerlink" title="Initial Block Download"></a>Initial Block Download</h3><ul><li>一个全节点在正式工作或者提供服务前，需要进行初始化，把除了硬编码生成的第一个区块外的所有区块下载下来，这个过程就是IBD。</li><li>Block-First 是其中一种下载方式，向一个对等网络节点进行询问，直接下载区块，其缺点也很明显<ul><li>下载速度的限制：只从一个同步节点下载，受限该节点的带宽</li><li>重新下载：同步节点可能会发送不是最长链上的区块，就会导致快结束时才发现需要重新下载</li><li>磁盘空间占用：和“重新下载”相关，下载时可能会将无用的区块保存到磁盘，占用空间</li><li>大量内存使用：因为同步节点发送过来的区块可能是无序的，所以需要先保存到内存中，直到接收到父块才能进行验证</li></ul></li><li>Header-First 的下载方式，解决了Block-First中四个缺陷，它的工作方式是：先向同步节点下载block headers，当部分地验证headers有效性后，IBD节点就可以并行地做两天事——一个是继续向同步节点发送请求下载headers，另一个是向其他对等节点发送请求下载block</li></ul><h2 id="Mining-挖矿"><a href="#Mining-挖矿" class="headerlink" title="Mining 挖矿"></a>Mining 挖矿</h2><ul><li>现在有两种挖矿方式：单独挖矿和矿池挖矿<ul><li>单独挖矿：bitcoind来获取P2P网络上的交易，挖矿软件通过RPC方法来获取列表，并构造一个Block模板，然后将对应的block header发送给ASIC进行运算。挖矿软件会将一个nonce值填入币基交易的的字段中，获得新的Merkle root的hash值，然后将新的Block header发送个ASIC。如果ASIC计算生成的block header hash小于预定的阈值，则表明添加的nonce值符合条件，将block header返回给挖矿软件，挖矿软件根据返回的block header更新block，最后将完整的block 返回给bitcoind，bitcoind再向网络传播区块</li></ul></li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110111350617.(null)"></p><ul><li>矿池挖矿：工作流跟单独挖矿类似。不同的是，矿池设定的阈值要比网络上设定的阈值小很多（降低了难度），因此各个矿工通过挖矿软件返回给矿池的block hearder中，有很多是满足矿池的阈值但不满足网络的阈值，这些返回的block header相当于是份额，证明了矿工的工作量；同时总会有几率产生同时满足两个阈值的block header，矿池将满足网络阈值条件的block发送给bitcoind，从而获得奖励。然后矿池根据矿工贡献的份额，平均分发奖励。举个具体例子就是，矿工们总共返回了100个满足矿池条件的block header（相当于有100份额），只有1个满足网络阈值，那么每份额的奖励就是总奖励的1&#x2F;100，矿工根据自己的份额获得相应奖励。</li></ul><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110111350905.(null)"></p><ul><li>还介绍了三种挖矿软件获取Block的RPC<ul><li>getwork RPC：当前Bitcoin Core已经废弃，这个方法直接为矿工构造好block header，因此矿工可能需要调用成百上千次RPC</li><li>getblocktemplate RPC：获取以下内容；然后挖矿软件就能自己改变nonce值，自己生成block header<ul><li>构造币基交易的信息</li><li>bitcoind发送给矿池的交易列表和具体交易信息，这使得挖矿软件可以查看交易，并有选择性地添加或删除交易</li><li>构造block header的其他信息</li><li>矿池提供的难度值或者网络设定的难度值</li></ul></li><li>Stratum：跟getblocktemplate很类似，但是不同的是，挖矿软件获取到的是重新构造Merkle树的必要信息，而不是具体的交易列表和交易内容。因此，挖矿软件不能添加或者删除交易，不过此时挖矿软件和矿池建立双向的TCP连接；在getblocktemplate 里，挖矿软件用的是HTTP longpoll长轮询，来获取最近的更新。</li></ul></li></ul><h1 id="存在疑问"><a href="#存在疑问" class="headerlink" title="存在疑问"></a>存在疑问</h1><p>阅读完所有内容后，还是有很多问题和细节没有弄明白。</p><ol><li>原文：Since it is impractical to have separate transactions with identical txids, this does not impose a burden on honest software, but must be checked if the invalid status of a block is to be cached; otherwise, a valid block with the duplicates eliminated could have the same merkle root and block hash, but be rejected by the cached invalid outcome, resulting in security bugs such as <a href="https://en.bitcoin.it/wiki/CVEs#CVE-2012-2459">CVE-2012-2459</a>.</li></ol><blockquote><p>对于上述内容不是很能理解，不同的transactions怎么会有相同的TXID，可能是由于hash冲突导致的？虽然概率很小。然后“对于缓存一个无效区块的状态”，这该如何理解？什么时候用到了缓存，缓存什么内容（区块的状态？），以及如何判断区块是有效还是无效？如果因为有TXID冲突判定区块无效的话，可以去重TXID，达到有效？</p></blockquote><ol><li>标准交易中，Null Data的的pubkey scripts类型用来干什么的？</li><li>P2PK 被 P2PKH所取代了，支付到公钥哈希的地址，可以使得公钥直到UTXO被使用时才会发布，延迟公钥发布的原因是什么呢？是为了避免攻击者利用公钥进行某些攻击吗？</li><li>多种Signature hash types的用途是什么呢？为什么要有选择性的进行签名？</li><li>交易被打包到区块，交易的费用是根据交易的签名字节长度计算出来，那么这笔费是由买家（支付者）来付吗？在对应的一个交易中，是会增加一个output来指向矿工吗？</li><li>对于HD钱包，即分层确定性钱包中的工作原理还是不太理解，特别是extened keys到harderned keys的转变，为什么要这么做？这么做如何解决问题的？</li><li>SPV客户端具体是怎么使用布隆过滤器的？</li><li>矿工发布区块时，具体是怎么给矿工发放奖励的？是在创建区块的时候，直接生成一个币基交易（把钱转账给该矿工），然后矿工打包所有交易后，开始找满足条件的nonce，找到后广播区块，这样如果区块得到其他节点认可上链了，那么矿工就切实得到了收益。（这样的话，每个节点在生成区块）</li></ol><h1 id="所思所感"><a href="#所思所感" class="headerlink" title="所思所感"></a>所思所感</h1><p>阅读完这篇Guide概览，让我认识了解比特币中许多技术和实现细节，但是通读完一遍后，发现自己好像懂了，又好像没懂，或者说从整体上对比特币的整体架构有了一定的认识，具体有哪些部分组成，涉及哪些关键技术，但是对个各个模块进一步的细节还是似懂非懂，并且还是难以串联起来，各个部分有明显的联系（比如交易与钱包与支付处理），但是感觉自己还是很难将这三者的关系表示清楚，或者说，当把整个比特币看做一个整体时，各个部分是怎么样有机独立又相互配合的。</p><p>还有一个简单的思考，就是对于合约部分中多重签名的使用，例如托管和仲裁，A和B之间的交易还是要依赖于仲裁第三方C，这是否与比特币去中心化的思想相矛盾了呢？后来进一步思考和查阅资料，从另一个视角去看，去中心化，不是不要中心，而是由节点来自由选择中心、自由决定中心。简单地说，中心化的意思，是中心决定节点。节点必须依赖中心，节点离开了中心就无法生存（类似于没了支付宝就不能用淘宝？）。而在去中心化系统中，任何人都是一个节点，任何人也都可以成为一个中心。任何中心都不是永久的，而是阶段性的，任何中心对节点都不具有强制性。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【99%环境搭建系列】云计算管理平台Devstack安装</title>
    <link href="/2021/10/08/2021-10/2021-10-08%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97%20-devstack%E5%AE%89%E8%A3%85/"/>
    <url>/2021/10/08/2021-10/2021-10-08%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97%20-devstack%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p class='note note-success'>99%概率完成环境搭建，让天下没有搭建不了的环境！ </p><p>openstack作为开源的云计算管理平台，可以让我们体验云计算技术的各种组件和功能，然而官网繁琐的配置教程令人望而却步。好在devstack提供了一站式安装服务，<del>只需简单执行几个命令即可完成安装</del>（根本不是这样好吗！）。不过经过我的百般测试，只要安装教程里的方式执行命令，成功概率99%！</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110082112035.png"></p><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>这里说一下我个人的安装环境</p><ul><li>PC操作系统：win10</li><li>VMware Workstation版本：16.x Pro</li><li>Ubuntu版本：18.04</li></ul><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><ol start="0"><li><strong>简要说明</strong></li></ol><p class='note note-primary'>ubuntu操作系统在虚拟机的安装这里不再演示，假设你已经完成了ubuntu18.04的安装，然后继续；<br>在~/ 目录下，依次执行命令即可，没有特殊说明，不用执行别的多余命令</p><ol><li><strong>设置静态IP（可选）</strong></li></ol><blockquote><p>说明：这一步是可选的，之所以设置成静态IP，是为了方便后面的配置，以及排除IP变动的原因导致的种种意外；不过不进行配置的话，应该也是ok的，只要保证整个安装以及使用过程IP不会改变</p><p>参考网站：<a href="https://www.cnblogs.com/yaohong/p/11593989.html">ubuntu配置静态ip</a>       <a href="https://blog.csdn.net/zh2508/article/details/85250360">VMware配置静态ip</a></p></blockquote><p>首先给机器设置静态ip，修改<code>/etc/netplan</code>目录下对应的文件，按如下文件进行配置。</p><p class='note note-info'>  三个注意点：<br>  1. 注意配置里的"ens32" 根据自己的机器进行改动，可能是"ens33"，可以通过命令 ip addr 来进行查看 <br>  2. 这里复制的话，注意复制后的结果是否一致，可能需要自己手动输入一下，这样的话要严格注意格式，冒号后面需要一个空格，换行缩进是4个空格<br>  3. 设置的ip和网关要在同一个网段上，记住这里填入的ip，需要用在下面的配置中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br><span class="hljs-attr">network:</span><br><span class="hljs-string">​</span>    <span class="hljs-attr">ethernets:</span><br><span class="hljs-string">​</span>        <span class="hljs-attr">ens32:</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]<br><span class="hljs-string">​</span>            <span class="hljs-attr">optional:</span> <span class="hljs-literal">true</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.2</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">nameservers:</span><br><span class="hljs-string">​</span>                    <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.1</span>,<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.2</span>] <span class="hljs-comment"># 这里DNS的修改，是因为我配置了上面VMware配置静态ip</span><br></code></pre></td></tr></table></figure><p>然后执行<code>sudo netplan apply</code>，让配置生效，再通过<code>ip addr</code>查看是否生效，已经<code>ping</code>命令查看网络是否连通</p><ol start="2"><li><strong>切换apt源</strong></li></ol><p>切换apt源的目的是为了加快下载安装的速度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install vim #先安装下vim<br>sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak<br>sudo vim /etc/apt/sources.list # 如果vim还没有安装，改用 vi 复制下就行<br></code></pre></td></tr></table></figure><p>这里配置用的是阿里云的镜像，如果之后因为网络的问题可以尝试换下别的源，不过我测试使用的都是阿里云</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注意ubuntu版本号对应不同的代号，这里用的是18.04，对应bionic</span><br>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>更换pip源</strong></li></ol><p>也是为了加快下载安装依赖的速度</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> .pip<br>vim .pip/pip.conf<br></code></pre></td></tr></table></figure><p>配置如下所示，用的是豆瓣的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[global]<br>index-url = http://pypi.douban.com/simple/<br>trusted-host = pypi.douban.com<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>更新并安装包</strong></li></ol><p>依次执行下列命令，主要是更新安装相关依赖，下载pip管理依赖工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get upgrade<br>sudo apt-get install git<br>sudo apt-get install python-pip<br>sudo pip install --upgrade pip<br>sudo pip install -U os-testr  # sudo pip install wcwidth 可选，如果这一步出了wcwidth相关的error的话<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>设置时区同步</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install ntpdate // 安装时间同步工具<br>sudo ntpdate cn.pool.ntp.org // 与网络服务器同步时间<br>date // 查看时间是否已经同步<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>下载devstack</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/openstack/devstack.git -b stable/queens</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">推荐使用opendev.org官网的wallby这个分支，github上对应的queens这个分支尝试过有问题解决不了</span><br>git clone https://opendev.org/openstack/devstack.git -b stable/wallaby <br></code></pre></td></tr></table></figure><ol start="7"><li><strong>创建stack用户</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo devstack/tools/create-stack-user.sh<br></code></pre></td></tr></table></figure><ol start="8"><li><strong>移动并设置文件夹权限</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mv devstack /opt/stack<br>sudo chown -R stack:stack /opt/stack<br>sudo chown stack:stack /opt/stack<br></code></pre></td></tr></table></figure><ol start="9"><li><strong>切换到stack用户</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo su - stack<br></code></pre></td></tr></table></figure><ol start="10"><li><strong>创建local.conf配置文件</strong></li></ol><p>执行下列命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd devstack<br>vim local.conf<br></code></pre></td></tr></table></figure><p>配置文件内容如下，<strong>注意修改HOST_IP</strong>，改成自己当前的IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[[local|localrc]]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Define images to be automatically downloaded during the DevStack built process.</span><br>DOWNLOAD_DEFAULT_IMAGES=False<br>IMAGE_URLS=&quot;http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">use TryStack git mirror</span><br>GIT_BASE=http://git.trystack.cn<br>NOVNC_REPO=http://git.trystack.cn/kanaka/noVNC.git<br>SPICE_REPO=http://git.trystack.cn/git/spice/sice-html5.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Credentials</span><br>[[local|localrc]]<br>ADMIN_PASSWORD=admin<br>DATABASE_PASSWORD=$ADMIN_PASSWORD<br>RABBIT_PASSWORD=$ADMIN_PASSWORD<br>SERVICE_PASSWORD=$ADMIN_PASSWORD<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Host IP - get your Server/VM IP address from ip addr <span class="hljs-built_in">command</span></span><br>HOST_IP=192.168.10.112 # ifconfig获取本机ip<br>enable_service placement-api<br>enable_service placement-client<br></code></pre></td></tr></table></figure><ol start="11"><li><strong>提前下载依赖包</strong></li></ol><p>因为是从github上连接下载依赖包，可能由于网络不好的问题，直接安装的话可能中途会因为下载失败导致安装失败，所以这里提前下载；如果下载失败了，就多执行几次，肯定是可以的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd files/<br>wget -c https://github.com/coreos/etcd/releases/download/v3.1.10/etcd-v3.1.10-linux-amd64.tar.gz<br>wget -c https://github.com/coreos/etcd/releases/download/v3.1.7/etcd-v3.1.7-linux-amd64.tar.gz<br>wget -c https://github.com/etcd-io/etcd/releases/download/v3.3.12/etcd-v3.3.12-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><ol start="12"><li><strong>安装simplejson</strong></li></ol><p>经过测试，之后安装的过程中可能会报错simplejson安装失败，所以这里提前进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">sudo apt-get purge python3-simplejson 清楚之前的软件包和配置</span><br>sudo apt-get install python3-simplejson<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sudo apt-get install python-simplejson <span class="hljs-comment"># 上面的命令不行可以试下这个</span></span><br></code></pre></td></tr></table></figure><ol start="13"><li><strong>修改pip安装配置</strong></li></ol><p class='note note-info'>  在测试中，pip相关安装可能会报错，这里提前修改下</p><p>修改对应的目录文件 <code>devstack/inc/python file 198 line</code></p><p> 源代码 <code>$cmd_pip $upgrade</code> </p><p> 修改成 <code>$cmd_pip $upgrade --ignore-installed</code></p><ol start="14"><li><strong>修改权限</strong></li></ol><p>经过测试，之后安装的过程可能会出现如下权限错误的错误，所以这里再次修改权限</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110082049771.png" alt="pip下载报错"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chown -R stack:stack /opt/stack<br>sudo chown stack:stack /opt/stack<br>sudo chown -R stack:stack /opt/stack/devstack<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sudo <span class="hljs-built_in">chmod</span> -R 777 /opt/stack  <span class="hljs-comment"># 先用前三个命令应该足够了，不行再试试这个</span></span><br></code></pre></td></tr></table></figure><ol start="15"><li><strong>开始安装</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>FORCE=yes ./stack.sh<br></code></pre></td></tr></table></figure><p>可能因为网络的原因，中途会连接不上github，导致安装失败，这样就需要重新尝试，先清理下环境再安装，多尝试几次应该都会成功的，不过确保网络质量也比较重要。</p><p>如果是因为下载github上某个依赖包导致的失败，可以事先安装好对应的依赖，使用pip命令下载即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">./unstack.sh<br>./clean.sh<br>FORCE=yes ./stack.sh<br></code></pre></td></tr></table></figure><ol start="16"><li><strong>见证奇迹的时刻</strong></li></ol><p>当你看到如下信息的时候，恭喜你，完成安装~</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110081954141.(null)" alt="成功截图"></p><ol start="17"><li><strong>openstack界面展示</strong></li></ol><p>具体如何使用openstack，这里就不再详细演示，openstack功能大家就自行地快乐玩耍吧~</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110081954271.(null)" alt="openstack界面展示"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到此为止，devstack的安装教程就到此结束了，如果安装上面的步骤成功了，恭喜你我的朋友！</p><div align='center'><img src='https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110082121023.jpeg' width='30%' height='30%' > </div><p>当然如果出现了别的问题无法解决的话，可以评论留下你的问题，或者与我联系。</p><hr><p>如果真的山穷水尽了的话，microstack 官网教程值得你的拥有~</p><p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202110082124003.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/hunjiancuo5340/article/details/85005995">https://blog.csdn.net/hunjiancuo5340/article/details/85005995</a></p><p><a href="https://blog.csdn.net/u013184378/article/details/84973629">https://blog.csdn.net/u013184378/article/details/84973629</a></p><p><a href="http://www.cnblogs.com/lianshuiwuyi/p/10955041.html">http://www.cnblogs.com/lianshuiwuyi/p/10955041.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>环境搭建系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devstack</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏王台词收录</title>
    <link href="/2021/09/30/2021-09/2021-09-30%20%E6%B8%B8%E6%88%8F%E7%8E%8B%E5%8F%B0%E8%AF%8D%E6%94%B6%E5%BD%95/"/>
    <url>/2021/09/30/2021-09/2021-09-30%20%E6%B8%B8%E6%88%8F%E7%8E%8B%E5%8F%B0%E8%AF%8D%E6%94%B6%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏王"><a href="#游戏王" class="headerlink" title="游戏王"></a>游戏王</h1><h2 id="凯撒亮"><a href="#凯撒亮" class="headerlink" title="凯撒亮"></a>凯撒亮</h2><p>因为之前也入坑过游戏王决斗链接国际服，也就组过月光、不知火、电子龙三套牌组，电子龙是我退坑前最后组的卡组，因此也有着特殊的感情。不久前听闻电子龙被彻底削废了，直接入土为安，心情也是五味杂陈，还能继续挣扎吗？</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202109301523396.jpg" alt="img"></div><div class="group-image-wrap"><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202109301531454.jpg" alt="img"></div></div></div><p><a href="https://www.bilibili.com/video/BV12b4y1C7wC">【日语每日一句】凯撒亮经典台词教学</a></p><p>Ko re ga, i ki no ku ru ta me no, o re no a ga ki da !</p><img src="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/img/202109301537861.png" width="50%" height="50%" align="middle" ><p>你又是如何呢，你又是为了什么而奋战至今？只要为了达到理想的终点，就算是卑微的挣扎又如何，这就是我所选择的道路！！</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
      <category>动漫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏王</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Fluid主题博客搭建</title>
    <link href="/2021/09/28/2021-09/2021-09-28%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/09/28/2021-09/2021-09-28%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实这个前言应该叫做”后记“了，之前一直这篇文章一直处于草稿的状态，心想着等博客网站正式上线了再改也不迟，这一拖就是3、4个月，属实是惭愧。但欠下的债终归是要偿还的，不是吗？</p><h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><p>其实网上搭建hexo博客的教程很多，感觉自己再重复造轮子也没什么必要，因此这里给出我在学习搭建博客过程中参考的一些文章博客：</p><ul><li><p><a href="https://evenweiss.github.io/2021-08-02-blog-building/#%E4%B8%80%E3%80%81Github-Pages-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%85%8D%E7%BD%AE">博客搭建教程</a></p></li><li><p><a href="https://www.cnblogs.com/mfrank/p/12829882.html">Hexo博客部署Github Pages</a></p></li><li><p><a href="https://blog.csdn.net/i_do_not_know_you/article/details/105594269">绑定域名的遇到坑</a></p></li><li><p><a href="https://hexo.fluid-dev.com/posts/fluid-write/">搭配 Fluid 如何优雅的写一篇文章</a></p></li></ul><h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><ol><li>绑定阿里云的top域名，解析成功的问题是：访问速度变得巨慢，并且页面效果很差，图片几乎展示不出来；和vercel部署出来的效果一致（是不是存在什么共性？）</li></ol><ul><li>这个问题后面也没有解决，令人惭愧，但我感觉是部署在境外服务器的问题？</li></ul><hr><ol start="2"><li>当删除阿里云域名解析相关记录后，访问2017zhangyuxuan.github.io 依然会跳转到注册的域名上kingofdark.top，然后报错HTTP 502</li></ol><ul><li>过了一天之后好像正常了，应该是DNS解析缓存的问题。</li></ul><hr><ol start="3"><li>取消Waline评论时显示浏览器内核与操作系统信息</li></ol><ul><li>hexo-theme-fluid&#x2F;source&#x2F;css&#x2F;main.styl 路径下添加以下配置 (不过好像只有本地预览有效，部署到Github pages上依然不生效；在Vercel部署的，同样也已经生效了)</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.vmeta</span> &#123;<br>  <span class="hljs-attribute">display</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>更好的做法是在服务端配置 DISABLE_USERAGENT 环境变量为true；重新部署后得到新的server url，一定要记得把这个server url填写到_config.fluid.yml文件中，更新！！ 这里踩了个大坑！！</li></ul><hr><ol start="4"><li>因为我是使用typora来写本地博客的，写博客时会需要插入图片，因此配置图床还是挺有必要的，下面推荐两篇教程：</li></ol><ul><li><a href="https://zhuanlan.zhihu.com/p/365829157">Typora+PicGo+Github &#x3D; Markdown编辑器+图床</a></li><li><a href="https://www.jianshu.com/p/1059cc94d63d">picgo + gitee 配置</a></li></ul><h1 id="进阶改动"><a href="#进阶改动" class="headerlink" title="进阶改动"></a>进阶改动</h1><p>当能够正常搭建起本地博客后，可以尝试一些进阶改动，可以参考下面几篇文章：</p><ul><li><p><a href="https://github.com/qixa/hexo-theme-fluid-mod#%E8%AF%A6%E7%BB%86%E4%BF%AE%E6%94%B9%E4%BF%A1%E6%81%AF">Fluid主题进阶修改版</a></p></li><li><p><a href="https://2017zhangyuxuan.github.io/2022/02/13/2022-02/2022-02-13%20%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEHexo%E5%8D%9A%E5%AE%A2/">阿里云服务器配置Hexo博客</a></p></li><li><p><a href="https://www.julydate.com/post/60859300/#%E6%80%BB%E7%BB%93">CDN加速</a></p></li><li><p><a href="https://github.com/cjh0613/hexo-submit-urls-to-search-engine">网站SEO优化</a></p></li></ul><hr><p>最后附上我当时的心路历程：心态崩了，弄了几天也没绑定上自己的域名，然后CDN加速也需要配置自己的域名，后来想想还是算了，毕竟博客还是内容最重要，像是页面的美观或者是网站加载速度都是其次了，下次一定。（也只能这样安慰自己了，流下了无能的泪水）</p><center><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fww4.sinaimg.cn%2Fbmiddle%2F9150e4e5ly1fkonbtgn8aj20qo0qomyg.jpg&refer=http%3A%2F%2Fwww.sina.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647397220&t=7ee46f97d55b16b2e4057e967d3fc105" alt="" style="zoom:67%;" /></center><p class='note note-primary' >  <font size='4'>     最后总结来说，写博客，最重要的还是持之以恒，还是产出内容，不能本末倒置，捡了芝麻丢了西瓜。  </font></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>环境搭建系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/25/2021-09/2021-09-25%20hello-world/"/>
    <url>/2021/09/25/2021-09/2021-09-25%20hello-world/</url>
    
    <content type="html"><![CDATA[<p>最初的博客，纪念那份探索新事物的激动与喜悦，也是告诉自己不忘初心。</p><p>Hello world !</p><p>I will be the best animation lover who is able to save the world !</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
