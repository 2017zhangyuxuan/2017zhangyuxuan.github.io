<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++踩坑记录之字面值常量</title>
    <link href="/2022/03/04/2022-03/2022-03-04%20C++%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F/"/>
    <url>/2022/03/04/2022-03/2022-03-04%20C++%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p class='note note-info'>   最近在刷题的时候无意间又踩了个坑，发现自己的修行还远远不够，所以也特此记录一下。</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202203051921295.jpg" alt="" /></p><p>目标是想要拼接一个字符串常量和一个<code>char</code>型字符，类似下面这样的代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">string input=<span class="hljs-string">&quot;abc&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;&quot;</span> + input[<span class="hljs-number">0</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>那么问题来了，上面会输出什么呢？</p><h1 id="排查过程"><a class="markdownIt-Anchor" href="#排查过程"></a> 排查过程</h1><p>之前我想象中是拼接后返回是一个string对象，最后输出<code>input</code>的第一个字符，但是输出结果却让人意外，上面输出的结果不是期望值 <code>&quot;a&quot;</code>，而是一串莫名奇妙的字符，如下图。</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202203050828438.png" alt="令人不解的输出" /></p><p>这让我有些摸不着头脑，这一串是怎么来的，当前执行的程序根本没有写过这样的字符串呀？等等，这些字符看着有点眼熟，然后我尝试搜索了一下，发现这个字符串在我之前执行的另一个源文件里。</p><p>这是怎么回事呢？为什么当前运行的程序，却涉及了另一个根本就没有启动、不相关的源文件呢？</p><center><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202203051921292.jpg" alt="安详" style="zoom: 50%;" /></center><p>然后灵光一现，我仿佛想起什么，该不会是这个常量字符串根本没有调用 string 重载的加法运算符吧？</p><p>然后再IDE里测试了一下，发现果然上面的这个加法是无法跳转到string对应的重载运算符上的，但如果用string构造函数封装一下，发现就可以进行跳转了。其实编译器也提示我，这种加法操作并没有真正的把<code>input[0]</code>这个字符插入到前面的这个字符串字面量里。</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202203051707911.png" alt="编译器提示" /></p><p>然后联想一下用<code>char*</code>表示字符串的方式，以及字面值常量在内存中的存放位置，答案就浮出水面了。</p><p>我们知道字面值常量存储在内存的常量区，而平常我们使用<code>char* s = &quot;abc&quot;;</code>这样的表达方式，也说明字符串字面量其实指向的就是它在内存常量区的地址，是一个地址值（或者再极端一点，把字符串字面量当成一个<code>char*</code>指针来看）。因此<code>&quot;&quot;+input[0]</code>在执行加法运算时，这里把<code>input[0]</code>隐式转换成了int，然后进行指针的加法运算，最后计算的结果指向了常量区的某处地址，而这个地址恰好指向我上个程序执行后还保存着的字符串字面量（<em>为什么常量区还存储着之前程序的内容，我猜测可能是<strong>缓存</strong>之类的原因</em>），也就是<code>from left to right are:</code>这个字符串，所以最终输出了上述结果。</p><p>最后通过https://cppinsights.io/ 这个网站验证下猜想的结果，发现的确如此。可以看到编译过后，如果和字符串字面进行相加，实际上会对<code>input[0]</code>进行<code>static_cast&lt;int&gt;</code>的转换，而如果和string类进行相加，则会调用重载运算符方法。</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202203051725718.png" alt="cppinsights" /></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>至此，问题解决（<s>又水了一篇博客</s>）。总结一下，这次踩的坑很粗浅，大概涉及两个知识点，一个是字符串字面值指向的是常量区的一个地址，二是C++有数据隐式转换，在进行算术运算时会自动提升类型，比如<code>char</code>转为<code>int</code>。究其因为应该是自己的基础不够牢固，对字面值常量欠缺认识，也有可能是受以前Java的影响，自以为会封装成类，太过于想当然了，需要引以为戒。</p><p>最后再记录下近期自己的一些感受吧，因为在准备找实习，所以也是在看八股，刷算法题，然后今天练习的时候，又被难住了，就觉得自己真弱呀，自己这样的水平和实力能去面试吗？回头一看，发现自己相比过去好像并没有太大的进步，或者说没有可以拿得出手，值得自豪的本事。或许有自谦的成分，但我自己知道，跟顶尖的人相比，不，就跟我理想中的自己相比，还差得太远了，待办事项里、待学习的东西还有一箩筐。</p><p>但是，平凡无奇的我啊，现在有时间让你消沉吗？！我能做的，我要做的，就是咬牙坚持，继续学习！</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202203051946077.jpg" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组与二级指针</title>
    <link href="/2022/02/28/2022-02/2022-02-28%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/"/>
    <url>/2022/02/28/2022-02/2022-02-28%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>最近再刷《剑指Offer》的面试题，其中遇到有一题跟二维数组相关，所以需要这样形式的函数，<code>void func(int** matrix, int rows, int columns)</code>，那么问题来了，再调用这个函数的时候，<strong>应该传入怎样的实参呢</strong>？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 需要被调用的函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>** matrix, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> columns)</span> </span>&#123;<br>  cout &lt;&lt; matrix[rows<span class="hljs-number">-1</span>][columns<span class="hljs-number">-1</span>] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 第一种传入实参方式</span><br><span class="hljs-keyword">int</span> matrix[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-built_in">func</span>(matrix, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 第二种传入实参</span><br><span class="hljs-keyword">int</span>** matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>*[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>matrix[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>    matrix[i][j] = i*<span class="hljs-number">2</span> + j + <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br><span class="hljs-built_in">func</span>(matrix, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202203012135420.jpg" alt="" style="zoom:50%;" /></center><h1 id="踩坑过程"><a class="markdownIt-Anchor" href="#踩坑过程"></a> 踩坑过程</h1><p>其实上面的答案很简单，直接敲代码测试一下，就知道第一种传参方式编译器直接报错，提示你类型不匹配。但是我头铁啊，愣是用强制转换 <code>func((int**)matrix, 2, 2)</code>的方式，然后就是程序崩溃报错了。</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202203012139296.jpg" alt="" /></p><p>这是为什么呢？现在来理性分析一波，以下面的测试代码来进行说明。</p><p>首先<code>matrix</code> 是一个二维数组，它（数组名）对应的指针类型实际上是 <code>int(*)[2]</code> ，即指向数组的指针（有人称作是行数组指针）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="C/C++——二维数组与指针、指针数组、数组指针（行指针）、二级指针的用法 ">[1]</span></a></sup>，也就是说如果把<code>matrix</code>看成是一个指针的话，指向的类型是一个长度为2的int数组，因此在对<code>matrix</code>执行指针加法<code>（matrix+1）</code>的时候，一次移动的字节数为一个数组的长度即 2*4 = 8 字节。那么执行解引用时， <code>matrix[1]</code> 得到是第2行一维数组的首地址，其类型就是一维数组。同时一维数组名对应指针类型为<code>int *</code>，因此再对 <code>matrix[1]</code> 执行指针加法操作<code>（matrix[1] + 1）</code>时，一次移动的字节数为一个int类型的字节长度。</p><p>其次对于二级指针（指针的指针）<code>p</code> 来说，因为<code>p</code> 指向的是一个<code>int *</code>指针，所以 <code>p</code> 执行指针加法的时候，一次移动的长度为 <code>int *</code> 指针类型的字节数（即8字节），那么解引用得到数据类型也就是 <code>int *</code> ，所以<code>p[0]</code> 得到的元素就是一个<code>int *</code> 指针，打印 <code>p[0]</code> 的值就是打印该指针的值，而指针的值就是一个地址。为什么这里打印出来的值这么怪异呢？因为它把<code>matrix</code>二维矩阵存储的int值当做指针的值来进行解析了，例如3 和 5 两个int值合起来为8字节，这个8个字节被当做地址的值而不是元素int的值，再加上我的电脑是小端（即低字节在低地址），最后打印出来的 <code>p[0]</code> 就是<code>0x500000003</code> 了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> matrix[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;matrix    address: &quot;</span> &lt;&lt; matrix &lt;&lt; endl;     <span class="hljs-comment">// 0x16d92b610</span><br>cout &lt;&lt; <span class="hljs-string">&quot;matrix[0] address: &quot;</span> &lt;&lt; matrix[<span class="hljs-number">0</span>] &lt;&lt; endl;  <span class="hljs-comment">// 0x16d92b610</span><br>cout &lt;&lt; <span class="hljs-string">&quot;matrix+1  address: &quot;</span> &lt;&lt; matrix+<span class="hljs-number">1</span> &lt;&lt; endl;   <span class="hljs-comment">// 0x16d92b618</span><br>cout &lt;&lt; <span class="hljs-string">&quot;matrix[1] address: &quot;</span> &lt;&lt; matrix[<span class="hljs-number">1</span>] &lt;&lt; endl;  <span class="hljs-comment">// 0x16d92b618</span><br><br><span class="hljs-keyword">int</span>** p = (<span class="hljs-keyword">int</span>**) matrix;<br>cout &lt;&lt; <span class="hljs-string">&quot;p    address: &quot;</span> &lt;&lt; p &lt;&lt; endl;          <span class="hljs-comment">// 0x16d92b610</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p[0] address: &quot;</span> &lt;&lt; p[<span class="hljs-number">0</span>] &lt;&lt; endl;       <span class="hljs-comment">// 0x500000003</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p+1  address: &quot;</span> &lt;&lt; p+<span class="hljs-number">1</span> &lt;&lt; endl;        <span class="hljs-comment">// 0x16d92b618</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p[1] address: &quot;</span> &lt;&lt; p[<span class="hljs-number">1</span>] &lt;&lt; endl;       <span class="hljs-comment">// 0x800000007</span><br><br><span class="hljs-keyword">int</span> ** p_matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>*[<span class="hljs-number">2</span>];<br>p_matrix[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>p_matrix[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>p_matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>; p_matrix[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>;<br>p_matrix[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">7</span>; p_matrix[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">8</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;p_matrix    address: &quot;</span> &lt;&lt; p_matrix &lt;&lt; endl;    <span class="hljs-comment">// 0x60000081c020</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p_matrix[0] address: &quot;</span> &lt;&lt; p_matrix[<span class="hljs-number">0</span>] &lt;&lt; endl; <span class="hljs-comment">// 0x60000081c030</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p_matrix+1  address: &quot;</span> &lt;&lt; p_matrix+<span class="hljs-number">1</span> &lt;&lt; endl;  <span class="hljs-comment">// 0x60000081c028</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p_matrix[1] address: &quot;</span> &lt;&lt; p_matrix[<span class="hljs-number">1</span>] &lt;&lt; endl; <span class="hljs-comment">// 0x60000081c040</span><br></code></pre></td></tr></table></figure><p>啰里啰嗦说了这么多，可能还是没解释清楚，反而把自己绕晕了，所以再用下面这张图解释一下。</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202203011443395.jpeg" alt="内存图解" /></p><p>弄清楚内存中数据分布后，现在应该知道为什么不能直接把二维数组matrix直接传给二级指针了吧。不过还有一个点，可能还是比较令人感到疑惑的，就是为什么<code>matrix+1</code> 和 <code>matrix[1]</code> 打印出来的值是相同的？</p><p>我是这么理解的（<strong>如果不对，还请在评论区中指出</strong>）：因为matrix 类型时 <code>int(*)[2]</code>，是一个指向一维数组的指针，因此解引用得到的应该就是个数组，所以可以认为 <code>matrix[1]</code> 就是个一维数组，而一维数组名不就是数组首元素的地址嘛，因此我觉得编译器在对 <code>matrix+1</code>这个地址解引用取值的时候，并没有像 二级指针 <code>int** p</code> 那样去取内存里的值作为地址值，而是直接将当前的地址值作为数组名的地址值反悔了。所以最终 <code>matrix+1</code> 和 <code>matrix[1]</code> 打印得到的结果相同。</p><hr /><p>其实还遇到了另一种比较奇怪的形式，见下面的函数。我试了好几种传参方式，但总是编译通过，编译器一直提示我类型不匹配，告诉我形参<code>matrix</code>的真实类型为<code>int(*)[columns]</code>，这就和尴尬，因为<code>columns</code>是个变量，我怎么传一个数组长度为变量的数组指针？</p><p>我们都知道C++里，数组的长度是一个固定值，那么这里的<code>func2</code>为什么可以通过编译？更痛苦的是我还无法传参。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 这里 martix 类型等价为 int(*)[columns]</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> columns, <span class="hljs-keyword">int</span> matrix[rows][columns])</span> </span>&#123;<br>    cout &lt;&lt; matrix[rows<span class="hljs-number">-1</span>][columns<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>后来我在stackoverflow上提了这个问题（结果标记为 <em>模板参数自动推导</em> 的问题，但我感觉还是不太一样），有人回复我说，这种函数定义方式在C里面是有效的，但在C++里是不合法，所以这不是如何传参的问题，而是这样的写法在C++标准里是不允许的。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="stackoverflow上的提问">[2]</span></a></sup>虽然感觉还是没说明白为什么编译可行，但是姑且认为是C++标准不允许这样的写法，所以导致没法传参。</p><h1 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h1><p>最后总结一下，二维数组是不能直接赋值给二级指针的，二维数组对应的指针类型是一个数组指针，下面表格给出数组和指针的参数匹配。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="C/C++二维数组名和二级指针">[3]</span></a></sup></p><table><thead><tr><th style="text-align:left">实参</th><th>例子</th><th>所匹配的形参</th></tr></thead><tbody><tr><td style="text-align:left">二维数组</td><td>char c[4][3]</td><td>char (*c)[3]</td></tr><tr><td style="text-align:left">指针数组</td><td>char * c[4]</td><td>char ** c</td></tr><tr><td style="text-align:left">数组指针</td><td>char (*c)[3]</td><td>char (*c)[3]</td></tr><tr><td style="text-align:left">二级指针</td><td>char ** c</td><td>char ** c</td></tr></tbody></table><p>然后再给出几种正确的传递二维数组的姿势。</p><h2 id="1形参使用二级指针"><a class="markdownIt-Anchor" href="#1形参使用二级指针"></a> 1.形参使用二级指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **matrix, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> columns)</span> </span>&#123;<br>    cout &lt;&lt; matrix[rows - <span class="hljs-number">1</span>][columns - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> rows = <span class="hljs-number">2</span>, columns = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> **matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> *[rows];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        matrix[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[columns];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; columns; j++) &#123;<br>            matrix[i][j] = i * columns + j + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">func</span>(matrix,rows, columns);<br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;rows;i++) &#123;<br>        <span class="hljs-keyword">delete</span>[] matrix[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] matrix;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2形参使用一级指针"><a class="markdownIt-Anchor" href="#2形参使用一级指针"></a> 2.形参使用一级指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *matrix, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> columns)</span> </span>&#123;<br>    cout &lt;&lt; matrix[(rows - <span class="hljs-number">1</span>) * columns + (columns - <span class="hljs-number">1</span>)];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rows = <span class="hljs-number">2</span>, columns = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> *matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows * columns];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; columns; j++) &#123;<br>            matrix[i * columns + j] = i * columns + j + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">func</span>(matrix, rows, columns);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3形参使用数组指针"><a class="markdownIt-Anchor" href="#3形参使用数组指针"></a> 3.形参使用数组指针</h2><p>采用这种方式，需要形参指定二维数组的列数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// columns = 2</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*matrix)[<span class="hljs-number">2</span>], <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> columns)</span> </span>&#123;<br>    cout &lt;&lt; matrix[rows<span class="hljs-number">-1</span>][columns<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rows = <span class="hljs-number">2</span>, columns = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> matrix[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-built_in">func</span>(matrix, rows, columns);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4形参使用指针数组"><a class="markdownIt-Anchor" href="#4形参使用指针数组"></a> 4.形参使用指针数组</h2><p>采用这种方式，需要形参指定二维数组的行数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// rows = 3</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* matrix[<span class="hljs-number">3</span>], <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> columns)</span> </span>&#123;<br>    cout &lt;&lt; matrix[rows - <span class="hljs-number">1</span>][columns - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rows = <span class="hljs-number">3</span>, columns = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> *matrix[rows];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        matrix[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[columns];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; columns; j++) &#123;<br>            matrix[i][j] = i * columns + j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">func</span>(matrix, rows, columns);<br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        <span class="hljs-keyword">delete</span>[] matrix[i];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="5形参使用-vector-容器"><a class="markdownIt-Anchor" href="#5形参使用-vector-容器"></a> 5.形参使用 vector 容器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> columns)</span> </span>&#123;<br>    cout &lt;&lt; matrix[rows - <span class="hljs-number">1</span>][columns - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rows = <span class="hljs-number">3</span>, columns = <span class="hljs-number">2</span>;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">matrix</span>(rows);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;columns;j++) &#123;<br>            matrix[i].<span class="hljs-built_in">push_back</span>(i * columns + j + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">func</span>(matrix, rows, columns);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202203012140651.jpeg" alt="" /></p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/oddcat/p/9701518.html">C/C++——二维数组与指针、指针数组、数组指针（行指针）、二级指针的用法 </a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://stackoverflow.com/questions/71303527/how-to-pass-parameters-to-this-function-void-funcint-rows-int-columns-int-m">stackoverflow上的提问</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.cnblogs.com/fuao2000/p/11005671.html">C/C++二维数组名和二级指针</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多即是少，少即是多</title>
    <link href="/2022/02/21/2022-02/2022-02-21%20%E5%A4%9A%E5%8D%B3%E6%98%AF%E5%B0%91%EF%BC%8C%E5%B0%91%E5%8D%B3%E6%98%AF%E5%A4%9A/"/>
    <url>/2022/02/21/2022-02/2022-02-21%20%E5%A4%9A%E5%8D%B3%E6%98%AF%E5%B0%91%EF%BC%8C%E5%B0%91%E5%8D%B3%E6%98%AF%E5%A4%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>这几天一直在折腾obsidian这款笔记软件，看相关视频，学习有关用法，广阔的主题和不计其数的插件令我烟花缭乱，完全被绚丽的界面配置所吸引。</p><p>但是等我冷静下来之后，扪心自问，自己真的需要这么深入学习使用obsidian吗？我决定接触使用obsidian的初心是什么？我的真实需求到底是什么？这样理清自己的思路后，或许就会豁然开朗了。</p><h1 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h1><p>其实我的需求很简单，就是想要找一个地方可以记录我的财务状况。此前我的主要笔记软件用的是飞书，但因为飞书需要联网，且数据存储在别人的服务器上，所以一些个人私密数据就不好写在上面，所以就需要一款本地的文本编辑软件。</p><p>然后就通过公众号等渠道，就了解到了obsidian这款笔记软件，相比 typora 来说具有更多的插件和更高的自由度。而此前我写博客用的就是 typora 来编辑撰写，所以就想着能不能改成用 obsidian，这样可以尝试去学习使用炫酷的插件了（还是追求花里胡哨的心理啊），甚至之后可以取代飞书。</p><p>但是现在我发现，其实当下尝试去深度学习使用obsidian并没有太大必要：一来我最初的需求很简单，只是想在本地记录点财务信息；二来如果使用obsidian取代typora来写博客，其实我还是没法用上obsidian里最关键的双链功能，因为博客渲染的时候无法支持；三来如果用obsidian取代飞书做笔记，成本比较高，想要把obsidian打造成现在飞书这样子需要花费的精力和时间可太大了。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>综上所述，其实我大可不必去深入学习obsidian，去学各种插件，打造一个完美的写作系统，毕竟已经有一个比较完备的软件在使用了，也没有特别的需求，有这个时间精力还不如去做当下优先级更高的事情，学习更多实际性的知识内容。</p><p>这件事让我联想到今天老师课上讲的话，“<strong>多即是少，少即是多</strong>”。在当下信息爆炸的时代，我们会接触到很多纷繁复杂的事物，我们或许会被表象所迷惑，而忘记自己真实的需求。当太多的选择摆在面前，反而无法决定，认为还是太少，还想追求更多更好。但其实只要掌握关键的几个技术、软件，就足以解决大多数问题和需求。</p><p>最关键的还是要明确自己的需求和想法，然后以此为出发点寻找合适的解决方法。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【漂流少年】青春的意义在于成长</title>
    <link href="/2022/02/19/2022-02/2022-02-19%20%E3%80%90%E6%BC%82%E6%B5%81%E5%B0%91%E5%B9%B4%E3%80%91%E9%9D%92%E6%98%A5%E7%9A%84%E6%84%8F%E4%B9%89%E5%9C%A8%E4%BA%8E%E6%88%90%E9%95%BF/"/>
    <url>/2022/02/19/2022-02/2022-02-19%20%E3%80%90%E6%BC%82%E6%B5%81%E5%B0%91%E5%B9%B4%E3%80%91%E9%9D%92%E6%98%A5%E7%9A%84%E6%84%8F%E4%B9%89%E5%9C%A8%E4%BA%8E%E6%88%90%E9%95%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>之前就听闻《漂流少年》这部番评价很高，就一直想找机会补了，恰好这段寒假时间里有空，就一次性刷完了。当时看完的确是心田里涌出了些什么，但可惜的是没有及时记录下来，现在回过头来，想要说些什么，却又无从说起了。</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202201047171.png" alt="" /></p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202201048916.png" alt="" /></p><h1 id="感悟"><a class="markdownIt-Anchor" href="#感悟"></a> 感悟</h1><p>《漂流少年》讲述了一个班级的中学生突然来到了奇妙的异次元世界，每个人获得了不同的超能力，为了回到现实世界，学生们做了各种尝试和努力，期间也发生了很多事件，最终只有主角长良和瑞穗回到了现实世界。</p><p>《漂流少年》是一部群像番，将班级里每个学生的个性刻画得很鲜明，很有特点，当卷入奇怪的事件中，漂流到异世界，每个人都有着各自的态度和表现。而历经众多事件后，每个人也都走上了不同的道路。</p><p>其中令我印象最深的就是主角的成长变化了（当然还有元气少女希和傲娇的瑞穗，笑），主角长良从一开始的消极避世，认为自己不重要，什么都不想做，到最后变得坚定不移，竭尽全力回到现实，这一成长过程令人侧目。或许是从长良身上看到了自己，那个妄自菲薄，胆小懦弱的自己，所以为长良的成长变化而喜悦动容，因为在我心底的某处，也一直希望自己能够做出改变，改正恶习，一扫颓废怠惰之风，变得坚定自信，勇往直前。</p><p>番剧里还讲述了很多故事，我认为很像是青春成长路上遇到的种种，有挫折有磨难，有黑暗有死亡，但也有恋情友情，有勇气有坚韧，有自信元气、傲娇善良的少女，有不断成长、自我救赎的少年，这一切共同交织的事物，组成了我们的青春。</p><p>最后故事的结尾，长良和瑞穗回到了希还活着的现实世界（但已经不是原来的世界了），一切都归于平淡，仿佛之前的那场漂流之旅未曾发生过，长良也回到了平静的生活之中。没有想象中的终成眷属，没有想象中的轰轰烈烈，但的确有什么发生了变化，长良成长了，不再是消极生活，而是能够抬起胸膛自信地走下去。作为观众的我来说，故事的结局并没有事事如愿，但这就是生活不是吗？</p><p>这是一场名为”成长“的青春漂流之旅。</p><h1 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h1><p>于我而言， 我不知道自己的青春何时开始，更无从谈起何时结束，我想自身或许还没经历过成长的阵痛，我还是带有孩子般的天真和稚气，不具有我这个年龄应有的成熟和坚毅。我想，我是渴望成长的，也希望自己变得负责任有担当，但总是缺乏实际行动。或许改变是有的，但还是太小，还是太慢，还是不满足。嘛，或许也不能操之过急。</p><p>你可以很菜，但你不能一直菜。</p><p>你可以天真，但你不能一直天真。</p><p>你可以逃避，但你不能一直逃避。</p><p class='note note-primary'>  <font size='4'>人生就是永无止境的徒劳，但正是因为一切皆无意义，所以「活着」的这个瞬间，这个光芒才会无比珍贵，因为那个瞬间是只属于那个人自己的。</font></p><center><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202201025436.png" alt="" style="zoom: 50%;" /></center>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
      <category>动漫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漂流少年</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB调试学习</title>
    <link href="/2022/02/16/2022-02/2022-02-16%20GDB%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/02/16/2022-02/2022-02-16%20GDB%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><p>GDB是一个由GNU开源组织发布的、UNIX / LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c/c++程序员，gdb是必不可少的工具。标准的 GDB 是纯命令行式的，但也有一些基于它的图形化工具（比如 DDD、Data Display Debugger），但用好 GDB 命令行调试，还是我们的一项基本素质。</p><p>**GDB 不仅是一个调试工具，它也是一个学习源码的好工具。**单纯的源码是静态的，虽然你可以分析它的整体架构，在头脑里模拟出它的工作流程，但计算机实在是太复杂了，内外部环境因素很多，仅靠“人肉分析”很难完全理解它的逻辑。这个时候，GDB 就派上用场了，以调试模式启动，任意设定外部条件，从指定的入口运行，把程序放慢几万倍，细致地观察每个变量的值，跟踪代码的分支和数据的流向，这样走上几个来回之后，再结合源码，就能够对程序的整体情况“了然于胸”。</p><p>本篇文章将简单地介绍 GDB 常见用法，更多内容可以参考下面的文章：</p><ul><li><a href="https://blog.csdn.net/niyaozuozuihao/article/details/91802994">linux下gdb调试方法与技巧整理</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="linux下gdb调试方法与技巧整理">[1]</span></a></sup></li><li><a href="https://github.com/hellogcc/100-gdb-tips">《100个gdb小技巧》</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="《100个gdb小技巧》">[2]</span></a></sup> (强烈推荐)</li></ul><h1 id="gdb使用流程"><a class="markdownIt-Anchor" href="#gdb使用流程"></a> GDB使用流程</h1><h2 id="1启动gdb调试"><a class="markdownIt-Anchor" href="#1启动gdb调试"></a> 1.启动GDB调试</h2><p>测试程序源代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x_2 = <span class="hljs-built_in">square</span>(x);<br>    <span class="hljs-keyword">return</span>  x_2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-built_in">get_num</span>(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>启动命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc test.cpp -o test # 编译源文件<br>gdb test<br>gdb -q test # -q 表示不打印gdb版本信息，界面较为干净；<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202160948610.png" alt="启动gdb" /></p><h2 id="2查看源码"><a class="markdownIt-Anchor" href="#2查看源码"></a> 2.查看源码</h2><p><strong>list(简写 l)</strong>： 查看源程序代码，默认显示10行，按回车键或继续输入<code>l</code>查看下10行。</p><p>效果如下所示：</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202160951660.png" alt="list 查看源程序代码" /></p><h2 id="3运行程序"><a class="markdownIt-Anchor" href="#3运行程序"></a> 3.运行程序</h2><p><strong>run(简写 r)</strong> ：运行程序直到遇到 结束或者遇到断点等待下一个命令；<br />效果如下所示（这里我没有设置断点，所以程序直接运行到结束）：</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202160953401.png" alt="run 运行程序" /></p><h2 id="4设置断点"><a class="markdownIt-Anchor" href="#4设置断点"></a> 4.设置断点</h2><p><strong>break(简写 b)</strong> ：命令格式 <code>b 行号</code>，在某行设置断点；<br /><strong>info breakpoints</strong> (简写 <code>i b</code>) ：显示断点信息</p><ul><li>Num： 断点编号</li><li>Type：类型，breakpoint 或者 watchpoint</li><li>Disp：断点执行一次之后是否有效 kep：有效 dis：无效</li><li>Enb： 当前断点是否有效 y：有效 n：无效</li><li>Address：内存地址</li><li>What：位置</li></ul><p>演示效果如下：</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202160957555.png" alt="b 设置断点" /></p><h2 id="5单步执行"><a class="markdownIt-Anchor" href="#5单步执行"></a> 5.单步执行</h2><p>首先需要输入<code>run</code>启动程序，运行到第一个断点处，然后可以选择<code>step</code>单步调试（如果有函数调用则进入函数），<code>next</code>单步跟踪程序（遇到函数调用，直接调用函数，不会进入函数体内），<code>continue</code>继续运行到下一个断点处。</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202161026973.png" alt="执行程序" /></p><hr /><p>程序运行的相关命令如下：</p><ul><li><strong>run</strong>：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li><li><strong>continue</strong> （简写c ）：继续执行，到下一个断点处（或运行结束）</li><li><strong>next</strong>：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li><li><strong>step</strong> （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li><li><strong>until</strong>：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li><li><strong>until+行号</strong>： 运行至某行，不仅仅用来跳出循环</li><li><strong>finish</strong>： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li><li><strong>call 函数(参数)</strong>：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li></ul><h2 id="6查看变量"><a class="markdownIt-Anchor" href="#6查看变量"></a> 6.查看变量</h2><ul><li>print ：打印变量或表达式的值</li><li>whatis ：查询变量或函数</li><li>pt ：跟whatis作用类似</li></ul><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202161039792.png" alt="查看变量" /></p><h2 id="7退出gdb"><a class="markdownIt-Anchor" href="#7退出gdb"></a> 7.退出GDB</h2><p>使用<code>quit</code>命令退出即可。</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202161041935.png" alt="退出gdb" /></p><h1 id="gdb常用命令"><a class="markdownIt-Anchor" href="#gdb常用命令"></a> GDB常用命令</h1><p>下面列出最常用的GDB命令：</p><ul><li><p>pt：查看变量的真实类型，不受 typedef 的影响。</p></li><li><p>bt：显示当前调用堆栈。</p></li><li><p>up/down：在函数调用栈里上下移动。或者使用<code>frame 函数帧号</code>跳转。</p></li><li><p>fin：直接运行到函数结束。</p></li><li><p>i b：查看所有的断点信息。</p></li><li><p>i locals：查看当前堆栈页的所有变量。</p></li><li><p>wh：启动“可视化调试”。这个是我最喜欢的命令，可以把屏幕分成上下两个窗口，上面显示源码，下面是 GDB 命令输出，不必再用“l”频繁地列出源码了，能够大大提高调试的效率。</p><ul><li>ctrl x + a ：退出或进入可视化模式</li></ul></li></ul><h1 id="分析coredump"><a class="markdownIt-Anchor" href="#分析coredump"></a> 分析CoreDump</h1><p>在真实生产环境中，程序可能会崩溃而产生CoreDump文件，此时我们通常就需要用gdb来调试CoreDump文件，分析程序崩溃的原因。</p><p>接下来，来模拟这一过程。首先需要修改下源代码，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x_2 = <span class="hljs-built_in">square</span>(x);<br>    <span class="hljs-keyword">return</span>  x_2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-built_in">get_num</span>(a);<br>    <span class="hljs-keyword">int</span>* p = <span class="hljs-literal">NULL</span>;<br>    *p = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后编译生成新的二进制文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -g test.cpp -o test6<br></code></pre></td></tr></table></figure><p>然后需要修改下配置<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="让程序崩溃后生成Core Dump">[3]</span></a></sup>，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 作用是让程序崩溃是产生的core dump文件大小没有限制，默认是0表示不生成core dump文件</span><br>ulimit -c unlimited<br></code></pre></td></tr></table></figure><p>然后执行修改后的程序，发生段错误：</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202161515053.png" alt="程序崩溃发生段错误" /></p><p>但奇怪的是，并没有生成core文件，明明我已经修改了ulimit。后来几经波折，发现了原因，参考<a href="https://baijiahao.baidu.com/s?id=1599347824327158577&amp;wfr=spider&amp;for=pc">在Linux上利用core dump和GDB调试segfault</a><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="在Linux上利用core dump和GDB调试segfault">[4]</span></a></sup>。简单来说，就是Ubuntu默认忽略非Ubuntu软件包的二进制文件的崩溃日志，也就不会产生core dump文件。调整的做法也比较简单，就是重新设置kernel.core_pattern的值（该值表示core dump文件的输出目录），执行下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sysctl -w kernel.core_pattern=/tmp/core/core-%e.%p.%h.%t<br></code></pre></td></tr></table></figure><p>现在再执行之前的程序，就可以在对应目录下生成core dump文件，并可以用gdb来进行调试分析，如下图所示，可以看到出错原因在源代码的第15行，对一个空指针赋值：</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202161511784.png" alt="调试core文件" /></p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/niyaozuozuihao/article/details/91802994">linux下gdb调试方法与技巧整理</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://github.com/hellogcc/100-gdb-tips">《100个gdb小技巧》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.cnblogs.com/chingliu/archive/2011/07/25/2223815.html">让程序崩溃后生成Core Dump</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://baijiahao.baidu.com/s?id=1599347824327158577&amp;wfr=spider&amp;for=pc">在Linux上利用core dump和GDB调试segfault</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【骚操作】MacOS上自动压缩截图</title>
    <link href="/2022/02/15/2022-02/2022-02-15%20%E3%80%90%E9%AA%9A%E6%93%8D%E4%BD%9C%E3%80%91MacOS%E4%B8%8A%E8%87%AA%E5%8A%A8%E5%8E%8B%E7%BC%A9%E6%88%AA%E5%9B%BE/"/>
    <url>/2022/02/15/2022-02/2022-02-15%20%E3%80%90%E9%AA%9A%E6%93%8D%E4%BD%9C%E3%80%91MacOS%E4%B8%8A%E8%87%AA%E5%8A%A8%E5%8E%8B%E7%BC%A9%E6%88%AA%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>之前写博客一直是用 picgo + github 作为 typora的图床，但是有时候网不太行，图片显示得很慢。所以后来换了 gitee 作为图床，但是发现仍然有时候图片无法显示，但是通过浏览器的URL访问没有问题，这就让我很疑惑，后来查阅资料发现，gitee 居然不支持 1M 以上图片的查看<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="记一次css文件引起的跨域问题（gitee图片超过1M需要登录查看) ↩">[1]</span></a></sup>，这可太坑了。</p><center><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202152050052.jpeg" alt="惊了" style="zoom: 25%;" /></center><p>然后我就想着能不能做到自动压缩截图大小，来实现曲线救国，通过查阅网上资料，还真让我找到了方法。</p><h1 id="自动压缩截图"><a class="markdownIt-Anchor" href="#自动压缩截图"></a> 自动压缩截图</h1><p>实现方法参考这篇文章：<a href="https://depp.wang/2020/08/07/how-to-automatically-compress-screenshot-size-in-macos/">在 macOS 中，如何自动压缩截屏图片大小</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="在 macOS 中，如何自动压缩截屏图片大小">[2]</span></a></sup>，里面写得很详细了，我这里就简单地描述下实现原理，并演示实际效果。</p><h2 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h2><p>我们都知道有一些办法能够调整图片大小，比如利用MacOS上的预览，对图片进行导出，就可以实现压缩图片大小。还可以通过其他软件，或者命令行工具（例如pngquant，ImageMagick）来压缩图片。但是上面如果手动操作就有点繁琐了， 所以关键在于如何实现“<strong>自动</strong>”的效果。</p><p>提到“自动”，那么自然就需要自动的工作流软件了，也就是 Hazel 或者  Automator，利用工作流软件，来自动地对截图进行压缩。完整流程如下：</p><ol><li>将截图保存到一个目录中；</li><li>利用 Hazel 或者 Automator 工作流软件，自动触发脚本；</li><li>在脚本中，使用命令行工具对截图进行压缩并保存；</li><li>将压缩后的图片复制到剪贴板（也是利用脚本完成）；</li><li>屏幕通知图片压缩完成；</li><li>（可选）将压缩后的图片删除。</li></ol><h2 id="实际演示"><a class="markdownIt-Anchor" href="#实际演示"></a> 实际演示</h2><p>接下来我将演示如何配置 Hazel ，Automator 可以参考上面博文的内容。</p><ol><li>首先选择一个文件夹，作为存放截图的目录。</li></ol><center><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202152110926.png" alt="选择截图目录" style="zoom: 50%;" /></center>2. 然后添加规则<center><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202152112016.png" alt="添加规则" style="zoom:50%;" /></center>3. 配置规则，如下图所示<p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202152113647.png" alt="配置规则" /></p><ol start="4"><li>具体脚本内容如下所示：</li></ol><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202152115294.png" alt="压缩图片并复制到剪贴板" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pngquant 128 --skip-if-larger --strip --ext=.png --force &quot;$1&quot;<br>osascript -e &quot;set the clipboard to (read (POSIX file \&quot;$(perl -e &quot;print glob(&#x27;$1&#x27;)&quot;)\&quot;) as &#123;«class PNGf»&#125;)&quot;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202152116588.png" alt="屏幕提示" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">The compressed image `file` has been copied to the clipboard.<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202152116561.png" alt="删除截图" /></p><p>最后删除截图是可选的，因为在typora里图片复制后自动上传，所以我就设置了删除截图。</p><hr /><p>至此就实现了自动压缩截图的效果，只要每次截图的时候保存到设置的目录，就会自动压缩图片，并复制到剪贴板，等屏幕提示“压缩已完成”后，我直接在 typora 里粘贴图片即可，又可以愉快地写博客喽~</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202152126405.jpeg" alt="" /></p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/xsyz/p/14043564.html">记一次css文件引起的跨域问题（gitee图片超过1M需要登录查看)</a> ↩<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://depp.wang/2020/08/07/how-to-automatically-compress-screenshot-size-in-macos/">在 macOS 中，如何自动压缩截屏图片大小</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>骚操作系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【99%环境搭建系列】阿里云服务器配置Hexo博客</title>
    <link href="/2022/02/13/2022-02/2022-02-13%20%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEHexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/02/13/2022-02/2022-02-13%20%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEHexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>这个环境搭建系列好久没更了，所以趁此机会难得填坑一下。</p><p>之前一直白嫖是Github pages来部署自己的博客，然后觉得还是有一个自己的服务器更好一点，还能学习相关知识。所以趁还没回学校，把自己的博客部署到自己的服务器上，毕竟之前购买的域名一直没用上，甚是心痛啊。</p><p>这次我是在阿里云上买的服务器，主要是因为之前在阿里云上买的域名，所以这次搭建的过程就用阿里云进行说明。</p><h1 id="新建用户"><a class="markdownIt-Anchor" href="#新建用户"></a> 新建用户</h1><p>这里以阿里云的服务器来举例。</p><p>通常创建好服务器实例后，在重置一下实例的密码，就可以用root用户进行ssh连接了。使用root用户登录后，我这里是新建了一个用户，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 新建用户</span><br>adduser zyx<br><span class="hljs-meta">#</span><span class="bash"> 设置密码</span><br>passwd zyx<br></code></pre></td></tr></table></figure><p>然后赋予<code>zyx</code>用户root权限，具体做法是编辑<code>/etc/sudoers</code>，在root用户下方添加新增的用户名，如下所示。</p><center><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202131602517.png" alt="image-20220213160236426" style="zoom: 67%;" /></center><h1 id="ssh免密登录"><a class="markdownIt-Anchor" href="#ssh免密登录"></a> ssh免密登录</h1><p>在本地创建密钥，使用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>然后一直回车，创建一个密钥。因为我是mac系统，生成的密钥文件位置在<code>~/.ssh/id_rsa.pub</code></p><p>然后回到服务器端，创建<code>.ssh</code>目录（在当前用户的~ 目录下即可），并编辑文件<code>.ssh/authorized_keys</code>，复制粘贴刚刚在本地创建好的密钥。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim .ssh/authorized_keys<br></code></pre></td></tr></table></figure><h1 id="配置环境"><a class="markdownIt-Anchor" href="#配置环境"></a> 配置环境</h1><p>首先需要安装配置一下开发相关的软件环境了，使用的命令如下<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="hexo本地博客部署到云服务器">[1]</span></a></sup>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 更新下载源</span><br>sudo apt-get update<br><span class="hljs-meta">#</span><span class="bash"> 安装 git</span><br>sudo apt install git<br><span class="hljs-meta">#</span><span class="bash"> 安装 vim</span><br>sudo apt install vim<br><span class="hljs-meta">#</span><span class="bash"> 安装 node.js</span><br>sudo apt install nodejs<br><span class="hljs-meta">#</span><span class="bash"> 安装 nginx</span><br>sudo apt install nginx<br></code></pre></td></tr></table></figure><p>然后再创建网站目录和远程仓库目录，使用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建网站目录，以这个目录作为博客静态文件的存放目录，之后再nginx配置文件里会用到</span><br>mkdir /home/zyx/hexo<br><span class="hljs-meta">#</span><span class="bash"> 创建服务器上的远程仓库目录</span><br>git init --bare blog.git<br><span class="hljs-meta">#</span><span class="bash"> 新建钩子文件</span><br>vim /home/zyx/blog.git/hooks/post-receive<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> ---------</span><br><span class="hljs-meta">#</span><span class="bash"> 把如下内容粘贴进去</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>git --work-tree=/home/zyx/hexo --git-dir=/home/zyx/blog.git checkout -f<br></code></pre></td></tr></table></figure><blockquote><p>注意上面创建远程仓库的命令，这里加了<code>--bare</code>参数，表示创建的是一个裸仓库，含义是这个仓库只保存git历史提交的版本信息，而不允许用户在上面进行各种git操作。</p></blockquote><h1 id="开放端口"><a class="markdownIt-Anchor" href="#开放端口"></a> 开放端口</h1><p>在安装完nginx并启动服务后，在浏览器中直接访问服务器的公网ip是可以看到nginx的欢迎页的。但是在实际操作中却发现，无法访问。后来发现是没有开放端口，所以我们需要在ECS云服务器的控制台中，在”<strong>网络与安全</strong>“中的”<strong>安全组</strong>“中，选择对应的安全组，选择”<strong>配置规则</strong>“，开放80（http）和443（https）端口。最终效果如下所示，此时再访问公网ip，就可以看到nginx的欢迎页的。</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202131917400.png" alt="域名解析添加记录" /></p><h1 id="ssl证书"><a class="markdownIt-Anchor" href="#ssl证书"></a> SSL证书</h1><p>在阿里云中，搜索”SSL证书“产品，选购免费的“DV单域名证书”，然后在控制台里创建证书，填上自己购买的域名和相关信息即可。签发成功后，就可以下载证书。</p><p>因为之后使用nginx进行配置，所以我这里下载的也就是nginx对应的证书。下载后会得到一个zip压缩包，解压后得到 <em>.key</em> 和 <em>.pem</em> 结尾的两个文件。</p><p>在nginx的安装目录（就是nginx.conf所在的目录，不知道的话可以通过<code>nginx -t</code>来查看配置文件所在目录）下，新建一个 <em>cert</em> 目录，将下载的两个证书文件放到 <em>cert</em> 目录下。</p><p>然后修改 <strong>nginx.conf</strong> 配置文件，添加如下配置<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="在Nginx（或Tengine）服务器上安装证书">[2]</span></a></sup>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">server</span> &#123;<br>    <span class="hljs-string">listen</span> <span class="hljs-number">80</span><span class="hljs-string">;</span><br>    <span class="hljs-string">server_name</span> <span class="hljs-string">yourdomain.com;</span> <span class="hljs-comment">#需要将yourdomain.com替换成证书绑定的域名，或者是域名的用为IP</span><br>    <span class="hljs-string">rewrite</span> <span class="hljs-string">^(.*)$</span> <span class="hljs-string">https://$host$1;</span> <span class="hljs-comment">#将所有HTTP请求通过rewrite指令重定向到HTTPS。</span><br>    <span class="hljs-string">location</span> <span class="hljs-string">/</span> &#123;<br>        <span class="hljs-string">index</span> <span class="hljs-string">index.html</span> <span class="hljs-string">index.htm;</span><br>    &#125;<br>&#125;<br><span class="hljs-string">server</span> &#123;<br>    <span class="hljs-comment">#如果您使用Nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。</span><br>    <span class="hljs-string">listen</span> <span class="hljs-number">443</span> <span class="hljs-string">ssl;</span><br>    <span class="hljs-string">server_name</span> <span class="hljs-string">yourdomain.com;</span> <span class="hljs-comment">#需要将yourdomain.com替换成证书绑定的域名。</span><br>    <span class="hljs-string">root</span> <span class="hljs-string">html;</span><br>    <span class="hljs-string">index</span> <span class="hljs-string">index.html</span> <span class="hljs-string">index.htm;</span><br>    <span class="hljs-string">ssl_certificate</span> <span class="hljs-string">cert/cert-file-name.pem;</span>   <span class="hljs-comment">#需要将cert-file-name.pem替换成已上传的证书文件的名称。</span><br>    <span class="hljs-string">ssl_certificate_key</span> <span class="hljs-string">cert/cert-file-name.key;</span>   <span class="hljs-comment">#需要将cert-file-name.key替换已上传的证书私钥文件的名称。</span><br>    <span class="hljs-string">ssl_session_timeout</span> <span class="hljs-string">5m;</span><br>    <span class="hljs-string">ssl_ciphers</span> <span class="hljs-string">ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br>    <span class="hljs-string">ssl_protocols</span> <span class="hljs-string">TLSv1.1</span> <span class="hljs-string">TLSv1.2</span> <span class="hljs-string">TLSv1.3;</span><br>    <span class="hljs-string">ssl_prefer_server_ciphers</span> <span class="hljs-string">on;</span><br>    <span class="hljs-string">location</span> <span class="hljs-string">/</span> &#123;<br>        <span class="hljs-string">index</span> <span class="hljs-string">index.html</span> <span class="hljs-string">index.htm;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="网站备案"><a class="markdownIt-Anchor" href="#网站备案"></a> 网站备案</h1><h2 id="icp备案"><a class="markdownIt-Anchor" href="#icp备案"></a> ICP备案</h2><p>在右上角控制台旁边，有个“ICP备案”按钮，点击这里进行网站的ICP备案，按照相关流程操作即可<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="阿里云-ICP备案指导">[3]</span></a></sup>。备案时间最好在工作日，大概需要一天时间。还有一个注意点是，备案用的服务器拥有时长必须<strong>满3个月</strong>以上，否则是无法用于网站备案的，也就是说免费申请的服务器是不能拿来做备案的。（白嫖党落泪QAQ）</p><p>只有域名ICP备案之后，才能通过域名访问网站，否则只能通过公网ip进行访问。<strong>还要记得在域名解析的控制台里，给自己购买的域名添加记录。</strong></p><p class='note note-info'>注意这里不用通过搜索“网站备案”来找，会把你导向眼花缭乱的云市场，属实没有必要。并且备案成功之后，注意要在自己的网站页面上增加备案的脚注。</p><h2 id="公安联网备案"><a class="markdownIt-Anchor" href="#公安联网备案"></a> 公安联网备案</h2><p>除了工信部的ICP备案，还需要进行<a href="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202211449323.png">公安联网备案</a>，同样按照阿里云的指导文档进行操作即可<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="阿里云-公安联网备案">[4]</span></a></sup>。注意在选择服务类型时，不要选择”博客网站“，选择”www服务“即可，不然可能又需要等待下次审核审核。</p><p>再补充一下，还需要上传安全评估报告，也就是下图的左侧登录入口。其中填报安全评估报告的内容可以参考<a href="https://wenku.baidu.com/view/17e55c62951ea76e58fafab069dc5022aaea46e6.html">安全网络报告中的问题及参考解答</a>。</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202211451504.png" alt="全国互联网安全管理服平台" /></p><p class='note note-info'>  注意一下，公安联网备案是需要本人现场到本地的网警部门审核签字的，所以最好在当地留出充裕的时间。我的一个惨痛教训就是临近开学的时候申请，结果人去学校了，所以就不能在本地这边办理了。<br>  幸运的是北京这边似乎网上办理就可以了。也就是ICP备案和公安联网备案可以是不同省份，但各个地方会有自己的要求。</p><h1 id="hexo站点配置修改"><a class="markdownIt-Anchor" href="#hexo站点配置修改"></a> Hexo站点配置修改</h1><p>最后修改本地hexo博客所在目录下的站点配置文件，也就是**_config.yml**，填入之前在服务器上创建的git仓库地址。最终执行<code>hexo clean &amp; hexo g &amp; hexo d</code>命令，就可以将静态文件代码部署到服务器上了，就可以通过域名或者ip进行访问，看到部署好的博客页面。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> [<span class="hljs-string">username</span>]<span class="hljs-string">@100.0.0.100:/home/git/blog.git</span>   <span class="hljs-comment">#用户名@服务器Ip:git仓库位置</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br><br></code></pre></td></tr></table></figure><h1 id="附录nginx常用命令"><a class="markdownIt-Anchor" href="#附录nginx常用命令"></a> 附录：Nginx常用命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 停止开机自启动</span><br>systemctl disable nginx.service<br><span class="hljs-meta">#</span><span class="bash">设置nginx服务开机自启动</span><br>systemctl enable nginx.service<br><span class="hljs-meta">#</span><span class="bash">启动nginx服务</span><br>systemctl start nginx.service<br><span class="hljs-meta">#</span><span class="bash">停止nginx服务</span><br>systemctl stop nginx.service<br><span class="hljs-meta">#</span><span class="bash">重启nginx服务</span><br>systemctl restart nginx.service<br><span class="hljs-meta">#</span><span class="bash">重新读取nginx配置(这个最常用, 不用停止nginx服务就能使修改的配置生效)</span><br>systemctl reload nginx.service<br><span class="hljs-meta">#</span><span class="bash"> 查看服务当前状态</span><br>systemctl status nginx.service<br><span class="hljs-meta">#</span><span class="bash"> 查看所有已启动的服务</span><br>systemctl list-units --type=service<br></code></pre></td></tr></table></figure><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.yyyzyyyz.cn/posts/45dafe31d273/">hexo本地博客部署到云服务器</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://help.aliyun.com/document_detail/98728.html?spm=5176.b657008.help.dexternal.7891799dpSS9Ed">在Nginx（或Tengine）服务器上安装证书</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://help.aliyun.com/document_detail/36921.html0">阿里云-ICP备案指导</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://help.aliyun.com/document_detail/116029.html">阿里云-公安联网备案</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>环境搭建系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
      <tag>阿里云ECS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我还是什么都没有改变</title>
    <link href="/2022/02/12/2022-02/2022-02-12%20%E6%88%91%E8%BF%98%E6%98%AF%E4%BB%80%E4%B9%88%E9%83%BD%E6%B2%A1%E6%9C%89%E6%94%B9%E5%8F%98/"/>
    <url>/2022/02/12/2022-02/2022-02-12%20%E6%88%91%E8%BF%98%E6%98%AF%E4%BB%80%E4%B9%88%E9%83%BD%E6%B2%A1%E6%9C%89%E6%94%B9%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<p>又几乎颓废了一周，每天都在游戏中花费了大量时光，抛弃了目标，抛弃了理想，抛弃了所有，就像是溺水的人拼命地想要抓住什么，我也把游戏当作唯一的宣泄口。明明知道自己这样下去不行，明明罪恶感和内疚感不断朝我袭来，我却无法控制自己，每次告诉自己收手吧，却又径自坠入深渊。</p><p class='note note-danger'>  “你小子，真的是，真的是一点都没有改变啊！还是，什么都做不到啊！什么都...做不到”</p><p>是啊，从初中开始的每个假期，就从来没有按自己最初计划的那样度过，每次都是沉迷在游戏世界了，忘记时间，忘记自我，忘记身边的一切，自甘堕落，伤害自己，伤害身边的亲人，然后又每次在假期结束的时候，感到无尽的懊恼与悔恨，却又总是安慰自己，“没事的，大不了重新开始就好”，以此作为借口，给自己一个台阶下。可事实究竟如何呢？时光从来不能倒流，唯有时间，失去了就真正的失去了，这段失去的时光永远不会重来，而这段时光的价值我又得到了多少呢，我又能弥补多少呢？</p><p class='note note-danger'>  “我逐渐变成自己最厌恶的样子。”</p><p>或许一些东西，更直白地说，人的习性，根深蒂固的恶习，真的很难改正。但是就这样放弃了吗，因为失败太多次就放弃改变了吗？我，真的是这样软弱无能的人吗？</p><p>答案其实已经很明显了吧，我那燃烧的灵魂告诉我，不要畏惧失败，不要停下脚步，就算遍体鳞伤，就算一无所有，也要前进，也要战斗，也要证明给自己看，我到底是怎样的一个人！？</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202122109437.jpg" alt="有话直说，说到做到" /></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令行下性能分析</title>
    <link href="/2022/02/02/2022-02/2022-02-02%20Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2022/02/02/2022-02/2022-02-02%20Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="性能分析"><a class="markdownIt-Anchor" href="#性能分析"></a> 性能分析</h1><p>我根据我这些年的经验，挑选了四个“高性价比”的工具：top、pstack、strace 和 perf。它们用起来很简单，而且实用性很强，可以观测到程序的很多外部参数和内部函数调用，由内而外、由表及里地分析程序性能。</p><h1 id="top"><a class="markdownIt-Anchor" href="#top"></a> top</h1><h2 id="参数解释"><a class="markdownIt-Anchor" href="#参数解释"></a> 参数解释</h2><p>通过top命令，就能够简单直观地看到 应用程序的CPU、内存等几个最关键的性能指标。下面这张图截自ubuntu20.04 虚拟机的top命令。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202202041956057.png" alt="ubuntu中top命令截图" /></p><p>其中个指标的含义可以参考自这篇博客<a href="https://blog.csdn.net/zhuoya_/article/details/81049967">top命令的用法</a> <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="top命令的用法">[1]</span></a></sup>：</p><ul><li><p>Tasks一行：</p><ul><li><p>total : 进程总数</p></li><li><p>Running: 正在运行进程数</p></li><li><p>Sleeping: 睡眠的进程数</p></li><li><p>Stopped: 停止的进程数</p></li><li><p>zombie: 僵尸进程数</p></li></ul></li><li><p>Cpu一行：</p><ul><li>us：用户空间占用CPU的百分比</li><li>sy：内核空间占用CPU的百分比</li><li>ni：用户进程空间内改变过优先级的进程占用CPU百分比</li><li>id：空闲CPU百分比</li><li>wa：等待输入输出的CPU百分比</li><li>hi：硬中断占用CPU百分比</li><li>si：软中断占用CPU百分比</li><li>st：当hypervisor服务另一个虚拟处理器的时候，虚拟CPU等待实际CPU的百分比</li></ul></li></ul><p class='note note-info'>软中断是执行中断指令产生的，而硬中断是由外设引发的。</br>为了满足实时系统的要求，中断处理应该是越快越好。linux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断来完成。</p><ul><li>Mem为物理内存使用，Swap为交换区使用。</li><li>白色标注行：<ul><li><p>PID：进程ID</p></li><li><p>USER：进程所有者的用户ID</p></li><li><p>PR：priority，动态优先级，取值范围[0,99]，取值越小，优先级越高。priority的值在之前内核的O1调度器上表现是会变化的，所以叫做<strong>动态优先级</strong>。</p></li><li><p>NI：nice值，静态优先级。取值范围[-20,19]，取值越小，优先级越高。nice值设定好后，一般是不会改变的，除非使用系统调用进行修改，所以称为<strong>静态优先级</strong>。</p></li><li><p>VIRT：进程使用的虚拟内存的总量，VIRT = SWAP + RES</p></li><li><p>RES：进程使用的、未被换出的物理内存大小，单位kb，RES = CODE + DATA</p></li><li><p>SHR：共享内存，也会被统计在RES中。</p><ul><li><p>除了自身进程的共享内存，也包括其他进程的共享内存；</p></li><li><p>虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小；</p></li><li><p>计算某个进程所占的物理内存大小公式：RES – SHR；</p></li></ul></li><li><p>S：进程状态</p><ul><li>R：当前正在运行(RUNNING)</li><li>S：睡眠(SLEEP)</li><li>D：不可中断</li><li>T：停止(STOP)</li><li>Z：僵尸进程(ZOMBIE)</li></ul></li><li><p>%CPU：上次更新到现在的CPU时间占用百分比</p></li><li><p>%MEM：进程占用物理内存占比</p></li><li><p>TIME+：进程使用CPU时间总结</p></li><li><p>COMMAND：进程名称（命名名/命令行）</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202202042034815.jpeg" alt="程序优先级描述" /></p><h2 id="交互命令"><a class="markdownIt-Anchor" href="#交互命令"></a> 交互命令</h2><ul><li>按 <code>f</code> 键进入交互界面，此时按<code>d</code>可以显示或隐藏列，按<code>s</code>可以设置当前选中的列进行排序，默认为降序，可以按<code>R</code>进行升序（注意大写）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202202042053474.png" alt="按 f 键进入交互界面" /></p><ul><li>先按<code>-&gt;</code>右键表示选中该列，在按上下移动键，就可以调整列的显示顺序</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202202042056414.png" alt="调整列的顺序" /></p><ul><li><p><strong>h</strong>或者**?**：显示帮助画面</p></li><li><p><strong>k</strong> :终止一个进程；默认使用15信号，可以使用信号9来强制结束该进程。但是在安全模式下此命令被屏蔽。</p></li><li><p><strong>t</strong>  ：切换显示进程和CPU状态信息。</p></li><li><p><strong>m</strong>  :切换显示内存信息。</p></li><li><p><strong>i</strong> :忽略闲置和僵死进程，开关式命令。</p></li><li><p><strong>M</strong>  ：根据驻留内存大小进行排序。</p></li><li><p><strong>P</strong>  ：根据CPU使用百分比大小进行排序。</p></li><li><p><strong>T</strong>   ：根据时间或者累计时间进行排序。</p></li><li><p><strong>top -d 秒数</strong>：表示进程界面更新时间（默认5秒）</p></li><li><p><strong>top -p 1</strong> : 查看进程号为1的进程</p></li></ul><h1 id="pstack"><a class="markdownIt-Anchor" href="#pstack"></a> pstack</h1><p>从 top 的输出结果里，我们可以看到进程运行的概况，知道 CPU、内存的使用率。如果发现某个指标超出了预期，就说明程序可能存在问题，接下来，我们就应该采取更具体的措施去进一步分析，比如采用pstack。pstack 可以打印出进程的调用栈信息，有点像是给正在运行的进程拍了个快照，能看到某个时刻的进程里调用的函数和关系，对进程的运行有个初步的印象。</p><p>pstack其实是个Shell脚本，核心原理是GDB的<strong>thread apply all bt</strong>命令，基本逻辑是通过进程号process-id来分析是否使用了多线程，同时使用GDB Attach到在跑进程上，最后调用bt子命令后简单格式化输出<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Linux pstack 源码里的基础知识">[2]</span></a></sup>。</p><hr /><p>编写一个测试程序如下，创建一个死循环线程，不停地睡眠1秒后输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleeptime</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>        cout &lt;&lt; <span class="hljs-string">&quot;sleep 1 s&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(sleeptime)</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译命令：<code>g++ -g -pthread test2.cpp -o test2</code>。</p><p>pstack命令：<code>sudo pstack $&#123;pid&#125;</code>这里的pid可通过top或者ps来找到。注意这里不加sudo可能不会打印输出。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202202042256078.png" alt="pstack打印函数调用栈" /></p><h1 id="strace"><a class="markdownIt-Anchor" href="#strace"></a> strace</h1><p><code>strace</code>是个功能强大的Linux调试分析诊断工具，可用于跟踪程序执行时进程系统调用(system call)和所接收的信号，尤其是针对源码不可读或源码无法再编译的程序。在Linux系统中，用户进程不能直接访问计算机硬件设备。当进程需要访问硬件设备(如读取磁盘文件或接收网络数据等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。<code>strace</code>可跟踪进程产生的系统调用，包括参数、返回值和执行所消耗的时间。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Linux进程照妖镜strace命令">[3]</span></a></sup></p><p>参考知乎这篇文章<a href="https://zhuanlan.zhihu.com/p/69527356">Linux进程照妖镜strace命令</a>，演示下 strace 命令作用。</p><p>首先编写一个测试程序，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">256</span>];<br>  <br>  <span class="hljs-comment">// 获取当前工作目录的绝对路径</span><br>    <span class="hljs-built_in">getcwd</span>(buffer, <span class="hljs-number">255</span>);<br><br>    <span class="hljs-built_in">printf</span>(buffer);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后执行下列命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编译</span><br>gcc test3.cpp -o test3<br><span class="hljs-meta">#</span><span class="bash"> 使用strace 追踪 test3程序</span><br>strace ./test3<br></code></pre></td></tr></table></figure><p>就可以看到程序产生的系统调用：</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202151120052.png" alt="程序中的系统调用" /></p><p>根据上述那片知乎文章参考，可以看到这里程序调用了<code>getcwd</code>函数，获取当前工作目录的绝对路径；<code>fstat</code>是用于检查文件状态，<code>brk</code>系统调用查阅了一下，大致作用是请求内核允许读写一个称为堆的连续内存块<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="BRK()系统调用做什么？">[4]</span></a></sup>，或者是说用于进程的内存分配<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="Linux进程分配内存的两种方式–brk() 和mmap()">[5]</span></a></sup>；<code>write</code>则是往文件写入内容。</p><hr /><p>strace的常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 执行名称为<span class="hljs-built_in">command</span>的命令或程序并跟踪系统调用</span><br>strace command<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 跟踪ID为的procid的进程系统调用情况</span><br>strace -p procid<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 统计ID为的procid的进程系统调用次数与用时，按CTRL+C结束统计</span><br>strace -c -p procid<br></code></pre></td></tr></table></figure><p class='note note-info'>  把 pstack 和 strace 结合起来，我们大概就可以知道，进程在用户空间和内核空间都干了些什么。当进程的 CPU 利用率过高或者过低的时候，我们有很大概率能直接发现瓶颈所在。</p><h1 id="perf"><a class="markdownIt-Anchor" href="#perf"></a> perf</h1><p><code>perf</code> 可以说是 <code>pstack</code> 和 <code>strace</code> 的“高级版”，它按照固定的频率去“采样”，相当于连续执行多次的 pstack，然后再统计函数的调用次数，算出百分比。只要采样的频率足够大，把这些“瞬时截面”组合在一起，就可以得到进程运行时的可信数据，比较全面地描述出程序的运行情况。</p><p>首先执行下面命令，安装perf：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install linux-tools-common <br></code></pre></td></tr></table></figure><p>但是提示我需要再安装新的包，这里我再安装<code>linux-tools-5.4.0-97-generic</code>就可以了。</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202151953426.png" alt="安装perf命令" /></p><p>然后执行 <code>sudo perf top</code>命令，就可以看到 <code>perf</code>界面，如下图所示：</p><p><img src="https://gitee.com/LoveAndShare/picture_backend/raw/master/img/202202152014700.png" alt="perf top 界面" /></p><p>参考这篇文章<a href="https://www.cnblogs.com/arnoldlu/p/6241297.html">系统级性能分析工具perf的介绍与使用</a>，了解各列的含义：</p><ul><li><p>第一列：符号引发的性能事件的比例，指占用的cpu周期比例。</p></li><li><p>第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。</p></li><li><p>第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库；[k]表述此符号属于内核或模块。</p></li><li><p>第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p></li></ul><hr /><p>perf top常用选项有：</p><blockquote><p>-e &lt; event &gt;：指明要分析的性能事件。</p><p>-p &lt; pid &gt;：Profile events on existing Process ID (comma sperated list). 仅分析目标进程及其创建的线程。</p><p>-k &lt; path &gt;：Path to vmlinux. Required for annotation functionality. 带符号表的内核映像所在的路径。</p><p>-K：不显示属于内核或模块的符号。</p><p>-U：不显示属于用户态程序的符号。</p><p>-d &lt; n &gt;：界面的刷新周期，默认为2s，因为perf top默认每2s从mmap的内存区域读取一次性能数据。</p><p>-g：得到函数的调用关系图。</p></blockquote><p>常用的 perf 命令是<code>perf top -K -p xxx</code>，按 CPU 使用率排序，只看用户空间的调用，这样很容易就能找出最耗费 CPU 的程序。</p><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/zhuoya_/article/details/81049967">top命令的用法</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/article/1005992">Linux pstack 源码里的基础知识</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/69527356">Linux进程照妖镜strace命令</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/ask/72042">BRK()系统调用做什么？</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.cnblogs.com/vinozly/p/5489138.html">Linux进程分配内存的两种方式–brk() 和mmap()</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>性能分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令学习</title>
    <link href="/2022/02/01/2022-02/2022-02-01%20Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/02/01/2022-02/2022-02-01%20Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="任务挂起和恢复"><a class="markdownIt-Anchor" href="#任务挂起和恢复"></a> 任务挂起和恢复</h1><p>我想大家应该都知道<code>ctrl+c</code>是终止任务/进程， <code>ctrl+z</code>是任务挂起（将一个正在前台执行的命令放到后台，并且处于暂停状态），那么任务挂起后该如何恢复呢？经过查阅<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="ctrl+z 以后怎么恢复挂起的进程">[1]</span></a></sup>，可以参考使用如下命令：</p><ol><li>jobs 显示当前暂停的进程</li><li>bg %N 使第N个任务在后台运行(%前有空格)</li><li>fg %N 使第N个任务在前台运行</li></ol><p class="note note-info">  注意：默认 bg 和 fg 不带%N时表示对最后一个进程操作</p><hr /><p>此外与任务/进程控制相关的命令还有 &amp; 和 nohup<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="linux 远程主机后台运行任务 挂起脚本">[2]</span></a></sup>。</p><p><code>Commod + &amp;</code> 在一个命令最后加上一个 &amp;，可以将这个命令放到后台执行；</p><p>如果让程序始终在后台执行，即使关闭当前的终端也执行（之前的&amp;做不到），这时候需要<code>nohup</code>。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。<br />关闭终端后，在另一个终端jobs已经无法看到后台跑得程序了，此时利用ps（进程查看命令）</p><h1 id="验证json格式正确性"><a class="markdownIt-Anchor" href="#验证json格式正确性"></a> 验证JSON格式正确性</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat a.json | python -m json.tool | wc -l <br></code></pre></td></tr></table></figure><p>使用上述命令，可以检查一个文件是否符合json格式，其实现原理如下：</p><ul><li>要验证的文件 a.json；</li><li>如果返回结果一行数字，则表示 a.json 文件格式正确；</li><li>否则返回 a.json 文件中错误的行号及错误信息。</li></ul><p>一旦 JSON 文件格式不对，或者文件内容缺失或者其他问题，就会导致 python -m 命令无法格式化，正是利用这一点，我们可以做一个 JSON 的验证。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Linux开发小技巧">[3]</span></a></sup></p><hr /><p>为了简化命令，可以利用alias设置命令别名，但是因为需要命令行参数传入文件名，而alias不支持命令行参数。在查阅资料后<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="linux中给 alias 添加自定义的参数">[4]</span></a></sup>，找到一种方法，就是通过定义函数的方式来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias isjson=&#x27;isjson()&#123;cat &quot;$1&quot; | python -m json.tool | wc -l&#125;; isjson&#x27;<br></code></pre></td></tr></table></figure><h1 id="grep-sed-awk命令"><a class="markdownIt-Anchor" href="#grep-sed-awk命令"></a> GREP、SED、AWK命令</h1><h2 id="grep"><a class="markdownIt-Anchor" href="#grep"></a> GREP</h2><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Linux开发小技巧">[3]</span></a></sup></p><ul><li>grep默认是忽略二进制数据的，可以加上 <code>-a</code> 或 <code>--text</code> 来表示不忽略二进制文件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -a file_name<br>或<br>grep --text file_name <br></code></pre></td></tr></table></figure><ul><li><strong>-E</strong>  : 使用正则表达式，匹配了才输出</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -E &quot;word1|word2|word3&quot; file.txt<br><span class="hljs-meta">#</span><span class="bash">满足任意条件（word1、word2和word3之一）将匹配。</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep word1 file.txt | grep word2 |grep word3<br><span class="hljs-meta">#</span><span class="bash">必须同时满足三个条件（word1、word2和word3）才匹配。</span><br></code></pre></td></tr></table></figure><ul><li><strong>-r</strong>  ：递归搜索目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -r word directory<br></code></pre></td></tr></table></figure><ul><li><strong>-v</strong> : 显示不包含匹配文本的所有行。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -v &#x27;abc\|efg&#x27; log.txt<br><span class="hljs-meta">#</span><span class="bash">排除 log.txt 中的 abc efg 关键字</span><br></code></pre></td></tr></table></figure><h2 id="sed"><a class="markdownIt-Anchor" href="#sed"></a> SED</h2><p>sed 可依照脚本的指令来处理、编辑文本文件。sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p><p>对文件进行文本替换操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s/原字符串/新字符串/&#x27; filename<br>sed -i &#x27;s/原字符串/新字符串/g&#x27; filename<br></code></pre></td></tr></table></figure><p><strong>-i</strong> 表示直接修改读取的文件内容，而不是输出到终端。</p><p>最后带 g 进行了一个全局的搜索；不带g的话，只是匹配每行的第一个字段，后面的匹配则会忽略。</p><hr /><p>示例：</p><ul><li>sed 文件首尾添加引号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s/^/&quot;/;s/$/&quot;/&#x27;  log.txt<br></code></pre></td></tr></table></figure><ul><li>sed 文件尾添加逗号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s/$/,/&#x27;  txt<br></code></pre></td></tr></table></figure><p class="note note-info">  注意上述命令在Mac系统的终端里会报错，需要在"-i" 后加上 "" </p><h2 id="awk"><a class="markdownIt-Anchor" href="#awk"></a> AWK</h2><p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。</p><ul><li>-F ：指定输入文件折分隔符</li><li>-v : 赋值一个用户定义变量。</li></ul><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 每行按空格或TAB分割，输出文本中的1、4项</span><br>awk &#x27;&#123;print $1,$4&#125;&#x27; log.txt<br><span class="hljs-meta">#</span><span class="bash"> 格式化输出</span><br>awk &#x27;&#123;printf &quot;%-8s %-10s\n&quot;,$1,$4&#125;&#x27; log.txt<br><span class="hljs-meta">#</span><span class="bash"> 使用<span class="hljs-string">&quot;,&quot;</span>分割</span><br>awk -F , &#x27;&#123;print $1,$2&#125;&#x27;   log.txt<br><span class="hljs-meta">#</span><span class="bash"> 使用自定义变量</span><br>awk -v a=1 &#x27;&#123;print $1,$1+a&#125;&#x27; log.txt# 数值加<br>awk -v a=1 &#x27;&#123;print $1,$1a&#125;&#x27; log.txt# 字符加<br></code></pre></td></tr></table></figure><h1 id="压缩和解压"><a class="markdownIt-Anchor" href="#压缩和解压"></a> 压缩和解压</h1><h2 id="zip"><a class="markdownIt-Anchor" href="#zip"></a> zip</h2><ul><li>压缩文件： <code>zip 压缩文件名 源文件</code></li><li>压缩目录： <code>zip -r 压缩文件名 源目录</code></li><li>解压： <code>unzip 压缩文件名</code></li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir book<br>touch book/1.txt<br>touch book/2.txt<br>zip -r book.zip book<br>unzip book.zip<br></code></pre></td></tr></table></figure><h2 id="gzip"><a class="markdownIt-Anchor" href="#gzip"></a> gzip</h2><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">示例</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">gzip 源文件</td><td style="text-align:left">gzip a.txt</td><td style="text-align:left">压缩为.gz格式的压缩文件，源文件会消失</td></tr><tr><td style="text-align:left">gzip -c 源文件 &gt; 压缩文件</td><td style="text-align:left">gzip -c yum.txt &gt; yum.txt.gz</td><td style="text-align:left">压缩为.gz格式的压缩文件，源文件不会消失</td></tr><tr><td style="text-align:left">gzip -r 目录</td><td style="text-align:left">gzip -r xx</td><td style="text-align:left">压缩目录下的所有子文件，但是不压缩目录</td></tr><tr><td style="text-align:left">gzip -d 压缩文件名</td><td style="text-align:left">gzip -d yum.txt.gz</td><td style="text-align:left">解压缩文件,不保留压缩包</td></tr><tr><td style="text-align:left">gunzip 压缩文件</td><td style="text-align:left">gunzip yum.txt.gz</td><td style="text-align:left">解压缩文件,不保留压缩包</td></tr></tbody></table><h2 id="tar"><a class="markdownIt-Anchor" href="#tar"></a> tar</h2><ul><li>tar -cvf 打包文件名 源文件<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="linux总结">[5]</span></a></sup><ul><li>-c 打包</li><li>-v 显示过程</li><li>-f 指定打包后的文件名</li><li>-x 解打包</li></ul></li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -cvf book.tar book<br>tar -xvf book.tar<br></code></pre></td></tr></table></figure><p><strong>更多压缩命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar –cvf jpg.tar *.jpg #将目录里所有jpg文件打包成tar.jpg <br><br>tar –czf jpg.tar.gz *.jpg #将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz <br><br>tar –cjf jpg.tar.bz2 *.jpg #将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 <br><br>tar –cZf jpg.tar.Z *.jpg #将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z <br><br>rar a jpg.rar *.jpg #rar格式的压缩，需要先下载rar for linux <br><br>zip jpg.zip *.jpg #zip格式的压缩，需要先下载zip for linux<br></code></pre></td></tr></table></figure><p><strong>更多解压命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar –xvf file.tar #解压 tar包 <br><br>tar -xzvf file.tar.gz #解压tar.gz<br><br>tar -xjvf file.tar.bz2 #解压 tar.bz2 <br><br>tar –xZvf file.tar.Z #解压tar.Z <br><br>unrar e file.rar #解压rar <br><br>unzip file.zip #解压zip<br></code></pre></td></tr></table></figure><h1 id="硬链接和软链接"><a class="markdownIt-Anchor" href="#硬链接和软链接"></a> 硬链接和软链接</h1><blockquote><p>参考：<a href="https://www.linuxprobe.com/soft-and-hard-links.html">软链接和硬链接的区别</a><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="软链接和硬链接的区别">[6]</span></a></sup></p></blockquote><p>我们知道文件都有文件名与数据，这在 <a href="https://www.linuxprobe.com/">Linux</a> 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。而有一种方法可以快速的寻找到数据元，那就是软硬链接，链接实际上就是一种文件共享的方式。</p><p>那么软链接和硬链接的区别在哪呢？<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="linux中硬链接与软链接的区别">[7]</span></a></sup></p><ol><li><strong>首先，两者作用的对象不同：</strong></li></ol><ul><li>硬链接，只能应用于文件，而不能应用于目录，而且不能跨文件系统（即分区）；</li><li>软（符号）链接，可以应用于文件，而且可以应用于目录和可跨文件系统（分区）。</li></ul><ol start="2"><li><strong>其次，两者的作用原理不同：</strong></li></ol><ul><li>硬链接中，假如说A文件是B文件的硬连接文件，那么A和B的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的，硬链接中一个inode号可以对应多个文件。如果删除其中任何一个文件，另外一个文件还能连接数据块，还是有效的文件，只是对应的inode节点号减少，其它并无影响。只有inode节点号减少到0，数据块才会被系统回收。</li><li>而在软链接中，假如说A文件是B文件的软连接文件，则A和B的inode节点号不同，每创建一个新的软链接，就会有一个新的节点号。而A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是“主从”关系，如果B被删除了，A仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</li></ul><ol start="3"><li><strong>语法不同：</strong></li></ol><ul><li>硬链接的语法：<code>ln filename [linkname ]</code></li><li>软链接的语法：<code>ln -s filename [linkname]</code></li></ul><hr /><p>最后总结一下：</p><ul><li>硬链接：与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块；</li><li>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问数据时，将用数据块中指向的文件路径进行替换。</li></ul><h1 id="其它shell技巧"><a class="markdownIt-Anchor" href="#其它shell技巧"></a> 其它shell技巧</h1><h2 id="输入相似文件名"><a class="markdownIt-Anchor" href="#输入相似文件名"></a> 输入相似文件名</h2><p>用花括号括起来的字符串之间再用逗号连接，可以实现自动扩展，非常有用。花括号中的每个字符都可以和之后（或之前）的字符串进行组合拼接，注意花括号和其中的逗号不可以用空格分隔，否则会被认为是普通的字符串对待。示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> &#123;one,two,three&#125;file</span><br>onefile twofile threefile<br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> &#123;one,two,three&#125;&#123;1,2,3&#125;</span><br>one1 one2 one3 two1 two2 two3 three1 three2 three3<br></code></pre></td></tr></table></figure><p>这个技巧有什么实际用处呢？最简单实用的就是给 cp,mv,rm 等命令扩展参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cp /search/code/file&#123;,.bak&#125;</span><br><span class="hljs-meta">#</span><span class="bash"> 给 file 复制一个叫做 file.bak 的副本</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> rm file&#123;1,3,5&#125;.txt</span><br><span class="hljs-meta">#</span><span class="bash"> 删除 file1.txt file3.txt file5.txt</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> mv *.&#123;c,cpp&#125; src/</span><br><span class="hljs-meta">#</span><span class="bash"> 将所有 .c 和 .cpp 为后缀的文件移入 src 文件夹</span><br></code></pre></td></tr></table></figure><h2 id="命令快捷键"><a class="markdownIt-Anchor" href="#命令快捷键"></a> 命令快捷键</h2><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ctrl+c</td><td style="text-align:left">强制终止当前命令</td></tr><tr><td style="text-align:left">ctrl+l</td><td style="text-align:left">清屏</td></tr><tr><td style="text-align:left">ctrl+a</td><td style="text-align:left">光标移动到命令行首</td></tr><tr><td style="text-align:left">ctrl+e</td><td style="text-align:left">光标移动到命令行尾</td></tr><tr><td style="text-align:left">ctrl+u</td><td style="text-align:left">从光标所在的位置删除到行首</td></tr><tr><td style="text-align:left">ctrl+z</td><td style="text-align:left">把命令放入后台</td></tr><tr><td style="text-align:left">ctrl+r</td><td style="text-align:left">在历史命令中搜索</td></tr><tr><td style="text-align:left">!n</td><td style="text-align:left">替换成第n条历史命令</td></tr><tr><td style="text-align:left">!!</td><td style="text-align:left">替换成上一条命令</td></tr><tr><td style="text-align:left">!字符</td><td style="text-align:left">替换成最后一条以该字符串开头的命令</td></tr></tbody></table><h2 id="命令连接符"><a class="markdownIt-Anchor" href="#命令连接符"></a> 命令连接符</h2><ol><li><p><strong>; 分号</strong>：没有任何逻辑关系的连接符。当多个命令用分号连接时，各命令之间的执行成功与否彼此没有任何影响，都会一条一条执行下去。</p></li><li><p><strong>|| 逻辑或</strong>：当用此连接符连接多个命令时，前面的命令执行成功，则后面的命令不会执行。前面的命令执行失败，后面的命令才会执行。</p></li><li><p><strong>&amp;&amp; 逻辑与</strong>：当用此连接符连接多个命令时，前面的命令执行成功，才会执行后面的命令，前面的命令执行失败，后面的命令不会执行，与 || 正好相反。</p></li><li><p><strong>| 管道符</strong>：当用此连接符连接多个命令时，前面命令执行的正确输出，会交给后面的命令继续处理。若前面的命令执行失败，则会报错，若后面的命令无法处理前面命令的输出，也会报错</p></li></ol><h2 id="复制文本内容"><a class="markdownIt-Anchor" href="#复制文本内容"></a> 复制文本内容</h2><p>有时候不好在终端界面里，用鼠标操作选中并复制文件里的文本内容，可以用下面的命令来复制文件里的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 方法1，利用重定向</span><br><span class="hljs-meta">$</span><span class="bash"> pbcopy &lt; file.txt</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 方法2，利用管道</span><br><span class="hljs-meta">$</span><span class="bash"> cat file.txt | pbcopy</span><br></code></pre></td></tr></table></figure><h1 id="bonus-系统启动过程"><a class="markdownIt-Anchor" href="#bonus-系统启动过程"></a> Bonus: 系统启动过程</h1><blockquote><p>参考阮一峰大佬的这篇博客：<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的</a><sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="计算机是如何启动的">[8]</span></a></sup></p></blockquote><h2 id="1bios"><a class="markdownIt-Anchor" href="#1bios"></a> 1.BIOS</h2><ul><li>计算机通电后，第一件事就是读取刷入ROM芯片的开机程序，这个程序叫做(Basic Input/Output System)</li></ul><h2 id="2硬件自检"><a class="markdownIt-Anchor" href="#2硬件自检"></a> 2.硬件自检</h2><ul><li>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做&quot;硬件自检&quot;（Power-On Self-Test)</li><li>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</li></ul><h2 id="3-启动顺序"><a class="markdownIt-Anchor" href="#3-启动顺序"></a> 3. 启动顺序</h2><ul><li>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</li><li>这时，BIOS需要知道，&quot;下一阶段的启动程序&quot;具体存放在哪一个设备</li><li>BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做&quot;启动顺序&quot;（Boot Sequence）</li><li>BIOS按照&quot;启动顺序&quot;，把控制权转交给排在第一位的储存设备。</li><li>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给&quot;启动顺序&quot;中的下一个设备。</li><li>这最前面的512个字节，就叫做&quot;主引导记录&quot;（Master boot record，缩写为MBR）</li></ul><h2 id="4-主引导记录的结构"><a class="markdownIt-Anchor" href="#4-主引导记录的结构"></a> 4. 主引导记录的结构</h2><ul><li><p>&quot;主引导记录&quot;只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。</p><ul><li><p>（1） 第1-446字节：是用来记录系统的启动信息的,调用操作系统的机器码</p></li><li><p>（2） 第447-510字节(64个字节)：分区表（Partition table），分区表的作用，是将硬盘分成若干个区</p></li><li><p>（3） 第511-512字节：主引导记录签名（0x55和0xAA）</p></li></ul></li></ul><h2 id="5-分区表"><a class="markdownIt-Anchor" href="#5-分区表"></a> 5. 分区表</h2><ul><li>磁盘分区是使用分区编辑器在磁盘上划分几个逻辑部分</li><li>磁盘一旦划分成多个分区，不同类的目录与文件可以存储进不同的分区内</li><li>&quot;主引导记录&quot;因此必须知道将控制权转交给哪个区</li><li>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做&quot;主分区&quot;<ul><li>（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</li><li>（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。</li><li>（3） 第5个字节：主分区类型，比如FAT32、NTFS等。</li><li>（4） 第6-8个字节：主分区最后一个扇区的物理位置。</li><li>（5） 第9-12字节：该主分区第一个扇区的逻辑地址。</li><li>（6） 第13-16字节：主分区的扇区总数。</li></ul></li></ul><h2 id="6-硬盘启动"><a class="markdownIt-Anchor" href="#6-硬盘启动"></a> 6. 硬盘启动</h2><ul><li>计算机的控制权就要转交给硬盘的某个分区了</li><li>四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做&quot;卷引导记录&quot;（Volume boot record，缩写为VBR）</li><li>&quot;卷引导记录&quot;的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</li></ul><h2 id="7-操作系统"><a class="markdownIt-Anchor" href="#7-操作系统"></a> 7. 操作系统</h2><ul><li>控制权转交给操作系统后，操作系统的内核首先被载入内存。</li><li>以Linux系统为例，先载入<code>/boot</code>目录下面的<code>kernel</code>。内核加载成功后，第一个运行的程序是<code>/sbin/init</code>。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代</li><li>然后，<code>init</code>线程加载系统的各个模块，比如窗口程序和网络程序，直至执行<code>/bin/login</code>程序，跳出登录界面，等待用户输入用户名和密码。</li></ul><hr /><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/zxRPI/p/7872413.html">ctrl+z 以后怎么恢复挂起的进程</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.jianshu.com/p/745a4cb32c47">linux 远程主机后台运行任务 挂起脚本</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/UwgHGSSnJhiYnDISxGQXag">Linux开发小技巧</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.phpernote.com/linux/1431.html">linux中给 alias 添加自定义的参数</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/QyERReOEIBC5T4580ffVHw">linux总结</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://www.linuxprobe.com/soft-and-hard-links.html">软链接和硬链接的区别</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="http://www.178linux.com/53101">linux中硬链接与软链接的区别</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>除夕夜浅谈</title>
    <link href="/2022/01/31/2022-01/2022-01-31%20%E9%99%A4%E5%A4%95%E5%A4%9C%E6%B5%85%E8%B0%88/"/>
    <url>/2022/01/31/2022-01/2022-01-31%20%E9%99%A4%E5%A4%95%E5%A4%9C%E6%B5%85%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p>哈哈，这还是第一次在除夕夜写点东西呢，也算是创纪录吧。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202201312130421.jpeg" alt="" /></p><p>主要前一周刚把学校里的作业忙完，然后这一周就本性暴露，开始摆烂躺平，疯狂沉迷游戏，肆意地挥霍时间，明明之前都制定好假期计划，要加强自我的，可恶，难道，wa ta shi，又要重蹈覆辙吗？</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202201312139874.jpeg" alt="" /></p><p>明天大年初一，新的一年，新的开始，就算伤痕累累，就算跌倒失败，我也要前进，我也要战斗，ta ta kai, yi zi mo ta ta kai !</p><p>至于今晚的剩余时间，晚上年夜饭也喝了酒，就好好休息吧，看看bilibili的拜年纪，再把天降之物的剧场版给补了，睡个好觉，明天再出发~</p><p>最后，祝大家新春快乐，虎年大吉~</p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202202010930000.jpeg" alt="虎年" style="zoom:67%;" />]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++指针那些事</title>
    <link href="/2022/01/17/2022-01/2022-01-17%20C++%E6%8C%87%E9%92%88%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/01/17/2022-01/2022-01-17%20C++%E6%8C%87%E9%92%88%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>指针真的让人又爱又恨，每当自己认为已经参悟一二，现实总是狠狠地打了我脸，不是忘了这个，就是忘了那个。因此趁这个机会，再温习回顾下C/C++里指针的相关语法知识，并记录下来以便日后复习。</p><h1 id="基本知识"><a class="markdownIt-Anchor" href="#基本知识"></a> 基本知识</h1><h2 id="指针基本概念"><a class="markdownIt-Anchor" href="#指针基本概念"></a> 指针基本概念</h2><p>在C语言中，每定义一个变量，系统就会为变量分配一块内存，而内存是有地址的。C语言中，采用运算符 &amp; 来获取变量的地址。</p><p><strong>指针是一种特殊类型的变量，用于存储变量的地址</strong>。当指针变量赋值之后，就可以使用运算符 * （解引用运算符），取得指针所指向地址的值，简单用法如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span>* p;  <span class="hljs-comment">// 定义一个指针p，类型为 int;</span><br><span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<span class="hljs-comment">// 定义一个 int 变量</span><br><br>p = &amp;b;<span class="hljs-comment">//将 p 指向 b</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;变量 num 的地址为 &quot;</span> &lt;&lt; p &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;变量 num 的地址为 &quot;</span> &lt;&lt; (&amp;num) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;变量 num 的值为&quot;</span> &lt;&lt; num &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;变量 num 的值为&quot;</span> &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">// *p 表示指针p中存储的地址所对应的值；</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：在 C++ 创建指针时，计算机将会分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存 ，为数据分配的空间是一个独立的空间，不可省略，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> *pt;<span class="hljs-comment">// 定义一个指向 int 类型的指针 pt;</span><br>*pt = <span class="hljs-number">23</span>;<span class="hljs-comment">// 错误，指针 pt 未指向任何地址，</span><br></code></pre></td></tr></table></figure><p>所以需要谨记一点，在对指针应用解引用运算符(*) 之前，将指针初始化为一个确定的，适当的地址。</p><h2 id="空指针与野指针"><a class="markdownIt-Anchor" href="#空指针与野指针"></a> 空指针与野指针</h2><p>空指针：没有赋值的指针变量（没有指向内存变量的地址），对空指针进行操作会造成程序的Core dump（段错误）。如下代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span>* p = <span class="hljs-number">0</span>;<br>*p = <span class="hljs-number">10</span>;<span class="hljs-comment">// 运行报错</span><br></code></pre></td></tr></table></figure><p>野指针：指针指向内存已释放，但指针的值不会被清零，对野指针操作的结果不可预知。如下代码所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">delete</span> p ;<br><span class="hljs-keyword">if</span> (p !=  <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-comment">// 已经释放了对应内存空间，但指针的值还没有清零，此时成为野指针</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;not nullptr&quot;</span> &lt;&lt; endl;<br>&#125;<br>p = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">// 释放指针后，应当手动置指针为nullptr</span><br></code></pre></td></tr></table></figure><h2 id="sizeof的坑"><a class="markdownIt-Anchor" href="#sizeof的坑"></a> sizeof的坑</h2><p>sizeof(x) ，当 x 为指针变量时，求得的是指针类型的大小；当 x 为数组名时，求得的是数组的大小（数组元素个数 * 数组元素类型大小）。</p><p><strong>注意</strong>：当数组作为函数的参数进行传递时，数组自动退化为同类型的指针。参考下面示例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data[])</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(data);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> data1[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">int</span> size1 = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(data1);    <span class="hljs-comment">// 20 （输出的是数组大小)</span><br>    <br>    <span class="hljs-keyword">int</span>* data2 = data1;<br>    <span class="hljs-keyword">int</span> size2 = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(data2);    <span class="hljs-comment">// 8 (64位机器） 输出的是指针大小</span><br>    <br>    <span class="hljs-keyword">int</span> size3 = <span class="hljs-built_in">get_size</span>(data1);  <span class="hljs-comment">// 8 (64位机器）</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="指针与数组"><a class="markdownIt-Anchor" href="#指针与数组"></a> 指针与数组</h1><ul><li>数组名用法上 类似于一个指针常量，指向数组首元素的地址</li><li>对于指针p， p+1 的跨度，即移动p一次增加的字节数大小，等于指针p所指元素类型的大小<ul><li>对于int *p，增加4字节</li><li>对于double *p ，增加8字节</li><li>对于int (* p)[3)，增加 3 * 4 = 12 字节，因为p指向的是一个数组，整个数组的大小为3、*4 = 12字节</li><li>对于int* * p，增加8字节（64位系统），因为p指向的是一个int*指针，而指针大小为8字节</li></ul></li><li>对于new的使用，通常是和指针结合在一起，对于 Type* p （Type代表某种类型），通常new是有两种用法<ul><li><code>Type* p = new Type( )</code>，只分配单个Type的内存，new返回的也是这个Type的内存地址<ul><li>获取对应元素，通常使用 *p，但是 p[0] 也是同样的效果；使用 p[1] 的话，会访问超出了我们分配的内存，可能带来不可预知的后果</li></ul></li><li><code>Type* p = new Type[n]</code>，分配n个 Type的内存，new返回的是Type数组首元素的地址<ul><li>获取对应元素，通常使用 p[i]，获取下标为 i 的元素</li></ul></li></ul></li></ul><hr /><p>这样的话有这样一个疑惑，如下方图片中标红区域，可以有申请一个int的大小，申请一个指针的大小，如何单独申请一个数组对象？</p><center><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202201221755705.png" alt="" style="zoom: 50%;" /></center><p>似乎并没有相对应的方式，因为申请一个数组的空间已经用 <code>int* p = new int[3]</code> 表达了，其实这个问题有点类似钻牛角尖，或者说自以为有这样的对称规律在。但在实际使用中并不推荐使用new 和 delete，对于数组的需求，使用vector&lt; T&gt; 就行了；这里只是为了探讨研究语法问题。</p><h1 id="指针常量与常量指针"><a class="markdownIt-Anchor" href="#指针常量与常量指针"></a> 指针常量与常量指针</h1><p><strong>指针常量</strong>：指针类型的常量。表示这个指针变量用const修饰后成了常量，变量的值不能改变即不能指向其他地址，但是指针所指向地址里的值是可以修改的。同时注意这是个常量，所以在定义的时候要初始化。</p><p><strong>常量指针</strong>：指针变量指向的类型为常量类型，即指针指向地址里的值不可以修改。</p><p>具体示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p1 = &amp;a;<span class="hljs-comment">// p1是指针常量</span><br>*p1 = <span class="hljs-number">30</span>;   <span class="hljs-comment">// p1指向的地址是一定的，但其内容可以修改</span><br><span class="hljs-comment">// p1 = &amp;b;// p1指针常量不能指向其他变量的地址</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p2 = &amp;a; <span class="hljs-comment">// p2是常量指针</span><br><span class="hljs-comment">// int const *p2 = &amp;a; // 和上一行等价</span><br>p2 = &amp;b; <span class="hljs-comment">// p2可以指向其他地址，但是内容不可以改变</span><br><span class="hljs-comment">// *p2 = 10; // p2常量指针，所指向地址的值不可以修改</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p3 = &amp;a;<span class="hljs-comment">// p3既是指针常量又是常量指针</span><br><span class="hljs-comment">// p3 = &amp;b;// p3不能指向其他地址</span><br><span class="hljs-comment">// *p3 = 30;// p3所指向地址的值不能修改</span><br></code></pre></td></tr></table></figure><p>有时候指针常量和常量指针傻傻分不清，教大家一个小技巧，<strong>就是看 const  在 * 的哪一侧</strong>，如果const 在 * 左侧，表明const 靠近所指向的变量类型，即所指向的变量是个常量，也就是常量指针；如果 const 在 * 的右侧，表明 const 靠近指针变量名，所以这个指针变量是个常量，也就是指针常量。</p><h1 id="函数名与函数指针"><a class="markdownIt-Anchor" href="#函数名与函数指针"></a> 函数名与函数指针</h1><p>就像定义 int 变量时，会在内存里分配一个4字节的空间存储该变量，对应有一个地址；当定义了一个函数后，同样需要在内存中分配空间进行存储，调用函数就像使用变量一样需要一个地址来唯一的指向它，所以每个函数都需要一个地址来唯一标识自己，也就是所说的入口地址。</p><p>函数名标识映射该函数的入口地址，而函数指针是指向函数入口地址的指针变量（记住了函数名本身并不是一个指针类型）。</p><p>有了指向函数的指针变量后，可以用函数指针变量调用函数，就像用指针变量操作其他类型变量一样。函数指针主要有两个用途：调用函数和做函数的参数。</p><hr /><p>我们都知道在调用函数的时候有函数名就够了，比如fun(2)，但编译器在编译的时候会进行所谓的&quot;<strong>Function-to-pointer conversion</strong>&quot;，也就是把函数名隐式转换成函数指针类型，也就是要通过函数指针来调用函数，所以如果你在调用函数的时候写成(&amp;fun)(2)也是一样能工作的，因为&amp;fun实际上就是返回一个函数指针。参照下面例子，只是这种写法很不常见，即使你不显式的写出&amp;的话编译器也会隐式的进行转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;fun&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fun=%p\n&quot;</span>,fun);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*fun=%p\n&quot;</span>,*fun);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;fun=%p\n&quot;</span>,&amp;fun);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*******fun=%p\n&quot;</span>,*******fun);<br><br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*p1)(<span class="hljs-keyword">int</span>)=fun;<span class="hljs-comment">// 函数指针p1，fun进行一次隐式转换</span><br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*p2)(<span class="hljs-keyword">int</span>)=*fun;<span class="hljs-comment">// fun进行了两次隐式转换</span><br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*p3)(<span class="hljs-keyword">int</span>)=&amp;fun;<span class="hljs-comment">// 显示转换成函数指针</span><br><span class="hljs-comment">//    void(*p4)(int)=&amp;&amp;fun; // 不可以，连续取两次地址，就变成了函数指针的指针类型</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p1=%p\n&quot;</span>, p1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p2=%p\n&quot;</span>, p2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p3=%p\n&quot;</span>, p3);<br>&#125;<br></code></pre></td></tr></table></figure><p>正如上面代码示例所示，其实即使你写成(* fun)(2)也是可以正常运行的，这是因为当编译器看到fun的时候发现它前面没有&amp;，<strong>也就是如果没有将函数名显示地转换成指针，那么他就会隐式地转换成指针</strong>，当转换完之后发现前面又有一个 * 这时候也就是要进行所谓的&quot;解引用&quot;操作，也就是取出 * 指针里的值，而那么值实际上也就函数名fun，这样一次隐式换然后再来一次解引用实际上相当于什么也没做，所以系统还会再进行一次隐式的&quot;Function-to-pointer conversion&quot;，所以即使你写成(************fun)(2)也会正常运行，和刚才的一个道理，只是多做了几次反复的转解操作而已，都是编译器自己完成的。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p>[1] <a href="https://www.cnblogs.com/Esfog/archive/2012/04/23/2467249.html">C/C++的函数名和函数指针的关系剖析 - Esfog - 博客园</a></p><p>[2] <a href="https://www.jb51.net/article/54220.htm">数组名与数组指针、指针数组</a></p><p>[3] <a href="https://juejin.cn/post/6923743288407097351">C++ 指针详讲、及指针与数组 - 掘金</a></p><p>[4] <a href="https://www.bilibili.com/video/BV16T4y1w7wm?p=7">解决全部C语言指针的问题_哔哩哔哩</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年终总结</title>
    <link href="/2021/12/31/2021-12/2021-12-31%202021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2021/12/31/2021-12/2021-12-31%202021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>现在是2021年12月31日19点45分，后天的这个时候我应该在考云计算，所以保险起见，我还是先去复习吧，年终总结就放到考完试再补上~</p><center><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20190816%2Fc1bb1f88cc334de5bfdb433c1766f830.png&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643543259&t=b6769fbb96552656e2b401a1e9d5feea" alt="" style="zoom:50%;" /></center><hr /><p>今天是2022年1月2日，现在我已经考完了史诗级难度的算法分析与设计，以及差点没写完的云计算。等到我心情平复下来，也时候补交这份年终总结了。</p><center><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202201022151747.jpeg" alt="看开了" style="zoom:40%;" /></center><h1 id="实习"><a class="markdownIt-Anchor" href="#实习"></a> 实习</h1><h2 id="实习经历简介"><a class="markdownIt-Anchor" href="#实习经历简介"></a> 实习经历简介</h2><p>从去年11月开始，我就去了字节实习，而截至今年开学9月份才离职，再除去中间请假一个多月回学校做毕设，算起来也快实习了9个月，不禁令人感叹时间真的过得太快了，下面我就简单介绍一下自己的实习经历吧。我所在部门是抖音国际版（也就是Tiktok）的广告中台Global Ads Infra，负责广告投放的相关业务，也算是比较核心的部门了，毕竟广告营收是流量变现的重要途经。</p><p>在实习期间，的确是学习到了不少广告的相关知识，从零开始了解相关业务，记得一开始碰到的广告相关的陌生名词有满满一页，对具体的广告投放流程也是云里雾里，不知所踪。到后来，待久了，也渐渐熟悉起来，明白了大致流程，大体的模块架构，当然也非常浅显，只是对各个功能模块了解个大概。从硬看源码，到增加功能点，进行测试，开AB测试实验，再到提交自己的PR通过Review，最终代码上线，这一过程下来也让我些许了解了大厂的项目开发流程。</p><p>然后再谈谈我个人的工作吧，一开始我是维护一个线上服务的监控系统，简单来说就是在线上服务里增加打点逻辑，然后再另一个程序里进行流处理，实时输出相关监控指标，不过因为代码使用scala写的，我也不是很熟，所以只是简单修改了一下逻辑，修复Bug。老实说，因为这个项目是2年前的项目了，大概快一年没人在维护了，所以感觉问题还是很大的，但我个人又因为实力不足，无法进行重构，就是那种知道有问题，但又给不出解决方案，可以说是菜鸡落泪了，所以最后这个项目也就是做到了能跑的效果。不过这个监控服务后来也没有被怎么重视，没有什么人用，所以也就这样了，因为后来有了更重要的需求要做。</p><p>之后主要负责的工作是搭建实验指标，为开发同学实验测试提供指标参考，测试新增功能是否存在异常。具体来说，我就是收集各个服务Owner的需求，在对应服务的代码里增加相关逻辑，然后提交需求给实验指标平台，再让他们做完成实验平台上的开发工作。这个工作的主要难点，就在于要去看各个服务的代码，得稍微懂点其中运行流程和逻辑，然后再合适的地方加上数据打点，写的代码其实不多，还有就是处理逻辑需要写个Flink SQL，然后再把需求整理给文档提交给实验平台的同学。这个过程是收集需求，看代码了解逻辑，以及和其他部门的同学打交道，对接工作需求，虽然重复性工作挺多，但也有一定的收获。</p><p>最后的话，是对一个线上服务做了小优化，主要在mentor的指导下，优化了Go语言里Map序列化的问题，略微降低了在线服务机器的CPU和内存使用率。这个工作对我来说，感觉受益匪浅，学习到了怎么去进行测试，性能优化看哪些指标，怎么看，最后出了一份方案报告，虽然也比较简单吧，但也受到了大家的肯定，对我来说，感觉还是很不错的，就是那种你做的工作切实有效，是肉眼可见的，而没有白费，就感觉实现了自己的一点价值。</p><h2 id="实习收获与感受"><a class="markdownIt-Anchor" href="#实习收获与感受"></a> 实习收获与感受</h2><p>总的来说，这份实习经历我认为还是非常宝贵的，无论是mentor还是其他同事，都十分友善，也都很有能力，给了我不少帮助和指导。不过实习期间，代码写的不多，文档倒是写了不少……所以我感觉自己的代码能力或许没有提升多少，但是眼界和视野是拓展开阔了，接触了解到项目的开发流程，学习如何与人合作沟通交流，思维方式也发生了改变，开始重视时间规划，估算工作量，关注工作产出。还有一个很大的收获就是学习使用飞书了，到现在，飞书也成了我的笔记主力，提升了我不少学习效率。</p><p>还有特别深的感触就是，感觉自己真的好菜，很多地方都不会，不懂，没啥突出的能力，跟正式员工真的差距很大，觉得自己在学校里虽然考试能拿高分，但是到了实际开发中，自己的能力真的是远远不足，没有过硬的代码能力，也没有什么架构思维，可能也就基础马马虎虎吧。也正是如此，让我下定决心，回到学校后，一定要去把这些欠缺的能力都给补起来。</p><h2 id="自我反思与总结"><a class="markdownIt-Anchor" href="#自我反思与总结"></a> 自我反思与总结</h2><p>在实习的头两个月还好，还保持着一种比较高昂的斗志，但是之后可能是热情散去了，就陷入了一种懒散的状态，每天相当于是打卡上班实习，按部就班完成自己的工作任务，也没有想着再多去学习新技术啥的，可能就导致我成长得比较慢（自我感觉）。</p><p>在实习期间，我还染上了一大恶习，那就是熬夜玩手机、玩电脑。曾经我也认为超过12点不睡觉就是罪大恶极，对身体会造成极大危害，会给自己带来极大的负罪感。但是在实习独居期间，各种熬夜到2、3点，甚至好几次熬夜到6点多睡，10点起上班，记得情况最严重的一次，当时整个人脑袋昏昏沉沉的，到了公司一点状态都没有，工作效率极差。而熬夜带来的连锁反应就是，睡眠不足，晚起不吃早饭，与我之前的作息大相径庭，也造成了我实习期间状态不佳，都没充沛的精神，还谈何学习和工作呢？再加上每逢周末必点外卖，不太注意饮食，导致那段期间身体状况不容乐观，明显可以感觉到不如从前。</p><p>总结来说，该反思的有两点，一个是心态上，实习期间还是缺乏一种积极学习的态度，或者说当时也没有明确的目标，不知道要学什么，可以学什么，每天就只是完成工作任务，没有花更多的时间来拓展学习，的确该好好反思反思。另一个就是身体上，如果连自己的身体照顾不好，那还谈什么其他的呢？身体是革命的本钱，同时良好的健康状态也才能更好地支撑工作学习，提高效率，以后真的是需要保持健康的生活作息，多运动，多健身。</p><h1 id="研究生"><a class="markdownIt-Anchor" href="#研究生"></a> 研究生</h1><p>今年下半年，我成为了北京大学软件与微电子学院的研究生。老实说，没有太多实感，就像是被一股潮流推至此地。简单谈谈在软微的学习生活吧，软微地方很小，我住的5号楼离食堂和宿舍都很近，下个楼拐个弯就到了，很方便。软微的食堂比较小，菜式也比较固定，几个月下来，我的早饭基本上就是肉饼、素饼、土豆饼、酱香饼、培根煎鸡蛋、豆浆这五样里排列组合，不过我对吃饭也没过高的要求，所以也都还能接受吧。</p><p>软微的课程，感觉总体上和 本科差别不大吧，比较大的区别可能就是，成了研究生之后，自学的时间占了大量的课后时间，除了一些核心课需要考试考核，其他多数课程是类似于大作业的形式进行考查。在软微，你会遇到大佬，遇到<s>卷王</s>（废寝忘食的人），遇到像我这样的佛系的人，也可以说是各具特色了。或许是之前有过实习经历吧，和许多能人、专家共事过，所以虽然也知道自己和别人的差距很大，倒也没有太大的心理压力了，一步一步脚印嘛，慢慢来吧，抗压这一块我一直可以的（哈哈，躺平就直说~）。</p><p>此外，我又重视其自己的健康了。开学以来，我就在积极锻炼了，在宿舍里做Keep，室外跑步，入冬之后就只剩下室内运动了。但不幸的时候，12月初腰部出了点问题，久坐之后感到疼，可能是腰肌劳损了，后来去看了医生，开了药膏和药丸，告诫我之后不能久坐，每坐一小时，就需要起来活动一会儿。也是因为这个原因，我的健身计划也不得已搁置了，不过也算是给我敲响了警钟，我的身体真的没有我想象中那么乐观了，各位朋友，也要多多保重自己的身体啊。</p><h1 id="生活"><a class="markdownIt-Anchor" href="#生活"></a> 生活</h1><p>再来谈谈这一年来的生活吧，年初因为疫情原因没有选择回家过年，人生第一次在外地和驰哥一起在过春节，记得初一还是初二，吃的还是泡面哈哈。年后又是近3个月的实习，然后就请假一个多月，回学校做毕设去了。在最后短暂的日子里，和大学同学们相拥这最后的时光，毕竟毕业之后，再次相见不知何年何月了，但相信总会有重逢的一天，就让我们在那一天到来之前，各自努力成为更好的自己吧~</p><p>毕业之后，在家呆了一星期之后又回公司实习去了。再此后，就是9月份研究生开学，正式拉开了我研究生生活的序幕。还记得当时上学前，立下一个flag，10月前必脱单，或许是看到周围身边的人都脱单而感到焦虑了，或许是感到寂寞了，或许是认为再不谈一场校园恋爱以后再也没有机会。但结果来说，我失败了。然后，然后就没有后文了。或许真的是单身太久了，不知道心动到底是怎样一种感觉，不知道喜欢一个人你该去怎么行动，不知道怎么去爱一个人。想想自身的原因，长相一般，身高一般，不太会装扮，生活常识也有欠缺，同时还是个看动漫的宅男，还带有略微的中二，还喜欢打游戏，除了稍微，一丢丢对学习上点心外，似乎没有别的什么特别之处，这样的人设的确吸引不了别人啊。不过后来我也看开了，再遇到她之前，我还是继续努力，多多提升自己吧，成为更优秀的人。</p><p>接着谈谈游戏吧，这一年主要玩的还是英雄联盟，每周六晚更是成了开黑时段，也就玩玩大乱斗了，与其说是玩游戏，或许更多的是享受和朋友吹水时刻吧。此外还用模拟器玩了女神异闻录p5以及八方旅人，感觉都是不错的游戏。以后的话，打算是等有钱了，整上台式机，ps主机，Switch，大屏显示器，不过可能到了那个时候可能反而没有玩游戏的心思了，想玩的时候玩不了，能玩的时候不想玩了或者还是玩不了，这么想来，还是有些许的悲伤呢。</p><p>还能说点什么呢，哦，对了，那就是我感觉自己还是没有长大，或者说不够成熟，对于人情世故不太擅长，不擅交际，对生活的一些常识或者说是细节还不了解，感觉自己的心态还是孩子一样，不愿去思考更多的东西，或者说不想去承担某些责任，只是任由生活推着自己往前走，而不是自己挑起担子往前跑，当然也有做努力在改变，但似乎远远不够。就像是周围的朋友都有了大人模样，而我还是那个沉浸在自己世界里的少年。我希望自己能长大，但也畏惧着长大。我很焦虑，但又很佛系，就像是薛定谔的猫一般，处在一个叠加态。</p><p>再谈谈一些个人的体会感悟吧：</p><ol><li>身体健康是第一位。</li><li>多关爱自己的父母。</li><li>多珍视自己的朋友。</li><li>学会换位思考。</li><li>一日三省吾身。</li><li>学无止境，终身学习。</li></ol><h1 id="目标"><a class="markdownIt-Anchor" href="#目标"></a> 目标</h1><p>最后自然是设定来年的目标啦，这里简略地列出了一些目标：</p><ol><li>搭建好自己的博客网站；</li><li>持续写博客，尽量保持每周一篇，目标全年50篇以上；</li><li>写番剧回顾，回顾自己的看番历史，也算是给自己热爱这么久的二次元一个总结交代吧。可以的话再剪辑一些片段，最后做一个AMV或者MAD出来；</li><li>C++ 开发学习，包括语法和项目（比如写一个网站，服务器）；stackflow上解决C++ 问题，检验自己的知识成果，目标Reputation 过500；</li><li>算法强化，刷题，目标Leecode 300题；</li><li>书籍阅读</li></ol><ul><li>计算机相关书籍 10本；;</li><li>文学类小说等 5本；</li><li>其他杂项（金融理财、传记、为人处世等）3~5本；</li></ul><ol start="7"><li>健身，目标拥有腹肌；增强上肢力量，增强背部、核心力量，目标引体向上做10个以上；</li><li>参加一次大型比赛并获奖，满足毕业资格；</li><li>日语继续学习，可以做到基本的听和说。</li></ol><h1 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h1><p>写写停停，缝缝补补，最后是在2022年1月7日回家的高铁上，完成了这篇年度总结，突然感觉自己又行了呢，哈哈。希望在新的一年了，自己能有更大的成长吧，也衷地祝愿各位成为更好的自己~</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>年度总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的最佳日志实践</title>
    <link href="/2021/12/25/2021-12/2021-12-25%20%E6%88%91%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5/"/>
    <url>/2021/12/25/2021-12/2021-12-25%20%E6%88%91%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><blockquote><p>本文译自：<a href="https://tuhrig.de/my-logging-best-practices/">https://tuhrig.de/my-logging-best-practices/</a></p></blockquote><p>如果你是一名后端开发者，那么日志就相当于你的应用的窗口。不像前端，除了日志消息外没有太多别的东西。接下来将介绍一些我个人写日志时的指导思想。</p><h1 id="log-after-not-before"><a class="markdownIt-Anchor" href="#log-after-not-before"></a> Log After, not before</h1><p>回想以下以前，每艘船都会有一本航海日志，就像日记一样，记录着每天发生的重要事情。就像一本传统的航海日志，我们应该记录已经发生的事情，而不是我们将要做的事情。</p><p>举一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// don&#x27;t do that</span><br>log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Making request to REST API&quot;</span>)<br>restClient.<span class="hljs-built_in">makeRequest</span>()<br> <br><span class="hljs-comment">// do that</span><br>restClient.<span class="hljs-built_in">makeRequest</span>()<br>log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Made request to REST API&quot;</span>)<br></code></pre></td></tr></table></figure><p>第一个 log 声明并没有给出太多信息。当读到它的时候，你并不知道REST调用是否成功。而为了知道是否调用成功，你必须寻找是否存在异常。当你读到这条log，但是却没有找到相应的 exception 异常，你将会困惑一整天。</p><blockquote><p>这里感觉没太翻译明白，可以对照原文看：The first log statement doesn’t tell much. When reading it, you will not know if the REST call was successful or not. To do so you must look for the absence of an exception. And if you read this log but miss the subsequent exception you will be confused for the rest of the day (trust me).</p></blockquote><p>第二个 log 方式则好了许多。它清楚地表明了刚刚的操作成功了。如果REST调用失败了，你将看不到这条 log，而是会有一个 exception。</p><p>我将对所有 <strong>INFO</strong> 日志遵守这条规则，然后对于 <strong>DEBUG</strong> 来说会生成 exceptions。</p><h1 id="separate-parameters-and-messages"><a class="markdownIt-Anchor" href="#separate-parameters-and-messages"></a> Separate parameters and messages</h1><p>一个典型的 log 小心包含两种类型的数据，一种是手写的消息，来声明接下来的消息内容。另一种类型数据则是一系列包含在之前操作中的参数。你应该区分这两部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// don&#x27;t do that</span><br>restClient.<span class="hljs-built_in">makeRequest</span>()<br>log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Made request to &#123;&#125; on REST API.&quot;</span>, url)<br> <br><span class="hljs-comment">// do that</span><br>restClient.<span class="hljs-built_in">makeRequest</span>()<br>log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Made request to REST API. [url=&#123;&#125;]&quot;</span>, url)<br></code></pre></td></tr></table></figure><p>第一种 log 消息有一些缺点。它是难以解析的，比如他对于 Grok pattern</p><p>来说。所以在我们的日志工具中，自动抽取 IDs 或者其他参数就会变得更困难。并且它也是难以阅读的。想象一下，一个非常长的 URL 在末端带有一系列参数。该条 log 消息的一半就超过了你的屏幕。同时，这个 log 也是难以扩展的。如果你想添加另一个参数（比如使用的 HTTP 方法）你就必须重写整个句子。</p><p>第二个版本就没有以上的缺点。它是非常容易解析的，因为它有清晰的结构。你在句子的前部分就能看到整个句子的内容。并且也十分容易扩展，只需要在列表里添加另一个参数。</p><h1 id="distinguish-between-warning-and-error"><a class="markdownIt-Anchor" href="#distinguish-between-warning-and-error"></a> Distinguish between WARNING and ERROR</h1><p>显然，有多种级别的 log 是有它存在的原因的，你应该适当地使用它们。在 <strong>WARNING</strong> 和 <strong>ERROR</strong> 之间存在明显的区别。</p><p>如果你做一些操作并且切实生效了，但是依然存在一些问题，这就是 WARNING。当如果你做了一些操作，它并没有生效，那就是一个 ERROR。</p><p>再来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    restClient.<span class="hljs-built_in">makeRequest</span>()<br>    log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Made request to REST API. [url=&#123;&#125;]&quot;</span>, url)<br>&#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span>(e: UnauthorizedException) &#123;<br>    log.<span class="hljs-built_in">warn</span>(<span class="hljs-string">&quot;Request to REST API was rejected because user is unauthorized. [url=&#123;&#125;, result=&#123;&#125;]&quot;</span>, url, result)<br>&#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span>(e: Exception) &#123;<br>    log.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;Request to REST API failed. [url=&#123;&#125;, exception=&#123;&#125;]&quot;</span>, url, exception)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 REST 调用可能有三种输出情况：</p><ul><li>它可以正常工作。那就会有一个 INFO 输出。</li><li>当它失败了，遇到了一个预期外的异常，那就是一个 ERROR。</li><li>当它导致了一些预期内的异常，那就是 WARNING。</li></ul><p>所以在 WARNING 的例子中，你做了一些事情，但你没有完美地做好。而在 ERROR 中，你并没有做事情。</p><p>另外注意，一个 WARNING（当然 ERROR 也是）是一个调用动作。如果没有人需要对此做出反应或者要做些什么，那么你也就不必去 log 输出 WARNING。</p><h1 id="info-is-for-business-debug-for-technology"><a class="markdownIt-Anchor" href="#info-is-for-business-debug-for-technology"></a> INFO is for business, DEBUG for technology</h1><p>INFO 日志应该看起来像一本书，它告诉你发生了什么，而不是如何发生的。这意味着 INFO 更适合于业务逻辑消息，相比于技术细节来说。技术相关的消息应该使用 DEBUG。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">INFO  | User registered <span class="hljs-keyword">for</span> newsletter. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br>INFO  | Newsletter send to user. [user=<span class="hljs-string">&quot;Thomas&quot;</span>]<br>INFO  | User unsubscribed from newsletter. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br></code></pre></td></tr></table></figure><p>上面 INFO 类型的日志，从我们业务逻辑的视角告诉你发生了什么。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">DEBUG | Saved user to newsletter list. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br>DEBUG | Send welcome mail. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br>INFO  | User registered <span class="hljs-keyword">for</span> newsletter. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br>DEBUG | Started cron job to send newsletter of the day. [subscribers=24332]<br>INFO  | Newsletter send to user. [user=<span class="hljs-string">&quot;Thomas&quot;</span>]<br>INFO  | User unsubscribed from newsletter. [user=<span class="hljs-string">&quot;Thomas&quot;</span>, email=<span class="hljs-string">&quot;thomas@tuhrig.de&quot;</span>]<br></code></pre></td></tr></table></figure><p>每个业务用例都会导致一条 INFO 日志输出。此外，会有 DEBUG 日志来给出更多细节信息，来描述处理过程。</p><h1 id="much-more"><a class="markdownIt-Anchor" href="#much-more"></a> Much more</h1><p>当然，对于好的日志来说还有许多值得做的。你还需要考虑 tracing, log aggregation and metrics 。但当提及如何书写时，我非常推荐上面的规则。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算的“奇淫技巧”</title>
    <link href="/2021/12/18/2021-12/2021-12-18%20%E4%BB%8B%E7%BB%8D%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2021/12/18/2021-12/2021-12-18%20%E4%BB%8B%E7%BB%8D%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><blockquote><p>原文来源：<a href="https://catonmat.net/low-level-bit-hacks">https://catonmat.net/low-level-bit-hacks</a></p></blockquote><p>介绍一些位运算的技巧，比如对应计算一个二进制整数中 1 bit的个数，不是通过循环遍历每一bit 是否为1，而是可以选择一些 tricky 的位运算来完成。</p><p>先来介绍一下本文中所使用的一些位运算操作符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">&amp;    -  bitwise and  位与<br>|    -  bitwise or     位或<br>^    -  bitwise xor    异或<br>~    -  bitwise not    取反<br>&lt;&lt;   -  bitwise shift left    左移<br><span class="hljs-meta">&gt;</span><span class="bash">&gt;   -  bitwise <span class="hljs-built_in">shift</span> right  右移</span><br></code></pre></td></tr></table></figure><p>在这篇文章中，表示的数字均为 8 bit 有符号整数（但是上述这些操作是可以在任意长度的有符号整数上执行的），并用 ‘x’ 来表示，而位运算计算后的结果用 ‘y’ 来表示。 其中 ‘x’ 的每一bit，使用 b<sub>7</sub>, b<sub>6</sub>, b<sub>5</sub>, b<sub>4</sub>, b<sub>3</sub>, b<sub>2</sub>, b<sub>1</sub>, b<sub>0</sub> 来表示，b<sub>7</sub> 是权重最高位（在符号数里就是符号位），b<sub>0</sub> 是权重最小的位。</p><p>接下来会先基本的bit hacks 介绍，然后逐渐深入到更高效的方法。</p><h1 id="1-检验一个整数的奇偶性"><a class="markdownIt-Anchor" href="#1-检验一个整数的奇偶性"></a> 1. 检验一个整数的奇偶性</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">if ((x &amp; 1) == 0) &#123;<br>  x is even<br>&#125;<br>else &#123;<br>  x is odd<br>&#125;<br></code></pre></td></tr></table></figure><p>相信很多人都已经看到过上述的技巧，其最基本的思想就是如果一个整数是奇数，那么它的最低位 b<sub>0</sub> 就为1。通过 将 ‘x’ 和 1 进行 <strong>AND-ing</strong> 操作，忽略其他bits，只关注 b<sub>0</sub> 即可，如果结果为0 表示 ‘x’ 是偶数，结果为1 表示 ‘x’ 是奇数。</p><p>举个例子，比如数字43，二进制表示为00101011，通过与 1 进行 <strong>AND-ing</strong> 操作，清除更高位的数值而只保留 b<sub>0</sub> ，最终剩余结果为 1 就表示整数为奇数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    00101011<br>&amp;   00000001   (note: 1 is the same as 00000001)<br>    --------<br>    00000001<br></code></pre></td></tr></table></figure><p>再举一个偶数的例子98，其二进制表示为1100010。在 <strong>AND-ing</strong> 操作后，最终结果为0，因此98是一个偶数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01100010<br>&amp;   00000001<br>    --------<br>    00000000<br></code></pre></td></tr></table></figure><h1 id="2-检验第n位-bit-是否置1"><a class="markdownIt-Anchor" href="#2-检验第n位-bit-是否置1"></a> 2. 检验第n位 bit 是否置1</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">if (x &amp; (1&lt;&lt;n)) &#123;<br>  n-th bit is set<br>&#125;<br>else &#123;<br>  n-th bit is not set<br>&#125;<br></code></pre></td></tr></table></figure><p>在先前的第一个例子，我们看到了通过 <code>（x &amp; 1）</code>来检验第一位 b0 是否置1，这个技巧可以通过改善实现检验第n位是否置1。主要做法就是将 1 左移n个位置，然后做相同的<strong>AND</strong> 操作，将除了第n位的其他bits清0。</p><p>下面演示了当你将 1 左移不同位数的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#">1         00000001    (same as 1&lt;&lt;0)<br>1&lt;&lt;1      00000010<br>1&lt;&lt;2      00000100<br>1&lt;&lt;3      00001000<br>1&lt;&lt;4      00010000<br>1&lt;&lt;5      00100000<br>1&lt;&lt;6      01000000<br>1&lt;&lt;7      10000000<br></code></pre></td></tr></table></figure><p>现在，我们将 ‘x’ 与  左移n位的 数字1 进行 AND 操作，就可以保留 'x’上第n位bit （对于 b0 来说是第0位）而将其他bit 清零。所以如果最终结果为0，表明对应bit 是0，最终结果不为0，表明对应bit置为1。</p><p>接下来给出一些例子，比如说 122 的第3rd bit 是否置为1，我们可以通过<code>122 &amp; (1&lt;&lt;3)</code>来实现，具体来说如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01111010<br>&amp;   00001000<br>    --------<br>    00001000<br></code></pre></td></tr></table></figure><p>可以看到最终结果不为0，因此122 对应的 3rd bit 是置为1的。</p><p>注意：在本文中，bit 的位数下标从0开始，也就是第0位bit，第1位bit ，…， 第7位 bit。</p><h1 id="3-将第n位-bit-置-1"><a class="markdownIt-Anchor" href="#3-将第n位-bit-置-1"></a> 3. 将第n位 bit 置 1</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">y = x | (1 &lt;&lt; n)<br></code></pre></td></tr></table></figure><p>这个 bit hack 结合了左移 (1&lt;&lt;n) 和 <strong>OR</strong> 运算的技巧，<code>y = x | (1&lt;&lt;n)</code>通过和一个第n位 置1 的数值进行 <strong>OR</strong> 运算就可以使得 ‘x’ 的第n位 置1。因为和 0 进行 OR-ing 数值保持不变，和 1 进行 OR-ing 对应bit变为1（如果不是1的话）。</p><p>同样给出一个例子，对于数120，我们希望将其 2nd bit 置为1，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01111000    (120 in binary)<br>|   00000100    (1&lt;&lt;2)<br>    --------<br>    01111100<br></code></pre></td></tr></table></figure><h1 id="4-将第n位-bit-置-0"><a class="markdownIt-Anchor" href="#4-将第n位-bit-置-0"></a> 4. 将第n位 bit 置 0</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">y = x &amp; ~(1&lt;&lt;n)<br></code></pre></td></tr></table></figure><p>这个bit hack 主要通过<code>y = x &amp; ~(1&lt;&lt;n)</code>实现，<code>~(1&lt;&lt;n)</code>起到的作用是将除了第n位置0，其余位置1，比如下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#">~1        11111110  (same as ~(1&lt;&lt;0))<br>~(1&lt;&lt;1)   11111101<br>~(1&lt;&lt;2)   11111011<br>~(1&lt;&lt;3)   11110111<br>~(1&lt;&lt;4)   11101111<br>~(1&lt;&lt;5)   11011111<br>~(1&lt;&lt;6)   10111111<br>~(1&lt;&lt;7)   01111111<br></code></pre></td></tr></table></figure><p>再通过 AND-ing 操作，就可以使得将 ‘x’ 的第n位置0，因为 AND-ing 中有个 bit 为0，结果 bit 就为0。下面给出数127，将第4位 bit 置0的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01111111    (127 in binary)<br>&amp;   11101111    (~(1&lt;&lt;4))<br>    --------<br>    01101111<br></code></pre></td></tr></table></figure><h1 id="5-反转第n位-bit"><a class="markdownIt-Anchor" href="#5-反转第n位-bit"></a> 5. 反转第n位 bit</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">y</span> = x ^ (<span class="hljs-number">1</span>&lt;&lt;n)<br></code></pre></td></tr></table></figure><p>这个bit hack 主要实现方式为<code>y = x ^ (1&lt;&lt;n)</code>，结合了左移和XOR 运算。<code>(1&lt;&lt;n)</code>将对应的第n位置1，而通过 XOR 运算，如果 ‘x’ 第n位为0，就会变为1，如果第n位为1，就会变为0，从而实现反转的效果。</p><p>下面给出一个例子，将 01110101 的第5位进行反转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01110101<br>^   00100000<br>    --------<br>    01010101<br></code></pre></td></tr></table></figure><h1 id="6-将最右边的1-bit置为0"><a class="markdownIt-Anchor" href="#6-将最右边的1-bit置为0"></a> 6. 将最右边的1-bit置为0</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">y</span> = x &amp; (x-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>该方式主要通过<code>y = x &amp; (x-1)</code>来实现。比如对于一个整数 001010<strong>1</strong>0（最右边的1用黑体标出），当将最后边的1-bit置为0后，就变成了001010<strong>0</strong>0（对应位变成了0）。</p><p>这里给出更多的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01011000    (x)<br>&amp;   01010111    (x-1)<br>    --------<br>    01010000<br><br>    10000000    (x = -128)<br>&amp;   01111111    (x-1 = 127 (with overflow))<br>    --------<br>    00000000<br><br>    11111111    (x = all bits 1)<br>&amp;   11111110    (x-1)<br>    --------<br>    11111110<br><br>    00000000    (x = no rightmost 1-bits)<br>&amp;   11111111    (x-1)<br>    --------<br>    00000000<br></code></pre></td></tr></table></figure><p>这是如何实现的呢，主要有两个可能的场景：</p><ol><li>该整数值存在一个最右边的1-bit。在这种情况下，当该数值减去1后，会将该二进制数的最右边的1-bit置为0，同时其右边所有低位的0变成1（就是一个减法得到的结果）。这个减法操作得到的结果，相当于已经把最右边的1-bit置0，然后再通过和原始值进行AND-ing 操作，就可以把低位的1都置为0。</li><li>当该二进制数不存在一个最右边的 1-bit（全为0）。那么在这种情况下，减1后会下溢，即所有 bit 置为 1 ，那么再和原始值（全0）进行AND-ing操作得到的也还是0。</li></ol><h1 id="7-只保留最右边的-1-bit"><a class="markdownIt-Anchor" href="#7-只保留最右边的-1-bit"></a> 7. 只保留最右边的 1-bit</h1><p class='note note-info'>y = x & (-x)</p><p>该方法通过<code>y = x &amp; (-x)</code>实现，将只保留 x 的最右边的 1-bit ，把其他位都置为0。比如对于 01010<strong>1</strong>00 (最右侧 1 用黑体标出)，得到的结果为 00000<strong>1</strong>00。</p><p>这里再给出更多的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01110000  (x)<br>&amp;   10010000  (-x)<br>    --------<br>    00010000<br><br>    00000001  (x)<br>&amp;   11111111  (-x)<br>    --------<br>    00000001<br><br>    10000000  (x = -128)<br>&amp;   10000000  (-x = -128)<br>    --------<br>    10000000<br><br>    11111111  (x = all bits one)<br>&amp;   00000001  (-x)<br>    --------<br>    00000001<br><br>    00000000  (x = all bits 0, no rightmost 1-bit)<br>&amp;   00000000  (-x)<br>    --------<br>    00000000<br></code></pre></td></tr></table></figure><p><strong>接下来探讨其实现原理。主要就是依赖于在计算机中， -x （对应的负数）跟 ~x+1 （按位取反后加1） 是一样的。</strong></p><p>不妨设 x 最右边的 1-bit 为b<sub>i</sub>，以下标 i 为界，将 b<sub>i</sub> 左侧的 bits 位设为 b<sub>i+1</sub>, …, b<sub>n</sub>，将 b<sub>i</sub> 右侧的所有 bits 位设为 b<sub>i-1</sub>, b<sub>i-2</sub> , … , b<sub>0</sub> （位于右侧的全为 0 ，因为 b<sub>i</sub> 是最右侧的 1 ）。</p><p>现在当我计算 -x ，首先做取反操作 ~x ，也就是将 b<sub>i</sub> 置为0， b<sub>i-1</sub>…b<sub>0</sub> 都置为 1，将 b<sub>i+1</sub> … b<sub>n</sub> 等位进行反转。然后做加 1 操作。因为 b<sub>i-1</sub>…b<sub>0</sub> 都为1，所以加 1 后会想 b<sub>i</sub> 进位（因为 b<sub>i</sub> 是第一个 0 bit ）。</p><p>此时我们不难发现，对于 -x ，b<sub>i+1</sub> … b<sub>n</sub> 等位反转了， b<sub>i</sub> 依然保持不变，b<sub>i-1</sub>…b<sub>0</sub> 也依然全为 0 。所以现在将 x 与 -x 进行 AND-ing 操作，就可以使得 b<sub>i+1</sub> … b<sub>n</sub> 置为 0 ，b<sub>i</sub> 保持 1， b<sub>i-1</sub>…b<sub>0</sub> 也全为 0 。只有一个 bit 保留了下来，就是最右边的 1-bit 。</p><h1 id="8-将最右边-1-bit-右侧的所有低位-bit-置-1"><a class="markdownIt-Anchor" href="#8-将最右边-1-bit-右侧的所有低位-bit-置-1"></a> <strong>8. 将最右边 1-bit 右侧的所有低位 bit 置 1</strong></h1><p class='note note-info'>y = x | (x-1)</p><p>具体实现就是 <code>y = x | (x-1)</code> 。这个翻译过来有点拗口，给个例子就能理解了，给出数 010<strong>1</strong>0000 ，执行后就得到 010<strong>11111</strong>，原来最右边 1-bit 右边的低位都置为1 。接下来看更多的一些例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C#">    10111100  (x)<br>|   10111011  (x-1)<br>    --------<br>    10111111<br><br>    01110111  (x)<br>|   01110110  (x-1)<br>    --------<br>    01110111<br><br>    00000001  (x)<br>|   00000000  (x-1)<br>    --------<br>    00000001<br><br>    10000000  (x = -128)<br>|   01111111  (x-1 = 127)<br>    --------<br>    11111111<br><br>    11111111  (x = -1)<br>|   11111110  (x-1 = -2)<br>    --------<br>    11111111<br><br>    00000000  (x)<br>|   11111111  (x-1)<br>    --------<br>    11111111<br></code></pre></td></tr></table></figure><p>这个方法的实现原理跟方法6很像，所以这里就不再证明了。</p><h1 id="9-保留最右边的-0-bit"><a class="markdownIt-Anchor" href="#9-保留最右边的-0-bit"></a> <strong>9. 保留最右边的 0-bit</strong></h1><p class='note note-info'>y = ~x & (x+1)</p><p>该方法的实现为<code>y = ~x &amp; (x+1)</code> 。该方法与方法7正好相反，它是找到最右侧的 0-bit，将其他位都置为0，将该 bit 置为 1 。距离来说，给定数 10101<strong>0</strong>11，经过处理后的结果为，00000<strong>1</strong>00。再给出更多的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C#">    01110111  (x)<br>    --------<br>    10001000  (~x)<br>&amp;   01111000  (x+1)<br>    --------<br>    00001000<br><br>    00000001  (x)<br>    --------<br>    11111110  (~x)<br>&amp;   00000010  (x+1)<br>    --------<br>    00000010<br><br>    10000000  (x = -128)<br>    --------<br>    01111111  (~x)<br>&amp;   10000001  (x+1)<br>    --------<br>    00000001<br><br>    11111111  (x = no rightmost 0-bit)<br>    --------<br>    00000000  (~x)<br>&amp;   00000000  (x+1)<br>    --------<br>    00000000<br><br>    00000000  (x)<br>    --------<br>    11111111  (~x)<br>&amp;   00000001  (x+1)<br>    --------<br>    00000001<br></code></pre></td></tr></table></figure><p><strong>接下来给出证明</strong>。与之前类似，不妨设最右边的 0-bit 设置为 b<sub>i</sub> ，将 b<sub>i</sub> 左侧的 bits 位设为 b<sub>i+1</sub>, …, b<sub>n</sub>，将 b<sub>i</sub> 右侧的所有 bits 位设为 b<sub>i-1</sub>, b<sub>i-2</sub> , … , b<sub>0</sub> （位于右侧的全为 1 ，因为 b<sub>i</sub> 是最右侧的 0 ）。</p><p>那么对于 ~x 来说，将所有位进行反转，包括最右侧的 0-bit，b<sub>i</sub> 也从 0 变成了 1 。</p><p>对于 x+1 来说，因为 b<sub>i-1</sub>, b<sub>i-2</sub> , … , b<sub>0</sub> 全为1，加 1 之后会向 b<sub>i</sub> 进位，因此 b<sub>i</sub> 也变成了 1，b<sub>i-1</sub>, b<sub>i-2</sub> , … , b<sub>0</sub> 都变成了0，而高位  b<sub>i+1</sub>, …, b<sub>n</sub> 保持不变。</p><p>此时再将 ~x 与 x+1 进行 AND-ing 操作，就只有 b<sub>i</sub> 位保留下来，其他位均为 0 。</p><h1 id="10-将最右侧的-0-bit-置为1"><a class="markdownIt-Anchor" href="#10-将最右侧的-0-bit-置为1"></a> <strong>10. 将最右侧的 0-bit 置为1</strong></h1><p class='note note-info'>y = x | (x+1)</p>该方法实现为 `y = x | (x+1)`。主要就是将最右侧的 0-bit 置为1，例如对于数 10100**0**11 经过运算后，得到结果 10100**1**11。给出更多的例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C#">    10111100  (x)<br>|   10111101  (x+1)<br>    --------<br>    10111101<br><br>    01110111  (x)<br>|   01111000  (x+1)<br>    --------<br>    01111111<br><br>    00000001  (x)<br>|   00000010  (x+1)<br>    --------<br>    00000011<br><br>    10000000  (x = -128)<br>|   10000001  (x+1)<br>    --------<br>    10000001<br><br>    11111111  (x = no rightmost 0-bit)<br>|   00000000  (x+1)<br>    --------<br>    11111111<br><br>    00000000  (x)<br>|   00000001  (x+1)<br>    --------<br>    00000001<br></code></pre></td></tr></table></figure><p>正确性也非常好理解。x+1 的操作将原来 x 的最右侧的 0-bit， b<sub>i</sub> 置为1，b<sub>i-1</sub>, b<sub>i-2</sub> , … , b<sub>0</sub> 都变成了0，而高位  b<sub>i+1</sub>, …, b<sub>n</sub> 保持不变。此时再和 x 做 OR-ing 运算，就可以使得原来 x 的最右侧 0-bit  b<sub>i</sub> 置为 1。</p><h1 id="bonus"><a class="markdownIt-Anchor" href="#bonus"></a> Bonus</h1><p>一个简单的C语言函数，实现打印一个数字的低8位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">int_to_bin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> str[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">7</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>    str[i] = (num&amp;<span class="hljs-number">1</span>)?<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;<br>    num &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>椭圆曲线公钥恢复算法与SM2编程实现</title>
    <link href="/2021/12/13/2021-12/2021-12-13%20%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95%E4%B8%8ESM2%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/12/13/2021-12/2021-12-13%20%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95%E4%B8%8ESM2%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="椭圆曲线公钥恢复算法"><a class="markdownIt-Anchor" href="#椭圆曲线公钥恢复算法"></a> 椭圆曲线公钥恢复算法</h1><p>在以太坊中，交易消息中不包含“from”字段（即交易发起者的地址），这是因为交易发起者的公钥可以直接从ECDSA签名中计算出来。而一旦你有公钥，就可以很容易地计算出对应的地址。恢复签名者公钥的过程称为公钥恢复，对应的算法即为公钥恢复算法。</p><p>接下来描述以太坊中公钥恢复算法的过程。</p><p>首先根据给定 ECDSA签名算法 中计算的值 <strong>r</strong> 和 <strong>s</strong>，我们可以计算得到两个可能的公钥。我们根据签名中的 <strong>x</strong> 坐标 <strong>r</strong> 值计算两个椭圆曲线点 <strong>R</strong> 和 <strong>R’</strong>。对于 r 值，计算它关于 n 的逆元 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">r^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，其中 n 是椭圆曲线的阶数。最后计算 e ，它是消息的散列值。然后可以得到两个可能的公钥：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>1</mn></msub><mo>=</mo><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>s</mi><mi>R</mi><mo>−</mo><mi>e</mi><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_1 = r^{-1} (sR - eG)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>2</mn></msub><mo>=</mo><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>s</mi><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup><mo>−</mo><mi>e</mi><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_2 = r^{-1} (sR&#x27; - eG)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span></span></p><p>其中:</p><ul><li><p>K<sub>1</sub> 和 K<sub>2</sub> 是签名者公钥的两种可能性</p></li><li><p>r<sup>-1</sup>是签名的 r 值的逆元</p></li><li><p>s 是签名的 s 值</p></li><li><p>R 和 R’ 是临时公钥 Q 的两种可能性</p></li><li><p>e 是消息散列的最低位</p></li><li><p>G 是椭圆曲线生成点</p></li></ul><p>为了使计算更有效率，在以太坊交易签名里包括一个前缀值 v，它告诉我们两个可能的R值中哪一个是真正临时的公钥。如果 v 是偶数，那么R是正确的值。如果 v 是奇数，那么选择R’。这样，我们只需要计算R的一个值。这也就是以太坊交易中签名数据的（v, r, s）。</p><h2 id="椭圆曲线上点的压缩"><a class="markdownIt-Anchor" href="#椭圆曲线上点的压缩"></a> 椭圆曲线上点的压缩</h2><p>在上述过程，有一个地方可能还没有解释清楚，那就是为什么一个 x 坐标会对应有两个椭圆曲线上的点？其实这里用到了椭圆曲线上点的压缩和解压缩方法。</p><p>根据椭圆曲线方程，我们只需要知道 x 坐标，就可以通过方程计算出 y 坐标，这样就不用同时保存x，y的值，减少了存储和带宽。但是如果只知道x，带入方程会求出两个y，一正一负，对应两个不同的点，所以还必须有一个标志来区别实际使用的是哪个。在以太坊中就采用了压缩公钥格式，具体格式为：</p><ul><li>前缀02 + x （当y为偶数）</li><li>前缀03 + x （当y为奇数）</li></ul><p>为什么y一定是一奇一偶呢，刚刚不是说一正一负吗？</p><p>假设 y 是方程的一个解，那么 -y 也是方程的一个解，但在模运算的规则下，<code>-y ≡ p - y (mod p)</code>，所以 p-y 也是方程的解，y-p 也是方程的解，但是在mod p 的有限域中，取值范围是[0, p-1]，没有负数，所以 -y 和 y-p 在椭圆曲线上取不到，最终得到就是两个解 y 和 p-y，因为p是大素数，所以 y 和 p-y 一定是一奇一偶。</p><p>在<a href="http://www.oscca.gov.cn/sca/xxgk/2010-12/17/1002386/files/b791a9f908bb4803875ab6aeeb7b4e03.pdf">《SM2椭圆曲线公钥密码算法》</a>中也谈及了椭圆曲线上点的压缩和解压缩方法，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204090.(null)" alt="椭圆曲线上点的压缩与解压缩" /></p><h2 id="椭圆曲线签名过程"><a class="markdownIt-Anchor" href="#椭圆曲线签名过程"></a> 椭圆曲线签名过程</h2><p>在推导椭圆曲线公钥算法之前，还需要先回顾了解下椭圆曲线的签名过程。</p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204793.(null)" alt="椭圆曲线签名过程" style="zoom:67%;" /><ol><li>随机选择一个临时私钥 k 值，范围在 [1, n-1]，其中 n 为椭圆曲线的阶数</li><li>计算临时公钥 kG = (x , y)</li><li>计算 r 值， r = x mod n，如果 r 为0则返回第1步重新选择私钥 k</li><li>计算消息散列值，e = H(m)</li><li>计算 s 值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><msup><mi>k</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>e</mi><mo>+</mo><mi>d</mi><mi>r</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">s = k^{-1} (e + dr) \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span>，其中 d 是签名者的私钥，如果算得 s 为0则返回第一步重新选择 k</li><li>最终得到签名 (r, s)</li></ol><p>对应签名的验证过程如下：</p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204418.(null)" alt="椭圆曲线签名的验证过程" style="zoom:67%;" /><ol><li>检验 r, s 是否满足取值范围 [1, n-1]</li><li>计算消息散列值， e  = H(m)</li><li>计算 s 的逆元，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>=</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">w = s^{-1} \ mod\  n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span></li><li>计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>=</mo><mi>e</mi><mi>w</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mi mathvariant="normal">，</mi><msub><mi>u</mi><mn>2</mn></msub><mo>=</mo><mi>r</mi><mi>w</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">u_1 = ew \ mod \ n，u_2 = rw \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span></li><li>计算 $ X = (x, y) = u_1G + u_2Q$。 其中G是生成元，Q是签名者的公钥。如果X为无穷远点则验签失败。</li><li>计算 v = x mod n</li><li>如果 v = r 则验签成功，否则失败</li></ol><p>椭圆曲线签名和验证的正确性证明如下所示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>≡</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>e</mi><mo>+</mo><mi>d</mi><mi>r</mi><mo stretchy="false">)</mo><mo>≡</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>e</mi><mo>+</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>r</mi><mi>d</mi><mo>≡</mo><mi>w</mi><mi>e</mi><mo>+</mo><mi>w</mi><mi>r</mi><mi>d</mi><mo>≡</mo><msub><mi>u</mi><mn>1</mn></msub><mo>+</mo><msub><mi>u</mi><mn>2</mn></msub><mi>d</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k ≡ s^{-1}(e + dr) ≡ s^{-1}e + s^{-1}rd ≡we + wrd ≡ u_1 + u_2d (mod \ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.947438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>=</mo><msub><mi>u</mi><mn>1</mn></msub><mi>G</mi><mo>+</mo><msub><mi>u</mi><mn>2</mn></msub><mi>Q</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>u</mi><mn>1</mn></msub><mo>+</mo><msub><mi>u</mi><mn>2</mn></msub><mi>d</mi><mo stretchy="false">)</mo><mi>G</mi><mo>=</mo><mi>k</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">X = u_1G + u_2Q = (u_1+u_2d)G = kG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">G</span></span></span></span></span></p><p>即验签时计算的X与签名时的临时公钥是相等的，对应的 x 坐标也相等，所以验签时判断 v 值是否等于 r 值即可。</p><h2 id="椭圆曲线公钥恢复算法推导"><a class="markdownIt-Anchor" href="#椭圆曲线公钥恢复算法推导"></a> 椭圆曲线公钥恢复算法推导</h2><p>好的，前序准备都已经完成，现在来推导公钥恢复算法，这里主要用到了签名过程中的相关计算。</p><p>设临时公钥为R，即R = kG</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><msup><mi>k</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>e</mi><mo>+</mo><mi>d</mi><mi>r</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mspace width="1em"/><mo>⇒</mo><mspace width="1em"/><mi>k</mi><mo>=</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>e</mi><mo>+</mo><mi>d</mi><mi>r</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">s = k^{-1} (e + dr) \ mod \ n  \quad ⇒ \quad k = s^{-1} (e + dr) \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>G</mi><mo>=</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>e</mi><mo>+</mo><mi>d</mi><mi>r</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>G</mi><mspace width="1em"/><mo>⇒</mo><mspace width="1em"/><mi>R</mi><mo>=</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>e</mi><mi>G</mi><mo>+</mo><mi>r</mi><mi>Q</mi><mo stretchy="false">)</mo><mspace width="1em"/><mo>⇒</mo><mspace width="1em"/><mi>Q</mi><mo>=</mo><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>s</mi><mi>R</mi><mo>−</mo><mi>e</mi><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">kG = s^{-1} (e + dr) \ G  \quad ⇒ \quad R = s^{-1}(eG+rQ) \quad ⇒ \quad Q = r^{-1}(sR-eG)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span></span></p><p>因为通过 r 值可以计算逆元 r<sup>-1</sup>，s 值已知，消息散列e和生成元G已知，临时公钥 R 可以通过 r（对应公钥的x坐标）利用椭圆曲线上点的解压缩方法求解，因此公钥 Q 是可以被计算出来的。</p><p>在 <a href="http://www.secg.org/sec1-v2.pdf">椭圆曲线标准</a> 中也描述了普通椭圆曲线公钥恢复算法的实现，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204527.(null)" alt="椭圆曲线标准中定义的公钥恢复算法" /></p><h1 id="sm2公钥恢复算法编程实现"><a class="markdownIt-Anchor" href="#sm2公钥恢复算法编程实现"></a> SM2公钥恢复算法编程实现</h1><p>因为SM2公钥签名算法和以太坊上椭圆曲线的签名算法不太一样，所以需要先了解SM2的签名过程，然后再推导SM2对应的公钥恢复算法。</p><h2 id="sm2签名与验证过程"><a class="markdownIt-Anchor" href="#sm2签名与验证过程"></a> SM2签名与验证过程</h2><p>根据官方的 <a href="http://www.oscca.gov.cn/sca/xxgk/2010-12/17/1002386/files/b791a9f908bb4803875ab6aeeb7b4e03.pdf">SM2 椭圆曲线公钥密码算法</a> 可以找到SM2算法的签名过程。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204885.(null)" alt="SM2签名计算过程" /></p><ul><li>设待签名的消息为M，为了获取消息M的数字签名(r,s)，作为签名者的用户A应实现以下运算步骤：</li></ul><ol><li>置  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><msub><mi>Z</mi><mi>A</mi></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">\overline{M} = Z_A || M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></li><li>计算消息散列值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e = H(\overline{M})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，并将e的数据类型转换为整数</li><li>用随机数发生器产生随机数 k，取值范围 [1, n-1]</li><li>计算椭圆曲线上的点（也就是临时公钥），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">(x_1,y_1) = kG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">G</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">将</mi></mrow><annotation encoding="application/x-tex">，并将</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">将</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>$数据类型转换为整数</li><li>计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mo stretchy="false">(</mo><mi>e</mi><mo>+</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">r = (e+x_1) \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span>，若 r = 0 或 r+k = n 则 返回第3步，重新选择k</li><li>计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msub><mi>d</mi><mi>A</mi></msub><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mo separator="true">⋅</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mi>r</mi><mtext> </mtext><mo separator="true">⋅</mo><mtext> </mtext><msub><mi>d</mi><mi>A</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">s = ((1 + d_A)^{-1} \ · \ (k-r\ ·\ d_A ) ) \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span>，若s = 0 则返回第3步</li><li>将r、s类型转换为字符串，得到消息M的签名(r, s)</li></ol><p>SM2数字签名的算法流程图如下所示。</p><center><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204893.(null)" width="60%" height="60%" align="middle" > </center><p><strong>SM2验证过程</strong></p><ul><li>为了检验收到消息M’及其数字签名(r’,s’)，作为验证者的用户B应实现以下运算步骤：</li></ul><ol><li>检验 r’ 是否在 [1, n-1] 范围内</li><li>检验 s’ 是否在 [1, n-1] 范围内</li><li>置$$\overline{M}’ = Z_A \ || \  M’$$</li><li>计算消息散列值，$$e = H(\overline{M}’)$$，并将e的数据类型转换为整数</li><li>将 r’ , s’ 数据类型转换为整数，计算 $$t = (r’ + s’) \ mod \ n$$</li><li>计算椭圆曲线点 $$(x_1’, y_1’) = [s’]G + [t]P_A$$</li><li>计算$$R = (e’ + x_1’) \ mod \ n$$，检验 R = r’ 是否成立，如果成立则验证通过，否则验证不通过</li></ol><p>SM2数字签名的验证过程如下图所示。</p><center><img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=NDYyZjBkZGZiODc4OWE3Y2E3YTc2YmJlYWIwMTY0OThfa1FUVDVtZzNubmI4bVh4cVd5SzA2OFhoa2xQVW1NWnRfVG9rZW46Ym94Y25OckpUY3E0c3gzRmVSUGh0N1hRbzBjXzE2Mzk0MDQyNTM6MTYzOTQwNzg1M19WNA" width="60%" height="60%" align="middle" > </center><h2 id="sm2公钥恢复算法"><a class="markdownIt-Anchor" href="#sm2公钥恢复算法"></a> SM2公钥恢复算法</h2><p>跟椭圆曲线中方法类似，从SM2签名算法的相关计算中，可以推导出对应的公钥恢复算法 。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msub><mi>d</mi><mi>A</mi></msub><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mo separator="true">⋅</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mi>r</mi><mtext> </mtext><mo separator="true">⋅</mo><mtext> </mtext><msub><mi>d</mi><mi>A</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mspace width="1em"/><mo>⇒</mo></mrow><annotation encoding="application/x-tex">s = ((1 + d_A)^{-1} \ · \ (k-r\ ·\ d_A ) ) \ mod \ n \quad ⇒  </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">⇒</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/><mi>k</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msub><mi>d</mi><mi>A</mi></msub><mo stretchy="false">)</mo><mi>s</mi><mo>+</mo><mi>r</mi><msub><mi>d</mi><mi>A</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><msub><mi>d</mi><mi>A</mi></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">\quad k= (1+d_A)s + rd_A = (s + (s+r)d_A) \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span></span></p><p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>=</mo><mi>k</mi><mi>G</mi><mspace width="1em"/><mspace width="1em"/><mi>t</mi><mo>=</mo><mi>r</mi><mo>+</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">R = kG \quad\quad t = r+s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><msub><mi>d</mi><mi>A</mi></msub><mo stretchy="false">)</mo><mi>G</mi><mspace width="1em"/><mo>⇒</mo><mspace width="1em"/><mi>R</mi><mo>=</mo><mi>s</mi><mi>G</mi><mo>+</mo><mi>t</mi><msub><mi>P</mi><mi>A</mi></msub><mspace width="1em"/><mo>⇒</mo><mspace width="1em"/><msub><mi>P</mi><mi>A</mi></msub><mo>=</mo><msup><mi>t</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mi>s</mi><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">kG = (s+(s+r)d_A)G \quad ⇒ \quad R = sG+tP_A \quad ⇒ \quad P_A = t^{-1}(R-sG)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span></span></p><p>因为r，s值可以计算得到t，进而得到t的逆元 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>t</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">t^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，R 可以通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mi>r</mi><mo>−</mo><mi>e</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">x_1 = r - e \ mod \ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span>，并利用椭圆曲线的压缩方法计算得到。s和G也都已知，因此，是可以计算得到公钥<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">P_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><h2 id="代码结构说明"><a class="markdownIt-Anchor" href="#代码结构说明"></a> 代码结构说明</h2><center><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204132.(null)" width="30%" height="30%" align="middle" > </center>附件代码结构如上图所示：<ul><li>cryptopp：该目录是开源库CryptoPP 的文件目录</li><li>test：测试文件目录，存放测试类TestCrypto，主要测试CryptoPP的相关API，模拟椭圆曲线的签名、验证以及公钥恢复算法；还有就是测试自定义实现的SM2 的签名、验证以及公钥恢复算法</li><li>util：该目录下，util类是cryptopp方法的封装，SM2是自定义实现类</li><li>main.cpp：实现测试函数</li></ul><h2 id="编程实现说明"><a class="markdownIt-Anchor" href="#编程实现说明"></a> 编程实现说明</h2><p>当了解了算法原理之后，实现起来就比较容易了，只要根据公式进行编程即可。在实现上借助了开源的CryptoPP库，来支持密码学里中原语操作，比如有限域上的计算，椭圆曲线上点的运算等。代码上主要是实现了一个<code>SM2</code>类，定义了签名，验证和公钥恢复算法，具体的代码实现这里不再展示，可见代码附件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 借助CryptoPP开源库 实现 SM2算法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SM2</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 签名：输入的消息和输出的签名数据  均为字节格式，签名是由(r,s)各32字节拼接得到的</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sign</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;message, std::string &amp;signature)</span></span>;<br>    <span class="hljs-comment">// 验证：输入的消息和签名均为字节格式，输出为bool值</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Verify</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;message, <span class="hljs-keyword">const</span> std::string &amp;signature)</span></span>;<br>    <span class="hljs-comment">// 公钥恢复算法，输入消息，签名（r,s），y值是否为奇数， 输出pubKey 字节格式，由(x,y) 各32字节拼接而成</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RecoverPublicKey</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;message, <span class="hljs-keyword">bool</span> isOdd,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-keyword">const</span> Integer &amp;r, <span class="hljs-keyword">const</span> Integer &amp;s, std::string &amp;pubKey)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">private</span>:</span><br><span class="hljs-function">    std::shared_ptr&lt;ECP&gt; ecp;</span>                   <span class="hljs-comment">// SM2 对应的椭圆曲线</span><br>    std::shared_ptr&lt;Integer&gt; p;<br>    std::shared_ptr&lt;Integer&gt; a;<br>    std::shared_ptr&lt;Integer&gt; b;<br>    std::shared_ptr&lt;Integer&gt; privateKey;        <span class="hljs-comment">// 私钥</span><br>    std::shared_ptr&lt;ECPPoint&gt; publicKey;        <span class="hljs-comment">// 公钥，以Point表示</span><br>    std::shared_ptr&lt;ECPPoint&gt; generator;        <span class="hljs-comment">// 生成元 点</span><br>    std::shared_ptr&lt;Integer&gt; n;                 <span class="hljs-comment">// 生成元 对应的阶数</span><br>    std::string ZA;                             <span class="hljs-comment">// 杂凑值，字节形式 ：ZA = H256(ENTL_A ∥ ID_A ∥ a ∥ b ∥ xG ∥ yG ∥ xA ∥ yA)</span><br><br>    <span class="hljs-comment">// 默认构造函数，使用官方参数</span><br>    <span class="hljs-built_in">SM2</span>();<br>    <span class="hljs-comment">// 初始化曲线参数，使用官方参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 计算杂凑值 ZA</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ComputeZA</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>测试代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 测试 SM2 类</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TestCrypto::Test_SM2</span><span class="hljs-params">()</span> </span>&#123;<br>    SM2 sm2;<br>    std::string message = <span class="hljs-string">&quot;message digest&quot;</span>;<br>    std::string signature;<br>    Integer k = Util::<span class="hljs-built_in">StringToInteger</span>(<span class="hljs-string">&quot;59276E27D506861A16680F3AD9C02DCCEF3CC1FA3CDBE4CE6D54B80DEAC1BC21&quot;</span>);<br>    sm2.<span class="hljs-built_in">Sign</span>(message, signature, k);<br><br>    Integer r = Util::<span class="hljs-built_in">StringToInteger</span>(Util::<span class="hljs-built_in">HexEncode</span>(signature.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>)));<br>    Integer s = Util::<span class="hljs-built_in">StringToInteger</span>(Util::<span class="hljs-built_in">HexEncode</span>(signature.<span class="hljs-built_in">substr</span>(<span class="hljs-number">32</span>,<span class="hljs-number">32</span>)));<br><br>    <span class="hljs-comment">// 打印输出，对照真实数据</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————————测试SM2 签名算法——————————————&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;真实 r:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;F5A03B0648D2C4630EEAC513E1BB81A15944DA3827D5B74143AC7EACEEE720B3&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;计算 r:&quot;</span> &lt;&lt; Util::<span class="hljs-built_in">HexEncode</span>(signature.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>)) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;真实 s:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;B1B6AA29DF212FD8763182BC0D421CA1BB9038FD1F7F42D4840B69C485BBC1AA&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;计算 s:&quot;</span> &lt;&lt; Util::<span class="hljs-built_in">HexEncode</span>(signature.<span class="hljs-built_in">substr</span>(<span class="hljs-number">32</span>,<span class="hljs-number">32</span>)) &lt;&lt; endl;<br><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————————测试SM2 验证签名——————————————&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;message: &quot;</span> &lt;&lt; message &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;r: &quot;</span> &lt;&lt; Util::<span class="hljs-built_in">IntegerToString</span>(r) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;s: &quot;</span> &lt;&lt; Util::<span class="hljs-built_in">IntegerToString</span>(s) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;签名验证结果: &quot;</span> &lt;&lt; boolalpha &lt;&lt; sm2.<span class="hljs-built_in">Verify</span>(message, signature ) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;——————————————测试SM2 公钥恢复算法——————————————&quot;</span> &lt;&lt; endl;<br><br>    std::string pubKey;<br>    sm2.<span class="hljs-built_in">RecoverPublicKey</span>(message,<span class="hljs-literal">false</span>, r, s,pubKey);<br>    <span class="hljs-function">ECP::Point <span class="hljs-title">P</span><span class="hljs-params">(Util::StringToInteger(Util::HexEncode(pubKey.substr(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>))),</span></span><br><span class="hljs-params"><span class="hljs-function">                 Util::StringToInteger(Util::HexEncode(pubKey.substr(<span class="hljs-number">32</span>,<span class="hljs-number">32</span>))))</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;真实公钥 P.x:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;09F9DF311E5421A150DD7D161E4BC5C672179FAD1833FC076BB08FF356F35020&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;恢复公钥 P.x:&quot;</span> &lt;&lt; Util::<span class="hljs-built_in">IntegerToString</span>(P.x) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;真实公钥 P.y:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;CCEA490CE26775A52DC6EA718CC1AA600AED05FBF35E084A6632F6072DA9AD13&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;恢复公钥 P.y:&quot;</span> &lt;&lt; Util::<span class="hljs-built_in">IntegerToString</span>(P.y) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试数据来自：<a href="https://blog.csdn.net/beebeeyoung/article/details/91063358">SM2 自检数据</a></p><p>测试结果如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202112132204273.(null)" alt="测试结果输出" /></p><p class="note note-primary">代码上传至Github仓库：https://github.com/2017zhangyuxuan/Learn-Blockchain</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p><a href="http://www.oscca.gov.cn/sca/xxgk/2010-12/17/1002386/files/b791a9f908bb4803875ab6aeeb7b4e03.pdf">SM2 椭圆曲线公钥密码算法</a></p><p><a href="https://blog.csdn.net/beebeeyoung/article/details/91063358">SM2 自检数据</a></p><p><a href="http://www.gmbz.org.cn/main/viewfile/2018010802371372251.html">SM2 官方参数定义</a></p><p><a href="https://github.com/inoutcode/ethereum_book/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0.asciidoc#%E7%AD%BE%E5%90%8D%E5%89%8D%E7%BC%80%E5%80%BCv%E5%92%8C%E5%85%AC%E9%92%A5%E6%81%A2%E5%A4%8D">以太坊：签名前缀值（v）和公钥恢复</a></p><p><a href="https://www.cryptopp.com/docs/ref/class_integer.html">CryptoPP 官方文档</a></p><p><a href="http://www.secg.org/sec1-v2.pdf">椭圆曲线标准</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SM2</tag>
      
      <tag>椭圆曲线密码算法</tag>
      
      <tag>公钥恢复算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题04】椭圆曲线密码算法在比特币中的应用</title>
    <link href="/2021/11/27/2021-11/2021-11-27%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9804-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E5%9C%A8%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2021/11/27/2021-11/2021-11-27%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9804-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E5%9C%A8%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li>不同于以太坊的账户模型，比特币采用的是UTXO模型，比特币的所有权是通过<em>数字密钥、比特币地址和数字签名</em>来确定的。数字密钥实际上并不存储在网络中，而是由用户生成之后，存储在一个叫做<em>钱包</em>的文件或简单的数据库中。用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问互联网。</li><li>密钥是成对出现的，由私钥和公钥所组成。公钥就像银行的帐号，而私钥就像银行卡的密码或支票的签名。比特币的用户很少会直接看到数字密钥。一般情况下，它们存储在钱包文件内，由比特币钱包软件进行管理。</li><li>在比特币交易的支付环节，收款人的公钥由数字指纹表示，称为<em>比特币地址</em>，就像支票上收款人名称 （即“付给谁的账户”）。一般情况下，比特币地址由公钥生成并与之对应。然而，并非所有比特币地址都代表公钥； 也可以代表其他支付对象，譬如脚本。这样一来，比特币地址就可以抽象成资金接收者，使得交易更灵活，就像纸质支票：可以支付到个人账户或公司账户，也可以支付账单和现金。比特币地址是密钥被用户能够看到的唯一形式，因为这个地址就是需要告诉别人的。</li><li>以上是对比特币和密码学应用的简单概述，而本篇文章将重点关注椭圆曲线密码算法在比特币中的应用，将从与之密切相关的密钥与地址、钱包、交易三部分介绍相关内容。</li></ul><h1 id="密钥与地址"><a class="markdownIt-Anchor" href="#密钥与地址"></a> 密钥与地址</h1><ul><li>在比特币系统中，我们用公钥密码学技术创建一个密钥对，用于控制对比特币的访问。密钥对包括一个私钥，和由其衍生出的唯一的公钥。公钥用于接收比特币，而私钥用于支付时进行交易签名。</li><li>比特币正是使用椭圆曲线密码算法作为其公钥密码学的基础。</li></ul><h2 id="私钥与公钥与地址"><a class="markdownIt-Anchor" href="#私钥与公钥与地址"></a> 私钥与公钥与地址</h2><p>一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。私钥（<em>k</em>）是一个数字，通常是随机选出的。基于私钥，我们就可以使用椭圆曲线乘法这个单向密码函数产生一个公钥（<em>K</em>）。基于公钥（<em>K</em>），我们就可以使用一个单向密码哈希函数生成比特币地址（<em>A</em>）。私钥、公钥和比特币地址之间的关系如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271547812.(null)" alt="私钥、公钥和比特币地址之间的关系" /></p><h2 id="私钥"><a class="markdownIt-Anchor" href="#私钥"></a> 私钥</h2><ul><li><p>私钥就是一个随机选出的数字而已。拥有和控制了私钥，就相当于控制了该私钥对应的比特币地址中的所有资金。通过证明比特币交易中资金的所有权，私钥可以生成花费该笔资金的签名。</p></li><li><p><em><strong>从一个随机数生成私钥</strong></em> 是生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源。生成一个比特币私钥在本质上与“在1到2<sup>256</sup>之间选一个数字”无异。只要选取的结果是不可预测或不可重复的，那么选取数字的具体方法并不重要。比特币软件使用操作系统底层的随机数生成器来产生256位的熵（随机性）。</p></li><li><p>更准确地说，私钥可以是1和n-1之间的任何数字，其中n是一个常数（n=1.158 * 10<sup>77</sup>，略小于2<sup>256</sup>），并被定义为由比特币所使用的椭圆曲线的阶（比特币使用的是 <strong>secp256k1</strong> 标准所定义的一种特殊的椭圆曲线和一系列数学常数。该标准由美国国家标准与技术研究院 （NIST）建立）。要生成这样的一个私钥，我们随机选择一个256位的数字，并检查它是否小于n-1。从编程的角度来看，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。如果运算结果小于n，我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。</p></li><li><h2 id="公钥"><a class="markdownIt-Anchor" href="#公钥"></a> 公钥</h2></li></ul><p>以一个随机生成的私钥<em>k</em>为起点，将其乘以曲线上一个预定的点，叫做<em>生成点G</em>得到曲线上的另一点，这就是相应的公钥 <em>K</em>。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>=</mo><mi>k</mi><mo>∗</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">K = k * G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span></span></p><p>其中<em>k</em>是私钥，<em>G</em>是生成点，在该曲线上所得的点<em>K</em>是公钥。因为所有比特币用户的生成点是相同的，一个私钥<em>k</em>乘以<em>G</em>将得到相同的公钥<em>K</em>。<em>k</em>和<em>K</em>之间的关系是固定的，但只能单向运算，即从<em>k</em>得到<em>K</em>。这就是可以把比特币地址（<em>K</em>的衍生） 与任何人共享而不会泄露私钥（<em>k</em>）的原因。</p><p>实现了椭圆曲线乘法，我们就可以用随机产生的私钥<em>k</em>和与生成点<em>G</em>相乘得到公钥<em>K</em>。下面给出一个简单例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash">k = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD <br>K = k * G<br><br>公钥K被定义为一个点 K = (x, y) ，其中：<br>x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A <br>y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB<br></code></pre></td></tr></table></figure><h2 id="比特币地址"><a class="markdownIt-Anchor" href="#比特币地址"></a> 比特币地址</h2><p>比特币地址可由公钥经过单向哈希算法得到。密码学哈希算法是一种单向函数，接收任意长度的输入产生指纹或哈希。哈希函数在比特币中被广泛使用 ：比特币地址、脚本地址以及在挖矿中的工作量证明算法。由公钥生成比特币地址时使用的算法是Secure Hash Algorithm (SHA)和the RACE Integ rity Primitives Evaluation Message Digest (RIPEMD)，具体来说是SHA256和RIPEMD160。</p><p>以公钥 <em>K</em> 为输入，计算其SHA256哈希值，并以此结果计算RIPEMD160 哈希值，得到一个长度为160位（20字节）的数字：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>R</mi><mi>I</mi><mi>P</mi><mi>E</mi><mi>M</mi><mi>D</mi><mn>160</mn><mo stretchy="false">(</mo><mi>S</mi><mi>H</mi><mi>A</mi><mn>256</mn><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A = RIPEMD160(SHA256(K))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">1</span><span class="mord">6</span><span class="mord">0</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">A</span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p>公式中，<em>K</em>是公钥，<em>A</em>是生成的比特币地址。</p><p>通常用户见到的比特币地址是经过“<strong>Base58Check</strong>”编码的（参见下面的“Base58Check Encoding”一图），这种编码使用了58个字符（Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。Base58Check编码也被用于比特币的其它地方，例如比特币地址、私钥、加密的密钥和脚本哈希中，用来提高可读性和录入的正确性。</p><center class="half"> <img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271513682.(null)" width="300"></img><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271513117.(null)" width="400"></img></center><hr /><ul><li><strong>WIF(Wallet import format)</strong> 钱包导入格式，(也被称为电子钱包的导出格式)是一种私有的 ESCDSA (椭圆曲线签名算法) 秘钥，意在使私钥更容易复制，私钥的各种形式如下表所示。</li></ul><table><thead><tr><th>Type</th><th>Prefix</th><th>Description</th></tr></thead><tbody><tr><td>Raw</td><td>None</td><td>32字节</td></tr><tr><td>Hex</td><td>None</td><td>64位Hex编码</td></tr><tr><td>WIF</td><td>5</td><td>使用Base58Check进行编码</td></tr><tr><td>WIF-compressed</td><td>K or L</td><td>使用Base58Check进行编码，但在编码前增加后缀0x01</td></tr></tbody></table><table><thead><tr><th style="text-align:left">Format</th><th>Private key</th></tr></thead><tbody><tr><td style="text-align:left">Hex</td><td>1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</td></tr><tr><td style="text-align:left">WIF</td><td>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</td></tr><tr><td style="text-align:left">WIF-compressed</td><td>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</td></tr></tbody></table><ul><li>公钥也可以用多种不同格式来表示，通常分为非压缩格式或压缩格式公钥这两种形式。</li><li>我们从前文可知，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256位的数字。其中一个256位数字是公钥的x坐标，另一个256位数字是y坐标。前缀04是是非压缩格式公钥， 压缩格式公钥是以02或者03开头。</li><li>正如前面所说，一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程来得到y坐标。这可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256位。这样每笔交易需要的字节数就会减少许多，随着时间推移，就能保存更多的交易数据。</li><li>未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。为什么会有两个前缀：当<strong>我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是偶数或者奇数</strong>。因此，为了区分y坐标的两种可能值，在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以让软件能够根据x坐标，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上点的完整坐标。下图阐释了公钥压缩的过程：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271547830.(null)"  height="50%" width="50%" align="center"> </img></p><p class="note note-primary"> 注意：实际上“压缩格式私钥”是一种名称上的误导，因为当私钥使用WIF压缩格式导出时，不但没有压缩，反而比“非压缩格式”私钥长出一个字节。这个多出来的一个字节是私钥被加了后缀01，用以表明该私钥是来自于一个较新的钱包，只能被用来生成压缩公钥。私钥并没有压缩的，也不能被压缩。“压缩私钥”实际上表示“只能生成压缩公钥的私钥”，而“非压缩私钥”用来表明“只能生成非压缩公钥的私钥”。为避免更多误解，应该只可以说导出格式 是“WIF压缩格式”或者“WIF”，而不能说这个私钥是“压缩”的。</p><h1 id="钱包"><a class="markdownIt-Anchor" href="#钱包"></a> 钱包</h1><ul><li>广义上，钱包是一个应用程序，为用户提供交互界面。钱包控制用户资金访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。</li><li>狭义上，“钱包”是指用于存储和管理用户密钥的数据结构。</li><li>在这一小节中，我们将更关注钱包是密钥容器的这一角度，探索椭圆曲线算法在其中的应用。</li></ul><h2 id="hd分层钱包"><a class="markdownIt-Anchor" href="#hd分层钱包"></a> HD分层钱包</h2><p>根据钱包包含的多个密钥之间是否有关系，主要分为两种类型：</p><ul><li><p>第一种类型是<em>非确定性钱包（nondeterministic wallet）</em>，其中每个密钥都是从随机数独立生成的。密钥彼此无关。</p></li><li><p>第二种类型是确定性钱包（deterministic wallet），其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包中使用了许多不同的密钥推导方法。最常用的推导方法是使用树状结构，称为分层确定性（hierarchical deterministic）钱包或HD钱包。</p><ul><li>相比随机（不确定性）密钥，HD钱包有两个主要的优势。第一，树状结构可以被用来表达附加的组织含义，比如子密钥的特定分支用来接收交易收入款项，另一个分支用来负责接收对外付款的找零。密钥的分支也可以用于公司设置，将不同的分支分配给部门、子公司、特定功能或会计类别。</li><li>HD钱包的第二个好处是，用户可以创建一系列公钥，而不需要访问对应的私钥。这样，HD钱包就能用在不安全的服务器上，或者仅作为接收用途，它为每个交易发布不同的公钥。公钥不需要被预先加载或者提前衍生，服务器也不需要有用来支付的私钥。</li></ul></li></ul><hr /><p>HD钱包密钥的生成过程如下图所示：通过记助词和 Salt 生成Root Seed种子，再通过HMAC-SHA512（单向哈希），输出512位bits，其中左256位作为主私钥（通过椭圆曲线密码算法可生成主公钥，采用的是压缩公钥格式264bits），右256位作为主链码。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271513500.(null)" width="70%" height="70%" alight="center"> </img></p><blockquote><p>HD钱包的种子生成过程，并没有涉及椭圆曲线密码算法，因此这里不再展开介绍，具体过程可参考：<br /><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch05.md#523-%E4%BB%8E%E5%8A%A9%E8%AE%B0%E8%AF%8D%E7%94%9F%E6%88%90%E7%A7%8D%E5%AD%90">HD分层钱包 种子生成过程</a></p></blockquote><h2 id="衍生子秘钥"><a class="markdownIt-Anchor" href="#衍生子秘钥"></a> 衍生子秘钥</h2><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271513760.(null)" width="60%" height="60%" aligh="center"> </img></p><ul><li>子秘钥的衍生推导如上图所示：父公钥 + 父链码 + 索引作为输入， 输出512bits，右256bits作为子链码；左256bits 与 父秘钥结合得到子秘钥</li><li>衍生得到的子私钥，推断不出兄弟姐妹的私钥；如果没有子链码，也无法推断出孙密钥</li><li>可以得到如下的推导公式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">child_private_key == (parent_private_key + lefthand_hash_output) % G<br>child_public_key  == point( (parent_private_key + lefthand_hash_output) % G )<br>child_public_key  == point(child_private_key) == parent_public_key + point(lefthand_hash_output)<br></code></pre></td></tr></table></figure><ul><li><p>可以看到，子公钥的推导有两种方式，一个是通过私钥推导，一个是直接通过公钥推导</p></li><li><p>正如我们之前看到的，密钥衍生函数可以被用来创造密钥树上任何层级的子密钥，基于以下三个输入量：密钥，链码以及想要的子密钥的索引。</p><p>密钥以及链码这两个重要的部分被结合之后，就叫做</p><p><em>扩展密钥（extended key）</em></p><p>。术语“扩展密钥”也被认为是“可扩展的密钥”，因为这种密钥可以用来衍生子密钥。</p><ul><li>扩展密钥编码用的 Base58Check使用特殊的版本号，Base58编码字符前缀分别为“xprv”和“xpub”</li></ul></li></ul><center class="half"> <img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271513936.(null)" width="300"></img><img src="https://kwaj2xdt3y.feishu.cn/space/api/box/stream/download/asynccode/?code=MDYwZjYzODI5NTFjOThiYTQ3MzZiM2JhMjAyNWIxNTBfazRleGFLaGlDbFVMOHlsZzllb01uelhQVkJ3SUo5RnJfVG9rZW46Ym94Y256d2Z4M2ZhWWR1NDZmeEtiV2hJOHRlXzE2Mzc5OTcyMDk6MTYzODAwMDgwOV9WNA" width="300"></img></center><ul><li>上面左图为常规衍生，直接使用父公钥衍生子公钥，这样推导的好处就是不用访问私钥，就能衍生扩展出子公钥，用于收款，可以用在安全性较弱的web服务器上<ul><li>但是这种常规的扩展方式存在的问题是，当一个攻击者得到父公钥和对应的链码时，他可以衍生扩展出之后所有的子公钥和对应链码，如果此时再获得子私钥，那么就可以推导出这个子私钥之后所有的私钥（孙私钥等），甚至可能会推导出父私钥</li></ul></li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">child_private_key == <span class="hljs-comment">(parent_private_key + lefthand_hash_output)</span> <span class="hljs-meta">%</span> G<br></code></pre></td></tr></table></figure><ul><li>右图为强化衍生，不使用父公钥，直接用父私钥 + 父链码 + 索引 作为输入，得到输出（这样就算子公钥和子链码暴露了，也不能推导出父私钥）<ul><li>简单来说，如果想利用xpub的便捷来衍生公钥的分支，又不想冒泄露链码的风险， 就该从强化父密钥，而不是常规父密钥衍生。最好的方式是，为了避免主密钥泄露，主密钥所衍生的第一层级的子密钥总是通过强化衍生得来。</li></ul></li></ul><h1 id="交易"><a class="markdownIt-Anchor" href="#交易"></a> 交易</h1><ul><li>比特币交易是比特币系统中最重要的部分。比特币中的其他一切都是为了确保交易可以被创建、在网络上传播、验证，并最终添加到全局交易分类账本（区块链）中。比特币交易的本质是数据结构，这些数据结构是对比特币交易参与者价值传递的编码。比特币区块链是一本全局复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。</li><li>交易主要的功能就是实现比特币的转移，而其实现过程就用到了密码学技术。支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名（每次交易的签名都不同，但都由同一个私钥生成）。针对展示的公钥和签名，比特币网络中的所有人都可以验证该交易有效并予以接受，从而确认支付者对该交易中的比特币的所有权。</li><li>这一小节中，将介绍交易的基本数据结构，关注比特币交易过程的实现，并聚焦密码学技术的使用。</li></ul><h2 id="交易的输出"><a class="markdownIt-Anchor" href="#交易的输出"></a> 交易的输出</h2><p>每一笔比特币交易都会创造输出，并被比特币正本记录下来。几乎所有的输出，除了一个例外（见“数据输出操作符”（OP_RETURN）），都能创造称为UTXO的比特币块，然后被整个网络识别，供所有者在未来交易中使用。</p><p>交易输出包含两部分：</p><ul><li><p>一定量的比特币，面值为“聪”（satoshis） ，是最小的比特币单位；</p></li><li><p>确定花费输出所需条件的加密难题（cryptographic puzzle），这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥 (scriptPubKey)。</p><ul><li>只有出示对应的解锁脚本，成功执行锁定脚本（相当于进行签名验证的过程），才能花费这笔输出</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-string">&quot;vout&quot;</span>: [<br>  &#123;<br>    <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-number">0.01500000</span>,<br>    <span class="hljs-attr">&quot;scriptPubKey&quot;</span>: <span class="hljs-string">&quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-number">0.08450000</span>,<br>    <span class="hljs-attr">&quot;scriptPubKey&quot;</span>: <span class="hljs-string">&quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot;</span>,<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><h2 id="交易的输入"><a class="markdownIt-Anchor" href="#交易的输入"></a> 交易的输入</h2><p>交易的输入包含四个元素：</p><ul><li><p>一个交易ID，引用包含将要消费的UTXO的交易</p></li><li><p>一个输出索引（vout），用于标识来自该交易的哪个UTXO被引用（第一个为零）</p></li><li><p>一个 scriptSig（解锁脚本），满足UTXO的消费条件，解锁用于支出</p></li><li><p>一个序列号，用于指定这笔输入的生效时间</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-string">&quot;vin&quot;</span>: [<br>  &#123;<br>    <span class="hljs-attr">&quot;txid&quot;</span>: <span class="hljs-string">&quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;</span>,<br>    <span class="hljs-attr">&quot;vout&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;scriptSig&quot;</span> : <span class="hljs-string">&quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;</span>,<br>    <span class="hljs-attr">&quot;sequence&quot;</span>: <span class="hljs-number">4294967295</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><h2 id="数字签名"><a class="markdownIt-Anchor" href="#数字签名"></a> 数字签名</h2><p>在上述交易的输入中提到了一个关键元素解锁脚本，实际上这就是应用了椭圆曲线密码算法的数字签名。在比特币的ECDSA算法的实现中，被签名的“消息”是交易，或更确切地说是交易中特定数据子集的哈希值。签名密钥是用户的私钥，结果就是签名：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>i</mi><mi>g</mi><mo>=</mo><msub><mi>F</mi><mrow><mi>s</mi><mi>i</mi><mi>g</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>F</mi><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi></mrow></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>d</mi><mi>A</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sig = F_{sig}(F_{hash}(m),  d_A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><ul><li><p><em>dA</em> 是签名私钥</p></li><li><p><em>m</em> 是交易（或其部分数据）</p></li><li><p><em>Fhash</em> 是散列函数</p></li><li><p><em>Fsig</em> 是签名算法</p></li><li><p><em>Sig</em> 是结果签名</p></li></ul><p>函数<em>Fsig</em> 产生由两个值组成的签名Sig，通常称为R和S：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>i</mi><mi>g</mi><mo>=</mo><mi mathvariant="normal">（</mi><mi>R</mi><mi mathvariant="normal">，</mi><mi>S</mi><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">Sig = （R，S）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">）</span></span></span></span></span></p><p>现在已经计算了两个值R和S，它们就使用一种称为<em>可分辨编码规则Distinguished Encoding Rules</em>或<em>DER</em>的国际标准编码方案，序列化为字节流，正如我们在交易输入的JSON字符串中看到的那样。</p><hr /><p><strong>签名序列化（DER）</strong></p><p>我们再来之前在交易输入中展示的一个解锁脚本，其中以下DER编码签名：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">3045022100884</span>d<span class="hljs-number">142</span>d<span class="hljs-number">86652</span>a<span class="hljs-number">3</span>f<span class="hljs-number">47</span>ba<span class="hljs-number">4746</span>ec<span class="hljs-number">719</span>bbfbd<span class="hljs-number">040</span>a<span class="hljs-number">570</span>b<span class="hljs-number">1</span>deccbb<span class="hljs-number">6498</span><span class="hljs-keyword">c</span><span class="hljs-number">75</span><span class="hljs-keyword">c</span><span class="hljs-number">4</span>ae<span class="hljs-number">24</span>cb<span class="hljs-number">02204</span>b<span class="hljs-number">9</span>f<span class="hljs-number">039</span>ff<span class="hljs-number">08</span>df<span class="hljs-number">09</span>cbe<span class="hljs-number">9</span>f<span class="hljs-number">6</span>addac<span class="hljs-number">960298</span>cad<span class="hljs-number">530</span>a<span class="hljs-number">863</span>ea<span class="hljs-number">8</span>f<span class="hljs-number">53982</span><span class="hljs-keyword">c</span><span class="hljs-number">09</span>db<span class="hljs-number">8</span>f<span class="hljs-number">6e381301</span><br></code></pre></td></tr></table></figure><p>该签名是用户钱包生成的R和S值的序列化字节流，证明对应用户拥有授权花费该输出的私钥。 序列化格式包含以下9个元素：</p><ul><li><p><em>0x30</em>表示DER序列的开始</p></li><li><p><em>0x45</em> - 序列的长度（69字节）</p></li><li><p><em>0x02</em> - 一个整数值</p></li><li><p><em>0x21</em> - 整数的长度（33字节）</p></li><li><p><em>00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb</em> - R值</p></li><li><p><em>0x02</em> - 接下来是一个整数</p></li><li><p><em>0x20</em> - 整数的长度（32字节）</p></li><li><p><em>4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813</em> - S值</p></li><li><p>后缀（<em>0x01</em>）指示使用的哈希的类型（SIGHASH_ALL）</p></li></ul><hr /><p><strong>验证签名</strong></p><ul><li>要验证签名，必须有签名（<em>R</em>和<em>S</em>）、序列化交易和公钥（对应于用于创建签名的私钥）。本质上，签名的验证意味着“只有生成此公钥的私钥的所有者，才能在此交易上产生此签名。”</li><li>签名验证算法采用消息（交易或其部分的哈希值）、签名者的公钥和签名（R和S值），如果签名对该消息和公钥有效，则返回 TRUE 值。</li></ul><h2 id="交易脚本"><a class="markdownIt-Anchor" href="#交易脚本"></a> 交易脚本</h2><p>正如之前内容提到的，锁定脚本和解锁脚本正是组成数字签名和签名验证过程的关键数据。</p><ul><li>锁定脚本：锁定脚本是一个放置在交易输出上面的花费条件——它指定了今后花费这笔输出必须要满足的条件。 由于锁定脚本往往含有一个公钥或比特币地址（公钥哈希值），在历史上它曾被称为<em>脚本公钥scriptPubKey</em>。</li><li>解锁脚本：解锁脚本是这样一个脚本，它“解决”或满足由锁定脚本放置在输出上的条件，并允许使用输出。解锁脚本是每一笔比特币交易输入的一部分，而且往往含有一个由用户的比特币钱包（通过用户的私钥）生成的数字签名。由于解锁脚本常常包含一个数字签名，因此它曾被称作<em>脚本签名ScriptSig</em>。</li><li>当结合锁定脚本和解锁脚本，在堆栈中执行脚本，如果堆栈中最后剩余的结果为“TRUE”，表明解锁脚本中签名跟锁定脚本中的公钥哈希是相匹配的，即用于签名的私钥跟公钥是匹配的。其中，签名验证的这个验证操作正是锁定脚本中 “<strong>OP_CHECKSIG</strong>” 所执行的，即比对消息（交易或其部分的哈希值）、签名者的公钥和签名（R和S值）。</li></ul><hr /><p><strong>脚本执行</strong></p><ul><li>在最初版本的比特币客户端中，解锁脚本和锁定脚本按顺序连起来执行。出于安全因素考虑，在2010年发生了改变，因为存在一个漏洞，允许格式错误的解锁脚本将数据推送到堆栈并损坏锁定脚本。而在当前的方案中，脚本是单独执行的，在两次执行之间传输堆栈，如下所述。<ul><li>首先，使用堆栈执行引擎执行解锁脚本。如果解锁脚本在执行过程中未报错（例如：没有留下“dangling”操作码），则复制主堆栈，并执行锁定脚本。如果从解锁脚本中复制而来的堆栈数据执行锁定脚本的结果为“TRUE&quot;，那么解锁脚本就成功地满足了锁定脚本所设置的条件，因此，该输入是一个能使用该UTXO的有效授权。如果合并脚本执行后的结果是”TRUE“以外的任何结果，输入都是无效的，因为它不能满足UTXO中所设置的使用该笔资金的条件。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111271513603.(null)" alt="结合scriptSig和scriptPubKey执行脚本" /></p><p class="note note-info"> 具体脚本在堆栈中的执行过程，可参考：<a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch06.md#644-p2pkhpay-to-public-key-hash">P2PKH 脚本执行流程</a></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>比特币系统中大量使用了密码学技术，例如使用椭圆曲线密码算法生成密钥和公钥，以及交易中的数字签名和验证，确保比特币的所有者在进行转账操作。密码学实现了比特币的许多有趣特性，包括去中心化信任和控制、所有权认证和基于密码学证明的安全模型。可以说，密码学是比特币实现的一大基石。</p><p class="note note-success"> 更多比特币知识可参考我的这个Github项目：<a href="https://github.com/2017zhangyuxuan/Learn-Blockchain">比特币系统 C++ 实现</a></p><h1 id="参考资料附录"><a class="markdownIt-Anchor" href="#参考资料附录"></a> 参考资料附录</h1><p><a href="https://github.com/tianmingyun/MasterBitcoin2CN">《精通比特币》中文电子书</a></p><p><a href="https://zhuanlan.zhihu.com/p/21298725">比特币（地址、私钥）压缩与非压缩的区别</a></p><p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch05.md#523-%E4%BB%8E%E5%8A%A9%E8%AE%B0%E8%AF%8D%E7%94%9F%E6%88%90%E7%A7%8D%E5%AD%90">HD分层钱包 种子生成过程</a></p><p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch06.md#644-p2pkhpay-to-public-key-hash">P2PKH 脚本执行流程</a></p><p><a href="https://bitcoin.stackexchange.com/questions/72657/signature-verification-in-python-using-compressed-public-key">Signature verification in python using compressed public key</a></p><p><a href="https://medium.com/@bitaps.com/exploring-bitcoin-signing-the-p2pkh-input-b8b4d5c4809c">Exploring Bitcoin: signing the P2PKH input</a></p><p><a href="https://www.jianshu.com/p/a560e0605ff2">比特币私钥，公钥和地址的关系</a></p><p><a href="https://live.blockcypher.com/">在线搜索交易记录、区块信息（各种数字货币）</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
      <tag>ECDSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SM4算法介绍与代码实现</title>
    <link href="/2021/11/13/2021-11/2021-11-13%20SM4/"/>
    <url>/2021/11/13/2021-11/2021-11-13%20SM4/</url>
    
    <content type="html"><![CDATA[<h1 id="sm4算法介绍"><a class="markdownIt-Anchor" href="#sm4算法介绍"></a> SM4算法介绍</h1><h2 id="加密过程"><a class="markdownIt-Anchor" href="#加密过程"></a> 加密过程</h2><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131454563.(null)" alt="SM4加密过程" /></p><ul><li>首先左侧描述了SM4加密的整体流程：</li></ul><ol><li>输入的一个消息分组为128bits，划分成4个小块，每个小块32bits</li><li>这四个小块经过32轮加密处理</li><li>加密处理后，再经过一次Permutation置换，得到最终加密结果</li></ol><ul><li>右侧描述其中一轮的加密过程，其他轮函数加密过程是类似的，只是轮密钥不同：</li></ul><ol><li>X_3 先后跟 X_2 、X_1 进行异或  —— ①</li><li>① 得到的结果再与轮密钥 RK_i 进行异或  —— ②</li><li>② 得到的记过为32bits，再分成4组8bits，每一组8bits 使用相同的S-Box进行替换，得到新的8bits   —— ③</li><li>③ 得到的4组8bits重新拼接得到32bits，将这32bits复制成5份输入，第1份循环左移2位，第2份循环左移10位，第3份循环左移18位，第4份循环左移24位，第5份不改动直接输出 —— ④</li><li>④ 的得到的5份输出的32bits与X_0 一起进行异或 —— ⑤</li><li>最终得到输出 X’_3 就是 ⑤ 的输出，其他输出X’_0 = X_1 ， X’_1 = X_2， X’_2 = X_3</li></ol><p>用公式进行描述如下所示，其中S代表使用S-box进行替换，L表示线性函数执行循环左移的操作</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>X</mi><mn>0</mn><mo mathvariant="normal">′</mo></msubsup><mo>=</mo><msub><mi>X</mi><mn>1</mn></msub><mspace linebreak="newline"></mspace><msubsup><mi>X</mi><mn>1</mn><mo mathvariant="normal">′</mo></msubsup><mo>=</mo><msub><mi>X</mi><mn>2</mn></msub><mspace linebreak="newline"></mspace><msubsup><mi>X</mi><mn>2</mn><mo mathvariant="normal">′</mo></msubsup><mo>=</mo><msub><mi>X</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">X&#x27;_0 = X_1  \\X&#x27;_1 = X_2\\X&#x27;_2 = X_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>X</mi><mn>3</mn><mo mathvariant="normal">′</mo></msubsup><mo>=</mo><msub><mi>X</mi><mn>0</mn></msub><mo>⊕</mo><mi>L</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mn>3</mn></msub><mo>⊕</mo><msub><mi>X</mi><mn>2</mn></msub><mo>⊕</mo><msub><mi>X</mi><mn>1</mn></msub><mo>⊕</mo><mi>R</mi><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X&#x27;_3 =X_0⊕ L( S (X_3 ⊕ X_2 ⊕ X_1 ⊕ RK_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi mathvariant="normal">替</mi><mi mathvariant="normal">换</mi><mi mathvariant="normal">操</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">输</mi><mi mathvariant="normal">入</mi><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">输</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">为</mi><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">则</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">：</mi><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><msub><mi>b</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>S</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>S</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S替换操作输入A=(a_0,a_1,a_2,a_3)，输出为B=(b_0,b_1,b_2,b_3)，则有： \\ (b_0,b_1,b_2,b_3) = S(A)= (Sbox(a_0),Sbox(a_1),Sbox(a_2),Sbox(a_3))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">替</span><span class="mord cjk_fallback">换</span><span class="mord cjk_fallback">操</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">入</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">：</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi mathvariant="normal">线</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">输</mi><mi mathvariant="normal">入</mi><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">输</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">为</mi><mi>C</mi><mo stretchy="false">(</mo><mn>32</mn><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>C</mi><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mn>10</mn><mo stretchy="false">)</mo><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mn>18</mn><mo stretchy="false">)</mo><mo>⊕</mo><mo stretchy="false">(</mo><mi>B</mi><mo>&lt;</mo><mo>&lt;</mo><mn>24</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L线性函数输入B=(b_0,b_1,b_2,b_3),输出为C (32bits) \\ C = L(B) = B ⊕ (B&lt;&lt;2) ⊕(B&lt;&lt;10) ⊕(B&lt;&lt;18)⊕(B&lt;&lt;24)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">入</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">3</span><span class="mord">2</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span></p><p class='note note-success'>  通过观察SM4加密过程可以看到，在一轮加密中，有3个输出完全等同于3个输入，只有一个输出需要经过一些复杂操作，即计算X'_3，所以在进行解密时，只需要计算原来的X_0，而这可以通过现有的输出得到的（具体操作见下面的解密过程）。</p><h2 id="解密过程"><a class="markdownIt-Anchor" href="#解密过程"></a> 解密过程</h2><ul><li>在了解了SM4一轮的加密过程后，不难得出一轮的解密过程，如下图所示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131519980.png" alt="SM4解密过程" /></p><ul><li>同样左侧描述了SM4解密的整体流程：</li></ul><ol><li>输入的一个密文C为128bits，划分成4个小块，每个小块32bits</li><li>对这四个小块经过一次Permutation置换</li><li>对置换结果进行32轮类似的解密处理，得到最终的明文输出</li></ol><ul><li>具体描述一轮的解密过程，进行32轮类似的解密操作，其中X’_0对应加密过程中的输入X_1，X’_1对应输入X_2，X’_2对应输入X_3，所以重点计算得到原来输入的X_0，下面直接用公式来表示计算过程</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>=</mo><msubsup><mi>X</mi><mn>0</mn><mo mathvariant="normal">′</mo></msubsup><mspace width="2em"/><msub><mi>X</mi><mn>2</mn></msub><mo>=</mo><msubsup><mi>X</mi><mn>1</mn><mo mathvariant="normal">′</mo></msubsup><mspace width="2em"/><msub><mi>X</mi><mn>3</mn></msub><mo>=</mo><msubsup><mi>X</mi><mn>2</mn><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">X_1 = X&#x27;_0     \qquad X_2 = X&#x27;_1 \qquad X_3 = X&#x27;_2     </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:2em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:2em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub><mo>=</mo><msubsup><mi>X</mi><mn>3</mn><mo mathvariant="normal">′</mo></msubsup><mo>⊕</mo><mi>L</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">(</mo><msubsup><mi>X</mi><mn>2</mn><mo mathvariant="normal">′</mo></msubsup><mo>⊕</mo><msubsup><mi>X</mi><mn>1</mn><mo mathvariant="normal">′</mo></msubsup><mo>⊕</mo><msubsup><mi>X</mi><mn>0</mn><mo mathvariant="normal">′</mo></msubsup><mo>⊕</mo><mi>R</mi><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_0 =X&#x27;_3⊕ L( S (X&#x27;_2 ⊕ X&#x27;_1 ⊕ X&#x27;_0 ⊕ RK_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><strong>其中L线性函数跟S-box置换 都跟加密过程中一致；但需要注意的是解密过程中，轮密钥的使用次序是（31, 30, …, 1,0），跟加密过程使用的轮密钥次序正好是相反的</strong></p><h2 id="轮密钥生成"><a class="markdownIt-Anchor" href="#轮密钥生成"></a> 轮密钥生成</h2><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131454839.(null)" alt="轮密钥生成" /></p><ul><li>轮密钥生成过程如上图所示，其中K代表的是16字节的密钥，公式里的S用的和加密过程中相同的Sbox</li></ul><h1 id="c实现sm4加密与解密"><a class="markdownIt-Anchor" href="#c实现sm4加密与解密"></a> C++实现SM4加密与解密</h1><h2 id="实现目标"><a class="markdownIt-Anchor" href="#实现目标"></a> 实现目标</h2><ol><li>使用C++实现SM4算法的加密和结果，实现包括ECB、CBC两种加密模式。并提供命令⾏接⼝对⼆进制⽂件 进⾏加/解密。</li><li>实现对png图像文件的加密，只对图像数据部分进行加密，使得对加密png文件后仍能以png格式打开</li></ol><h2 id="命令行格式说明"><a class="markdownIt-Anchor" href="#命令行格式说明"></a> 命令行格式说明</h2><ul><li>生成的二进制可执行文件为 AppliedCryptography，共有以下几种可选配置<ul><li>-enc：进行加密操作</li><li>-dec：进行解密操作</li><li>-mode：指定加密/解密操作，其后跟着ecb或者cbc（如果没有指定，默认为ecb模式）</li><li>-png：指定输入和输出文件为png格式（对png文件做特殊处理，只加密数据块部分）；如果指定了，请保证文件的后缀名以.png格式结尾</li><li>-in：输入文件的路径，请使用相对路径</li><li>-out：输出文件的路径，请使用相对路径</li><li>-key：指定密钥，默认为&quot;123456&quot;</li><li>-iv：指定初始化向量，默认为&quot;123456&quot;</li><li>-test：如果指定了，执行测试函数</li></ul></li></ul><p class='note note-warning'>1. 配置的命令请用小写 <br>2. 一些配置之后请紧跟对应的参数值 <br>3. 输入和输出的路径请用相对路径 <br></p><ul><li>参考的测试命令如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试cbc模式加密png文件</span><br>./AppliedCryptography -enc -mode cbc -png -in logo.png -out test.png -iv 123456 -key 123456<br>./AppliedCryptography -dec -mode cbc -png -in test.png -out dec_test.png -iv 123456 -key 123456<br><span class="hljs-meta">#</span><span class="bash"> 测试ecb加密文件</span><br>./AppliedCryptography -enc -mode ecb -in test.txt -out ecb_test.txt -iv 123456 -key 123456<br>./AppliedCryptography -dec -mode ecb -in ecb_test.txt -out dec_test.txt -iv 123456 -key 123456<br></code></pre></td></tr></table></figure><h2 id="代码结构说明"><a class="markdownIt-Anchor" href="#代码结构说明"></a> 代码结构说明</h2><p>首先说明进行代码目录的说明，如下图所示：</p><center><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131454890.(null)" width="40%" height="40%" ></center><p align="middle"><font size="2" color="grey">代码目录结构</font></p><ul><li>项目使用CMake 构建，build目录是构建目录，build/output/bin下是对应可执行文件的输出目录，build/output/bin/test 目录下存放测试用的相关文件</li><li>Cmake-build-debug：使用CLion 编译构建时生成的目录</li><li>FirstWork：主要目录，sm4对应源代码是算法的具体实现；test对应的是测试相关方法，主要用于测试算法的正确性</li><li>hash-library：一个简单的第三方库，封装了hash操作和hex编码和解码等操作</li><li>util：其中util是一个工具类，主要封装了一些辅助函数</li><li>main.cpp：程序入口，主要实现了解析命令行参数，执行对应的操作</li></ul><h2 id="实现相关说明"><a class="markdownIt-Anchor" href="#实现相关说明"></a> 实现相关说明</h2><ul><li><p>在<code>sm4.h</code>和<code>sm4.cpp</code>中实现了SM4算法，具体实现逻辑只要是拆分成多个子函数</p><ul><li>L线性函数和Sbox替换函数实现</li><li>轮密钥生成</li><li><code>SM4EncRound</code>和<code>SM4DecRound</code>实现一轮的加密和解密</li><li><code>Encryption</code>和<code>Decryption</code>实现128bits输入的加密和解密</li><li><code>EncFile</code>和<code>DecFile</code>实现文件的加密和解密</li><li><code>EncPNG</code>和<code>DecPNG</code>实现对png格式文件的加密和解密</li></ul></li><li><p>需要注意的是，png图片文件，有自己的固定格式，主要为头部8字节固定签名，加其他数据块的结构，所以解析时要得到真正的数据块（IDAT)，对这一部分进行加密，这样才能加密后依然能够以png方式打开，具体的PNG格式参考：<a href="https://blog.csdn.net/einsteinlike/article/details/41803193">PNG格式说明</a></p></li><li><p>测试函数主要有4个</p><ul><li><code>TestAll()</code> ：进行所有测试</li><li><code>TestEncDec()</code>： 测试SM4 单次加解密128bits</li><li><code>TestEncDecFileECB()</code>： 测试SM4 加密和解密文件 ECB模式</li><li><code>TestEncDecFileCBC()</code>： 测试SM4 加密和解密文件 CBC模式</li><li><code>TestEncDecPNG()</code>： 测试SM4 加密和解密PNG图片</li></ul></li></ul><p class='note note-info'>  代码已上传Github仓库：https://github.com/2017zhangyuxuan/AppliedCryptography <br></p><p class='note note-danger'>  但是当前代码还存在问题是，大端和小端的问题没有彻底解决，如果对比一些官方实现，加密结果是不同的，因为时间原因没有能排查出来，只能作罢。所以仅仅是提供一些思路。</p><center><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//hexo_img/菜狗.jpeg" width="40%" height="40%" align="middle" ></center><h1 id="参考附录"><a class="markdownIt-Anchor" href="#参考附录"></a> 参考附录</h1><p>SM4算法原理 ：<a href="https://blog.csdn.net/bird_tp/article/details/105988468">https://blog.csdn.net/bird_tp/article/details/105988468</a></p><p>SM4 实现参考：<a href="https://cryptopp.com/docs/ref/class_s_m4_1_1_base.html#details">https://cryptopp.com/docs/ref/class_s_m4_1_1_base.html#details</a></p><p><a href="https://blog.csdn.net/weixin_39672443/article/details/110806799">png文件头_图片格式知识PNG_weixin_39672443的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/einsteinlike/article/details/41803193">PNG格式说明</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SM4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题03】隔离见证、闪电网络</title>
    <link href="/2021/11/13/2021-11/2021-11-13%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9803-%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81%E3%80%81%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/11/13/2021-11/2021-11-13%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9803-%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81%E3%80%81%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>最近通读了一遍《精通比特币》，对比特币中运行机制和实现原理有了初步的认识和了解。其中隔离见证和闪电网络是此前学习中遇到到两个困惑点，现在也大致有所了解，故而本篇文章就来谈谈我的个人理解，基本上是对书里关键知识点的提炼和总结，下方也给出了电子书连接。如有任何错误，欢迎批评指出~</p><p class='note note-info'><a href=https://github.com/tianmingyun/MasterBitcoin2CN>精通比特币电子书链接</a>  </p><h1 id="隔离见证"><a class="markdownIt-Anchor" href="#隔离见证"></a> 隔离见证</h1><p>隔离见证提出的背景：随着比特币火热发展，网络上的交易量越来越大，而由于区块大小受限，一个区块能打包的交易数量是有一定限制的，而出块速度限定在10分钟一次，这就导致无法满足交易吞吐量的增长。那么隔离见证提出，挑战了交易结构，使得一个区块可以容纳更多的交易，从而提高了交易吞吐量，当时隔离见证还有别的好处，可以去看书中内容<a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch07.md#781-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81">隔离见证的好处</a>。当然提高比特币性能（比如提高交易吞吐量）的方法还有很多，这里不再展开。</p><p class='note note-primary'>隔离见证相关BIP方案:<br>  <a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">BIP-141 隔离见证的定义</a>  <br>    <a href="https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki">BIP-144 隔离见证网络序列化</a></p><h2 id="关键知识"><a class="markdownIt-Anchor" href="#关键知识"></a> 关键知识</h2><ul><li>在比特币环境中，数字签名是见证的<em>一种类型</em>，但更广义来说，见证是指能够满足对UTXO施加的条件并解锁该UTXO以供消费的任何解决方案。术语“见证”是“解锁脚本”或“scriptSig”的更一般的术语。</li><li>在引入隔离见证之前，交易中的每一个输入后面紧跟着的就是解锁它的见证数据。见证数据作为每个输入的一部分嵌入到交易中。术语<em>隔离见证</em>（简称<em>segwit</em>）只是指把特定输出的签名或解锁脚本隔离开。“单独的scriptSig”或“单独的签名”就是它最简单的形式。</li><li>乍一看，隔离见证似乎只是对交易构造方式的改变，属于交易级特性，但事实并非如此。其实，隔离见证是对单独的UTXO花费方式的更改，因此可以说是每个输出层面的特性。</li><li>当交易使用UTXO时，必须提供一个见证。在传统的UTXO中，锁定脚本要求见证数据<em>内嵌</em>在花费UTXO的交易的输入部分。但是，隔离见证UTXO指定了一个锁定脚本，该脚本可以用输入之外的见证数据（隔离）满足。</li><li><strong>隔离见证是一个软分叉</strong></li></ul><h2 id="txid-和-wtxid"><a class="markdownIt-Anchor" href="#txid-和-wtxid"></a> TXID 和 WTXID</h2><ul><li>隔离见证的最大好处之一就是<strong>消除了第三方交易延展性</strong>。</li><li>在隔离见证之前，交易可以通过第三方巧妙地修改其签名，在不改变任何基本属性（输入，输出，金额）的情况下更改其交易ID（哈希）。这为拒绝服务DOS攻击，以及对有缺陷的钱包软件的攻击创造了机会，这些软件假定未经证实的交易哈希是不可变的。</li><li>通过引入隔离见证，交易有两个标识符txid和wtxid。传统的txid是序列化交易的双SHA256哈希，没有见证数据。交易的wtxid是具有见证数据的交易的新序列化格式的双SHA256哈希。</li><li>传统txid的计算方式与非隔离见证交易完全相同。但是，由于隔离见证交易在每个输入中都有空的scriptSig，不存在可由第三方修改的交易部分。因此，在隔离交易中，即使交易未经确认，txid也是不能被第三方修改的。</li></ul><blockquote><p><strong>提示</strong> 隔离见证交易有两个ID：txid和wtxid。txid是没有见证数据的交易的哈希，wtxid是包含见证数据的哈希。所有输入都是隔离见证输入的交易，不受第三方交易延展性影响。</p></blockquote><hr /><ul><li>TXID的生成和传统方式一致：是对version, txins, txouts, nLocktime序列化后的数据，进行两次SHA256哈希</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[nVersion][txins][txouts][nLockTime]<br></code></pre></td></tr></table></figure><ul><li>WTXID的生成：对version, marker, flag, txins, txouts, witness, nLocktime序列化后的数据，进行两次SHA256哈希</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[nVersion][marker][flag][txins][txouts][witness][nLockTime]<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131049973.png" alt="TXID与WTXID的生成" /></p><h2 id="隔离见证的数据到底放在哪里"><a class="markdownIt-Anchor" href="#隔离见证的数据到底放在哪里"></a> 隔离见证的数据到底放在哪里</h2><p>在了解隔离见证的大致原理后，我其实还是存在一个疑惑：既然说见证相当于是原来的签名数据（解锁脚本），与原来的交易数据隔离开，那么这些见证数据到底放在哪里了？</p><ul><li><p>通过<a href="https://www.jianshu.com/p/eef8e260b9f7">比特币探究之隔离见证</a> 这篇文章，了解到原来的签名数据放到了见证数据中，见证数据在CTxIn 是一个新的字段，但是只有在交易被序列化网络传输时才参与，呼应上文计算TXID时，witness是不需要序列化的；</p></li><li><p>通过<a href="https://boinnex.com/what-is-segwit/">外文- Segwit如何工作的</a> 这篇文章，进一步了解到在生成区块时，输入的见证数据同样构成一棵Merkle Tree，并把root放到了区块中的币基交易的output的锁定脚本中，具体原文描述如下图。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131137534" alt="ScriptPubKey of Witness in coinbase " /></p><h1 id="闪电网络"><a class="markdownIt-Anchor" href="#闪电网络"></a> 闪电网络</h1><p>闪电网络其实也是一种提高比特币交易性能的方法，简单来说，就是将大量交易放到比特币区块链之外进行。在具体介绍闪电网络是如何工作运行前，还需要先介绍状态通道，支付通道，HTLC哈希时间锁合约等概念。</p><h2 id="状态通道和支付通道"><a class="markdownIt-Anchor" href="#状态通道和支付通道"></a> 状态通道和支付通道</h2><p>基本概念：</p><ul><li><em>支付通道Payment channels</em>是在比特币区块链之外，双方交换比特币交易的无信任机制。</li><li>实际上，<em>通道channel</em> 一词是一个比喻。状态通道是区块链外，由双方之间的交换状态代表的虚拟构想。实际上没有“通道”，底层数据传输机制也并不是通道。我们使用通道这个术语来表示链外双方之间的关系和共享状态。</li><li>支付通道是更广泛的<em>状态通道state channel</em>概念的一部分，状态通道代表了链外状态的变化，通过最终在区块链上结算得到保障。支付通道是一种状态通道，其中被改变的状态是虚拟货币余额。</li></ul><hr /><p>《精通比特币》中对支付通道的描述感觉过于复杂，这里用Bitcoin Developer Guide里的微支付通道来举例说明，在之前博客[【比特币专题02】Developer Guide导读](<a href="https://2017zhangyuxuan.github.io/2021/10/11/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9802-Developer">https://2017zhangyuxuan.github.io/2021/10/11/2021-10-11比特币专题02-Developer</a> Guide/) 也有介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131147856.(null)" alt="微支付通道" /></p><ul><li>其工作原理大体上可以这样描述：A给B打工，B首先使用A和B的签名，使用P2SH的方式，发送一定金额到脚本地址，并将该交易立即传播到比特币网络上；然后B创造第二个交易，并用到刚刚A的签名，其输入是第一个交易的脚本地址，输出是B的地址（相当于全额返回给B），然后给这个交易加上Locktime，比如说一天后才能广播这个交易。然后A给B工作一部分内容后，A要求B先支付这份工作量的薪水，那么B就创建一份新的交易，从原来全额给B变成分出一部分金额给A，这个新的交易拷贝给A，这样A就可以广播这个新的交易从而获得薪水。（实际上A只需要在locktime过期前，广播最后版本的交易即可）<ul><li>B创建的第一笔交易和第二笔交易，可以理解为《精通比特币》中的<em>注资交易funding transaction</em>或<em>锚点交易anchor transaction</em>：通过在区块链上锁定共享状态的交易，在交易两方之间建立了一个状态通道。在支付通道的示例中，锁定的状态即为通道的初始余额（以货币计）</li><li>随后双方交换已签名的交易，这被称为<em>承诺交易commitment transactions</em>。承诺交易会改变初始状态。这些交易是有效的交易，因为它们<em>可以</em>被任何一方提交进行结算，但是在通道关闭之前，每一方都会将其在链下保留。</li><li>最后，通道可以协商关闭，即向区块链提交最后的<em>结算交易settlement transaction</em>，或者由任何一方单方面提交最后承诺交易到链上。</li></ul></li><li>为什么采用支付通道这样的方式呢，因为A诉求是及时支付薪水，但是因为量小，B不能每次都立即创造一个交易即刻支付，这样的交易费的成本太高了。所以利用这样的方式，既确保了A的薪水是及时得到确认的，又可以使得只需一个交易就一次性支付薪水</li><li>实际上，更改交易金额的输出，这个权利是在B的，因为B有A的签名但A没有B的签名，A拿的是经过B签名后的交易副本（这个交易被B签名过了，所以是有效的）。所以A能实时确保自己对应工作量的薪水能及时支付，就算中途B跑路了，也只是损失一小部分工作量的薪水，之前的薪水都可以得到支付。而对B来说，如果A没有工作，那B也能在locktime 过期后拿回自己的钱（不过这样就需要等待一个locktime的时间）</li></ul><h2 id="htlc哈希时间锁合约"><a class="markdownIt-Anchor" href="#htlc哈希时间锁合约"></a> HTLC哈希时间锁合约</h2><p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch12.md#1255-%E5%93%88%E5%B8%8C%E6%97%B6%E9%97%B4%E9%94%81%E5%90%88%E7%BA%A6htlc">HTLC 哈希时间锁合约</a> 原文中介绍得比较详细了，这里简单总结一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过密钥R生成哈希值H</span><br>H = Hash(R)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 实现HTLC的脚本可能如下所示：</span><br>IF<br>Payment if you have the secret R<br>    HASH160 &lt;H&gt; EQUALVERIFY<br>ELSE<br>    # Refund after timeout.<br>    &lt;locktime&gt; CHECKLOCKTIMEVERIFY DROP<br>    &lt;Payer Public Key&gt; CHECKSIG<br>ENDIF<br></code></pre></td></tr></table></figure><ul><li>任何知道密钥R，其哈希值等于H的人，都可以通过行使IF语句的第一个子句来兑换该输出。</li><li>如果密钥R没有被透露，HTLC中写明了，在一定数量的区块之后，付款人可以使用IF语句中的第二个子句申请退款。</li></ul><h2 id="闪电网络运行"><a class="markdownIt-Anchor" href="#闪电网络运行"></a> 闪电网络运行</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131152708.(null)" alt="" /></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202111131152805.(null)" alt="" /></div></div></div><p align="middle"><font size="2" color="grey">左图：支付通道初始状态；右图：闪电网络运行流程</font></p><p>接下来说明一下，闪电网络是如何工作：</p><ul><li>在这个例子中，我们有五个参与者：Alice, Bob, Carol, Diana, and Eric。这五名参与者已经彼此之间开设了支付通道。Alice和Bob有支付通道。Bob连接Carol，Carol连接到Diana，Diana连接Eric。为了简单起见，我们假设每个通道每个参与者都注资2个比特币资金，每个通道的总容量为4个比特币，也就是如左图所示的初始状态</li><li>Alice想要支付给Eric1个比特币。但是，Alice并没有直接连接Eric的支付通道。创建支付通道需要注资交易，而这笔交易必须首先提交给比特币区块链。Alice不想建立一个新的支付通道还要支出更多的手续费。那么就可以通过闪电网络来进行支付。</li></ul><ol><li>Alice通过路由发现了一条从Alice到Eric的一条支付路由，由多个支付通道组成。此时Alice和Eric可以进行通信，Eric生成一个密钥R，并进行hash，将哈希值H发送给Alice。</li><li>Alice构造一个HTLC，支付1.003BTC到哈希H（多出来的0.003BTC是给路由上3个节点的费用），并可以在10区块内得到退款。Alice将此HTLC提供给Bob，从和Bob之间的通道余额中扣除1.003比特币，并将其提交给HTLC。该HTLC具有以下含义：<em>“如果Bob知道密钥，Alice将其通道余额的1.003支付给Bob，或者如果超过10个区块后，则退还入Alice的余额”</em>。</li><li>Bob构造一个新的HTLC，支付1.002BTC到哈希H，如果Carol知道了密钥R，可以去取走HTLC中的1.002BTC，然后Bob也可以取走Alice提供的1.003BTC，相当于赚取了0.001BTC；如果Carol不能提供密钥，Bob也可以在9个区块时间内取回1.002BTC</li><li>Carol向Diana提供1.001BTC的HTLC，同上面一样</li><li>Dinana向Eric提供1.0BTC的HTLC</li><li>Eric知道密钥，向Diana出示了密钥R，因此取走了HTLC中的1.0BTC</li><li>Diana从Eric知道了密钥R，再向Carol出示密钥R，获得了1.001BTC，此时在Eric和Diana中支付通道中，Diana余额只有1.0BTC了，但在Carol和Diana的支付通道中，Diana余额为3.001BTC，对比原来的2+2，赚取了0.001BTC</li><li>Carol向Diana支付了1.001BTC，再从Bob处赚取了1.002BTC，赚取了0.001BTC</li><li>Bob向Carol支付了1.002BTC，从Alice处赚取了1.003BTC，赚取了0.001BTC</li><li>最终Alice支付了1.003BTC，实际上1BTC转账给了Eric，0.003支付给了路由上的其他节点</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CryptoPP C++库学习使用</title>
    <link href="/2021/11/01/2021-11/2021-11-01%20CryptoPP%E5%BA%93%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/11/01/2021-11/2021-11-01%20CryptoPP%E5%BA%93%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><blockquote><p>参考书籍：《深入浅出CryptoPP密码学库》<br />crypto++  密码学库 ：<a href="https://github.com/weidai11/cryptopp">https://github.com/weidai11/cryptopp</a><br />电子书下载 ：<a href="https://gitee.com/locomotive_crypto">https://gitee.com/locomotive_crypto</a></p></blockquote><p>最近在学习比特币相关技术，在比特币系统中使用大量哈希加密、签名验证等操作，为了用代码来模拟实现比特币的运行过程，学习一个支持密码原语操作的第三方库是非常有必要的。</p><p>最为知名的密码学相关开源库应该是OpenSSL了，但是由于官网是一堆英文，学习起来太吃力，后来机缘巧合下发现了CryptoPP这个库，而且还有专门的中文书籍来讲解使用，因此就决定学习CryptoPP库，本篇论文也是基于《深入浅出CryptoPP密码学库》阅读，整理出关键章节内容，供大家参考学习。</p><p class='note note-info'>1. CryptoPP库的安装使用这里不再详细说明，请大家自行搜索网上教程  <br>2. 后来看到OpenSSL也有一个中文手册学习网站，也推荐给大家https://www.openssl.net.cn/</p><h1 id="string-和-secbyteblock类型互换"><a class="markdownIt-Anchor" href="#string-和-secbyteblock类型互换"></a> string 和 SecByteBlock类型互换</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// SecByteBlock 转 string</span><br><br>SecByteBlock iv; ... <span class="hljs-comment">// C++-style cast </span><br><br>std::string token = std::<span class="hljs-built_in">string</span>(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt;(iv.<span class="hljs-built_in">data</span>()), iv.<span class="hljs-built_in">size</span>());<br><br><br><br><span class="hljs-comment">// string 转 SecByteBlock</span><br><br>std::string str; ... <span class="hljs-comment">// C++-style cast </span><br><br><span class="hljs-function">SecByteBlock <span class="hljs-title">sbb</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> byte*&gt;(str.data()), str.size())</span></span>;<br></code></pre></td></tr></table></figure><h1 id="第四章-初识cryptopp库"><a class="markdownIt-Anchor" href="#第四章-初识cryptopp库"></a> 第四章 初识CryptoPP库</h1><h2 id="hex编解码字符串"><a class="markdownIt-Anchor" href="#hex编解码字符串"></a> Hex编解码字符串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;filters.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;hex.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 第一种编码方式</span><br><br>    HexEncoder hex;<br><br>    string str = <span class="hljs-string">&quot;I like&quot;</span>;<br><br>    string hexstr;<br><br>    hex.<span class="hljs-built_in">Detach</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(hexstr));<br><br>    hex.<span class="hljs-built_in">Put</span>(<span class="hljs-keyword">reinterpret_cast</span>&lt;byte*&gt;(&amp;str[<span class="hljs-number">0</span>]),str.<span class="hljs-built_in">size</span>());  <span class="hljs-comment">// 注意是会追加写入的</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;str:&quot;</span> &lt;&lt; str &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;hexstr:&quot;</span> &lt;&lt; hexstr &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// 第二种编解码写法  Source -&gt; Filter -&gt; Sink  这是一种Pipeline的方式</span><br><br>    string encode,decode;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">enc</span><span class="hljs-params">(str, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> HexEncoder(<span class="hljs-keyword">new</span> StringSink(encode)))</span></span>;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">dec</span><span class="hljs-params">(hexstr, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> HexDecoder(<span class="hljs-keyword">new</span> StringSink(decode)))</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;encode:&quot;</span>&lt;&lt;encode &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;decode:&quot;</span>&lt;&lt;decode &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第五章-随机数生成器"><a class="markdownIt-Anchor" href="#第五章-随机数生成器"></a> 第五章 随机数生成器</h1><p>主要可以关注GenerateBlock方法，生成指定字节长度的随机数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;osrng.h&gt;</span> <span class="hljs-comment">// 可以使用 AutoSeededRandomPool ，该随机器不用设置种子</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;rng.h&gt;</span> <span class="hljs-comment">//包含LC_RNG算法的头文件</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span> <span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP; <span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Array_Size 64</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//定义一个LC_RNG随机数发生器对象，并设置其种子</span><br><br>    <span class="hljs-function">LC_RNG  <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生一个比特的随机数：&quot;</span> &lt;&lt; rng.<span class="hljs-built_in">GenerateBit</span>() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生一个字节的随机数：&quot;</span> &lt;&lt; rng.<span class="hljs-built_in">GenerateByte</span>() &lt;&lt; endl;<br><br>    byte output[Array_Size + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//定义一个缓冲区      </span><br><br><br><br>    <span class="hljs-comment">//产生Array_Size字节长度的随机数</span><br><br>    rng.<span class="hljs-built_in">GenerateBlock</span>(output, Array_Size);  <span class="hljs-comment">// 这里也可直接传入SecByteBlock</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生Array_Size长度的随机数（十六进制）：&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Array_Size; ++i)<br><br>    &#123;<span class="hljs-comment">//将获得的随机数转换成十六进制并输出</span><br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X&quot;</span>, output[i]);<br><br>    &#125;<br><br>    cout &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;产生一个100到1000之间的随机数：&quot;</span> &lt;&lt; rng.<span class="hljs-built_in">GenerateWord32</span>(<span class="hljs-number">100</span>, <span class="hljs-number">1000</span>) &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">//丢弃掉随机数发生器接下来产生的100个字节数据</span><br><br>    rng.<span class="hljs-built_in">DiscardBytes</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">int</span> arry[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><br>    rng.<span class="hljs-built_in">Shuffle</span>(arry, arry + <span class="hljs-number">10</span>); <span class="hljs-comment">//打乱数组arry中元素的顺序</span><br><br>    <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第六章-hash函数"><a class="markdownIt-Anchor" href="#第六章-hash函数"></a> 第六章 Hash函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sha.h&gt;</span> <span class="hljs-comment">//使用SHA384</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;filters.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;hex.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span> <span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP; <span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">try</span><br><br>    &#123;<br><br>        SHA256 sha; <span class="hljs-comment">//定义一个SHA256的类对象</span><br><br>        byte msg[] = <span class="hljs-string">&quot;I like cryptography very much&quot;</span>;<br><br><br><br>        <span class="hljs-comment">// 使用pipeline范式</span><br><br>        <span class="hljs-function">SecByteBlock <span class="hljs-title">tmp</span><span class="hljs-params">(msg, <span class="hljs-keyword">sizeof</span>(msg)<span class="hljs-number">-1</span>)</span></span>;<br><br>        string r;<br><br>        <span class="hljs-function">StringSource <span class="hljs-title">s1</span> <span class="hljs-params">(tmp, tmp.size(),<span class="hljs-literal">true</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HashFilter(sha,    <span class="hljs-comment">// 使用其他hash函数，更换一下类型即可</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HexEncoder(</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> StringSink(r))))</span></span>;<br><br>        cout &lt;&lt; r &lt;&lt; endl;<br><br>        r.<span class="hljs-built_in">clear</span>();  <span class="hljs-comment">// 清空一下，不然后面会追加</span><br><br><br><br>        <span class="hljs-comment">// 连续两次Hash256，再用Hex编码输出</span><br><br>        SHA256 sha2;<br><br>        <span class="hljs-function">StringSource <span class="hljs-title">s2</span> <span class="hljs-params">(<span class="hljs-string">&quot;I like cryptography very much&quot;</span>,<span class="hljs-literal">true</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HashFilter(sha,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HashFilter(sha2,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> HexEncoder(</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">new</span> StringSink(r)))) )</span></span>;<br><br>        cout &lt;&lt; r &lt;&lt; endl;<br><br><br><br>        <span class="hljs-function">SecByteBlock <span class="hljs-title">digest</span><span class="hljs-params">(sha.DigestSize())</span></span>; <span class="hljs-comment">//申请内存空间以存放消息摘要</span><br><br>        <span class="hljs-comment">//CalculateDigest()相当于Update()+Final()</span><br><br>        <span class="hljs-comment">// Update用来向sha输入，Final计算hash值，同时重置hash函数内部状态</span><br><br>        sha.<span class="hljs-built_in">CalculateDigest</span>(digest, msg, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(msg) - <span class="hljs-number">1</span>);<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;digest2=&quot;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; sha.<span class="hljs-built_in">DigestSize</span>(); ++i)<br><br>        &#123;<span class="hljs-comment">//以十六进制输出Hash值</span><br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X&quot;</span>, digest[i]);<br><br>        &#125;<br><br>        cout &lt;&lt; endl;<br><br><br><br>        <span class="hljs-comment">//计算msg消息的Hash值</span><br><br>        <span class="hljs-keyword">bool</span> res;<br><br>        res = sha.<span class="hljs-built_in">VerifyDigest</span>(digest, <span class="hljs-comment">//可能抛出异常</span><br><br>                               msg, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(msg) - <span class="hljs-number">1</span>); <span class="hljs-comment">//去掉字符串最后的&#x27;\0&#x27;</span><br><br>        cout &lt;&lt; <span class="hljs-string">&quot;res = &quot;</span> &lt;&lt; boolalpha &lt;&lt;res &lt;&lt; endl;  <span class="hljs-comment">// 这里的boolalpha 是为了输出bool值true或者false</span><br><br><br><br>    &#125;<br><br>    <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword">const</span> Exception&amp; e)<br><br>    &#123;<span class="hljs-comment">//出现异常</span><br><br>        cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl; <span class="hljs-comment">//异常原因</span><br><br>    &#125;<br><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十一章-公钥密码学数学基础"><a class="markdownIt-Anchor" href="#第十一章-公钥密码学数学基础"></a> 第十一章 公钥密码学数学基础</h1><h2 id="大整数-与-大素数生成"><a class="markdownIt-Anchor" href="#大整数-与-大素数生成"></a> 大整数 与 大素数生成</h2><ul><li>可以再研究一下大整数的一些用法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;integer.h&gt;</span><span class="hljs-comment">//使用Integer</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span><span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;osrng.h&gt;</span><span class="hljs-comment">//使用AutoSeededRandomPool</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;nbtheory.h&gt;</span><span class="hljs-comment">//使用PrimeAndGenerator、VerifyPrime</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP;<span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    AutoSeededRandomPool rng; <span class="hljs-comment">// 定义随机数发生器对象</span><br><br>    <span class="hljs-comment">// 定义PrimeAndGenerator对象，利用随机数发生器rng产生素数p和q</span><br><br>    <span class="hljs-comment">// 要求产生的p是1024比特的素数，q是512比特的素数</span><br><br>    <span class="hljs-function">PrimeAndGenerator <span class="hljs-title">pag</span><span class="hljs-params">(<span class="hljs-number">1</span>, rng, <span class="hljs-number">1024</span>, <span class="hljs-number">512</span>)</span></span>;<br><br>    Integer p = pag.<span class="hljs-built_in">Prime</span>(); <span class="hljs-comment">// 获取素数p的值</span><br><br>    Integer q = pag.<span class="hljs-built_in">SubPrime</span>(); <span class="hljs-comment">// 获取素数q的值</span><br><br>    Integer r = (p - <span class="hljs-number">1</span>) / q / <span class="hljs-number">2</span>; <span class="hljs-comment">// 计算r的值，因为p=2*r*q+1，delta=1</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p(&quot;</span> &lt;&lt; p.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot;)：&quot;</span> &lt;&lt; p &lt;&lt; endl; <span class="hljs-comment">// 打印p的值及比特数</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;q(&quot;</span> &lt;&lt; q.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot;)：&quot;</span> &lt;&lt; q &lt;&lt; endl; <span class="hljs-comment">// 打印q的值及比特数</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;r(&quot;</span> &lt;&lt; r.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot;)：&quot;</span> &lt;&lt; r &lt;&lt; endl; <span class="hljs-comment">// 打印r的值及比特数</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">VerifyPrime</span>(rng, r, <span class="hljs-number">10</span>)) <span class="hljs-comment">// 验证r是否为素数</span><br><br>    &#123;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;r是素数&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 如果r为素数，则输出该信息</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">else</span><br><br>    &#123;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;r不是素数&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 如果r不为素数，则输出该信息</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十三章-数字签名"><a class="markdownIt-Anchor" href="#第十三章-数字签名"></a> 第十三章 数字签名</h1><p>电子书给出的参考是ECNR数字签名算法</p><p><a href="https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA椭圆曲线 - Crypto++</a></p><p><a href="https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm">https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm</a> -》关于压缩公钥的实现可以参考 Compressed Point 这一部分</p><h2 id="私钥和公钥生成-保存"><a class="markdownIt-Anchor" href="#私钥和公钥生成-保存"></a> 私钥和公钥生成、保存</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;integer.h&gt;</span><span class="hljs-comment">//使用Integer</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span><span class="hljs-comment">//使用cout、cin</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;osrng.h&gt;</span><span class="hljs-comment">//使用AutoSeededRandomPool</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;eccrypto.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;oids.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;files.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;filters.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;filesystem&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;hex.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;base32.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//std是C++的命名空间</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> CryptoPP;<span class="hljs-comment">//CryptoPP是CryptoPP库的命名空间</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ECDSA_Generate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 指定 private exponent  32字节随机数，生成对应的私钥</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    string exp = &quot;E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB&quot;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    HexDecoder decoder;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    decoder.Put((byte*)&amp;exp[0], exp.size());</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    decoder.MessageEnd();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Integer x;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    x.Decode(decoder, decoder.MaxRetrievable());</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    privateKey.Initialize(ASN1::secp256r1(), x);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br><br><br>    AutoSeededRandomPool prng;<br><br>    ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;<br><br><br><br>    privateKey.<span class="hljs-built_in">Initialize</span>( prng, ASN1::<span class="hljs-built_in">secp256k1</span>() );<br><br><br><br>    <span class="hljs-comment">/* 使用ByteQueue 方便将公私钥存储在内存中，如果要持久化到磁盘，可以使用FileSink</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ByteQueue queue;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    privateKey.Save(queue);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    privateKey.Load(queue);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br><br><br><br>    <span class="hljs-comment">// 验证密钥强度</span><br><br>    <span class="hljs-keyword">bool</span> result = privateKey.<span class="hljs-built_in">Validate</span>( prng, <span class="hljs-number">3</span> );<br><br>    cout &lt;&lt; boolalpha &lt;&lt; result &lt;&lt; endl;<br><br><br><br>    Integer p = privateKey.<span class="hljs-built_in">GetPrivateExponent</span>();<br><br>    cout&lt;&lt; <span class="hljs-string">&quot;len:&quot;</span> &lt;&lt; p.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot; Private Key:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    string priHexKey;<br><br>    <span class="hljs-function">HexEncoder <span class="hljs-title">encoder</span><span class="hljs-params">(<span class="hljs-keyword">new</span> StringSink(priHexKey))</span></span>;<br><br>    p.<span class="hljs-built_in">Encode</span>(encoder, <span class="hljs-number">32</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;priHexKey:&quot;</span>&lt;&lt;priHexKey.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; priHexKey &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// Save private key in PKCS #8 format</span><br><br>    <span class="hljs-function">FileSink <span class="hljs-title">fs1</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/private.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*binary*/</span> )</span></span>;<br><br>    privateKey.<span class="hljs-built_in">Save</span>( fs1 );<br><br><br><br>    <span class="hljs-comment">// Generate publicKey</span><br><br>    ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey publicKey;<br><br>    privateKey.<span class="hljs-built_in">MakePublicKey</span>(publicKey);<br><br>    <span class="hljs-keyword">const</span> ECP::Point&amp; q = publicKey.<span class="hljs-built_in">GetPublicElement</span>();<br><br>    <span class="hljs-keyword">const</span> Integer&amp; qx = q.x;<br><br>    <span class="hljs-keyword">const</span> Integer&amp; qy = q.y;<br><br>    string qxHex, qyHex;<br><br>    <span class="hljs-function">HexEncoder <span class="hljs-title">encoderx</span><span class="hljs-params">(<span class="hljs-keyword">new</span> StringSink(qxHex))</span></span>;<br><br>    <span class="hljs-function">HexEncoder <span class="hljs-title">encodery</span><span class="hljs-params">(<span class="hljs-keyword">new</span> StringSink(qyHex))</span></span>;<br><br>    qx.<span class="hljs-built_in">Encode</span>(encoderx, <span class="hljs-number">32</span>);<br><br>    qy.<span class="hljs-built_in">Encode</span>(encodery, <span class="hljs-number">32</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;len:&quot;</span> &lt;&lt; qx.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot; Public Point x:&quot;</span> &lt;&lt; qx &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;qxHex:&quot;</span> &lt;&lt; qxHex &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;len:&quot;</span> &lt;&lt; qy.<span class="hljs-built_in">BitCount</span>() &lt;&lt; <span class="hljs-string">&quot; Public Point y:&quot;</span> &lt;&lt; qy &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;qyHex:&quot;</span> &lt;&lt; qyHex &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// Save public key in X.509 format</span><br><br>    <span class="hljs-function">FileSink <span class="hljs-title">fs2</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/public.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*binary*/</span> )</span></span>;<br><br>    publicKey.<span class="hljs-built_in">Save</span>( fs2 );<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="私钥和公钥的加载-签名和认证"><a class="markdownIt-Anchor" href="#私钥和公钥的加载-签名和认证"></a> 私钥和公钥的加载、签名和认证</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 头文件和上述一样</span><br><br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ECDSA_LOAD</span><span class="hljs-params">()</span></span>&#123;<br><br>    AutoSeededRandomPool prng;<br><br>    <span class="hljs-function">FileSource <span class="hljs-title">fs1</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/private.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span> )</span></span>;<br><br>    <span class="hljs-function">FileSource <span class="hljs-title">fs2</span><span class="hljs-params">( <span class="hljs-string">&quot;../../../keys/public.ec.der&quot;</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span> )</span></span>;<br><br>    ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;<br><br>    ECDSA&lt;ECP, SHA256&gt;::PublicKey publicKey;<br><br>    <span class="hljs-comment">// 加载私钥， 私钥格式：PKCS #8</span><br><br>    privateKey.<span class="hljs-built_in">Load</span>( fs1 );<br><br>    publicKey.<span class="hljs-built_in">Load</span>(fs2);<br><br><br><br>    <span class="hljs-comment">// 用私钥进行签名</span><br><br>    ECDSA&lt;ECP, SHA256&gt;::<span class="hljs-function">Signer <span class="hljs-title">signer</span><span class="hljs-params">(privateKey)</span></span>;<br><br>    string message = <span class="hljs-string">&quot;Yoda said, Do or do not. There is no try.&quot;</span>;<br><br>    string signature;<br><br><br><br><br><br>    <span class="hljs-function">StringSource <span class="hljs-title">s</span><span class="hljs-params">( message, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">new</span> SignerFilter( prng,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                                      signer,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-keyword">new</span> StringSink( signature )</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                    ) <span class="hljs-comment">// SignerFilter</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>; <span class="hljs-comment">// StringSource</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;signature len:&quot;</span> &lt;&lt; signature.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; output:&quot;</span> &lt;&lt; signature &lt;&lt; endl;<br><br><br><br>    <span class="hljs-comment">// 将签名（包含R，S）转换成 DER 格式</span><br><br>    std::string derSign;<br><br>    <span class="hljs-comment">// Make room for the ASN.1/DER encoding</span><br><br>    derSign.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>+<span class="hljs-number">3</span>+<span class="hljs-number">3</span>+<span class="hljs-number">2</span>+signature.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-keyword">size_t</span> converted_size = <span class="hljs-built_in">DSAConvertSignatureFormat</span>(<br><br>            (byte*) (&amp;derSign[<span class="hljs-number">0</span>]), derSign.<span class="hljs-built_in">size</span>(), DSA_DER,<br><br>            (<span class="hljs-keyword">const</span> byte*) (signature.<span class="hljs-built_in">data</span>()), signature.<span class="hljs-built_in">size</span>(), DSA_P1363);<br><br>    derSign.<span class="hljs-built_in">resize</span>(converted_size);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;DER len:&quot;</span> &lt;&lt; derSign.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; DER:&quot;</span> &lt;&lt; derSign &lt;&lt; endl;<br><br>    string hexDER;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">toDER</span><span class="hljs-params">(derSign, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> HexEncoder(<span class="hljs-keyword">new</span> StringSink(hexDER)))</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;DER hex:&quot;</span> &lt;&lt; hexDER &lt;&lt; endl;<br><br><br><br>    <br><br>    <span class="hljs-comment">// 进行验证</span><br><br>    <span class="hljs-keyword">bool</span> result;<br><br>    ECDSA&lt;ECP, SHA256&gt;::<span class="hljs-function">Verifier <span class="hljs-title">verifier</span><span class="hljs-params">(publicKey)</span></span>;<br><br>    <span class="hljs-function">StringSource <span class="hljs-title">ss</span><span class="hljs-params">( signature+message, <span class="hljs-literal">true</span> <span class="hljs-comment">/*pump all*/</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-keyword">new</span> SignatureVerificationFilter(</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                             verifier,</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">new</span> ArraySink( (byte*)&amp;result, <span class="hljs-keyword">sizeof</span>(result) )</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                     ) <span class="hljs-comment">// SignatureVerificationFilter</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>;<br><br><br><br>    <span class="hljs-comment">// 传统的C 方式 - 函数调用形式</span><br><br><span class="hljs-comment">//    result = verifier.VerifyMessage( (const byte*)message.data(), message.size(), (const byte*)signature.data(), signature.size() );</span><br><br>    <span class="hljs-keyword">if</span>(result)<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Verified signature on message&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">else</span><br><br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to verify signature on message&quot;</span> &lt;&lt; std::endl;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第三方库</tag>
      
      <tag>CryptoPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu-arm apt源配置</title>
    <link href="/2021/10/20/2021-10/2021-10-20%20Ubuntu-arm%20apt%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/10/20/2021-10/2021-10-20%20Ubuntu-arm%20apt%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="配置环境"><a class="markdownIt-Anchor" href="#配置环境"></a> 配置环境</h1><p>PC：M1 MacBook Air</p><p>虚拟机软件：Parallel Desktop 16.5</p><p>虚拟机操作系统：<a href="https://ubuntu.com/download/server/arm">Ubuntu Server 20.04 TLS</a></p><h1 id="遇到问题"><a class="markdownIt-Anchor" href="#遇到问题"></a> 遇到问题</h1><p>首先就是随便搜索了一篇网上教程，来配置apt源，比如这篇</p><p><a href="https://blog.csdn.net/p1279030826/article/details/111640455">https://blog.csdn.net/p1279030826/article/details/111640455</a></p><p class='note note-info'>要注意自己的ubuntu版本和apt源设置的版本一致</p><p>但是然后呢，满怀期待执行<code>sudo apt-get update</code> 却报错了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110201532536.png" alt="apt-get update报错 " /></p><p>当时很郁闷啊，因为之前在windows虚拟机上配置的时候都好使的，怎么到你这就拉胯了呢？</p><p>后来在网上找各种资料、解决办法，有的说是网络的问题，有的说是DNS解析的问题，但经过各种尝试都没有效果，后来无奈放弃，就此作罢。</p><h1 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h1><p>但是天无绝人之路，当我第二次再次尝试配置的时候，终于让我找到了正确答案：<a href="https://zongxp.blog.csdn.net/article/details/90604966?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link">解决方案</a></p><p>重点就是后缀要加上-ports，这样对应的镜像源才是arm源，才能适配M1的mac系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">deb http://mirrors.aliyun.com/ubuntu-ports/ focal main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-proposed main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu-ports/ focal-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>​</p><p>换源之后执行成功，nice！</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110201533176.png" alt="apt-get update成功" /></p><h1 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h1><p>总的来说踩了个坑，而究其原因，还是自己对这个apt配置参数没有理解到位，仅仅只是照猫画虎，复制教程，而没有领会其中的真意。同时对这个系统架构arm 和 x86的差异没有深刻认识，不同架构之间软件肯定是需要进行适配的，没有很清楚的认识到这一点。所以呢，学海无涯，我还差得远呢~</p><div align='center'><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110251023808.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" width="50%" height="50%" align="middle" ></div>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题01】白皮书导读</title>
    <link href="/2021/10/16/2021-10/2021-10-16%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9801-%E7%99%BD%E7%9A%AE%E4%B9%A6/"/>
    <url>/2021/10/16/2021-10/2021-10-16%20%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9801-%E7%99%BD%E7%9A%AE%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="论文概述"><a class="markdownIt-Anchor" href="#论文概述"></a> 论文概述</h1><p>论文地址：<a href="https://bitcoin.org/bitcoin.pdf">https://bitcoin.org/bitcoin.pdf</a></p><p>由于在“基于信任”模式下的交易，存在交易成本增加、限制了交易额的大小即阻断小额交易、商家欺诈行为等问题，本论文提出解决方案即比特币，这是一个P2P分布式的电子现金交易网络，依靠hash和加盖时间戳，以及工作量证明机制等手段，解决了双重支付问题，并在极大程度上保证了交易的有效性、正确性、抗伪性。论文中也详细介绍了实现所用到的技术、机制、原理等。</p><h1 id="主要收获"><a class="markdownIt-Anchor" href="#主要收获"></a> 主要收获</h1><p>个人感觉最大的收获就是对比特币的运行机制有了大体的认识，了解了整体流程，虽然可能一些技术的实现细节还是不够明朗。下面就是我对其中各个部分的认识和理解。</p><ul><li>在引言介绍部分，引出了比特币的产生背景，基于第三方机构的交易存在的种种问题，并提出比特币这一解决方案。然后接下来的各个章节介绍比特币涉及的主要关键技术。</li><li>Transactions部分描述了交易是如何被记录的，其中运用了Hash和公私钥，但仅仅记录是无法验证交易的有效性，即存在双重支出问题。</li><li>Timestamp Server部分描述了具体每个节点（服务器）的工作，即对形成的区块进行Hash，并加盖上时间戳，根据时序进行排列形成链。</li><li>Proof-of-Work部分描述了进一步说明Timestamp server的实现，即使用工作证明机制，通过找到满足条件的nonce来获得记账权，因为寻找这个nonce依靠CPU算力，CPU算力越高找到的概率越大，即one-CPU-one-vote规则，解决了多数决策中的代表问题。同时这样的方式，也保证了如果攻击者想要篡改某个区块，就先得把这个区块之后的区块都进行修改，而每个区块都是需要靠大量CPU算力来找到nonce，获得记账权进行修改，这样的成本是很大的。</li><li>Network部分则是描述了比特币网络的工作流程。其中提到的一个很重要的原则就是，所有人是默认最长链是最正确的。而正是有这一前提，才有了只要网络里超过51%的算力属于诚实节点，就能保证区块链里交易信息的正确性，因为诚实节点的算力超过一半，算得比攻击节点快，那么最长链肯定属于诚实节点一方。</li><li>Incentive部分说明的是激励机制，给予抢到记账权的节点一定的比特币，正是有这样的激励机制，各个节点才会愿意投入算力去争夺记账权，也才能是之前的工作量证明机制正常运行。还有一种就是以交易手续费的方式进行奖励。</li><li>Reclaiming Disk Space部分说明区块链可以通过Merkel Tree技术方法来压缩数据，减小空间存储。</li><li>Simplified Payment Verification部分则是说明了如何来检验交易的有效性，因为基于之前最长链总是正确的原则， 因此只要向网络上的节点进行询问，找到最长链就可以验证所有的有效交易记录。</li><li>Combining and Splitting Value部分描述的是形成交易的细节，是可以有多个输入的，而输出最多是两个。</li><li>Privacy部分则是说明比特币网络中的隐私相关问题。</li><li>Calculations部分用具体的数学计算来说明了，当一个攻击者在落后最长链Z个块的情况下，想要追上最长链的概率。结果表明，当落后的块数越多，追上的概率就越小，也就保证了区块链的安全性和稳定性。</li><li>Conclusion部分则是最后进行了总结。</li></ul><h1 id="存在疑问"><a class="markdownIt-Anchor" href="#存在疑问"></a> 存在疑问</h1><ul><li><strong>问题1：怎么理解数字货币中的double-spending problem？</strong></li></ul><p>用数字货币交易时，是用先前的交易和下一个拥有者的公钥做Hash，然后用拥有者的私钥进行签名形成这一次交易，比如这次交易A支付给B 1个电子货币，然后A的余额只有1个电子货币，如果没有第三方机构进行监管，确认这个电子货币已经交易出去了，那么A可以继续拿这1个电子货币继续交易，而接受者也无法确认这1个电子货币是否真正的属于他。也就是说，没有第三方监管机构，也没有引入区块链P2P这个网络的话，相当于就没有办法确认交易的有效性，这里产生的交易仅仅起到一个记录的作用。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110162135282" alt="交易链示意图" /></p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110162150429.png" alt="双重支出问题" /></p><ul><li>进一步，那么比特币是怎么解决这个问题的呢？</li></ul><p>比特币建立起了一个用工作量证明机制的P2P网络，网络上的节点都可以进行记账（也就是记录交易信息），记账的方式是基于区块链技术，区块上记录着一段时间内的交易信息，然后按时序用链串联起来，就有了所有的交易信息；同时最长的区块链是被网络上的节点所共同认可是正确的，即相当于第三方监管的确认作用，证明某次交易有效。</p><p>用上面的例子继续说明A的余额只有一个，然后他又同时和B、C进行交易，这两条交易信息传播到网络上，各个节点进行记录。有节点先收到A给B一个比特币的消息，他们检查余额之后会自动忽略另外一条交易消息（这个检查应该是基于他们当前的链？）；同样，会有先收到A给C一个比特币消息的节点，在检查余额之后也会自动忽略另外一条消息。接下来算力最高的（CPU最多的）节点获得记账权，把他记录的区块加到主链上，然后网络上其他节点都会以主链上的交易信息为准。如果放入主链的交易信息是A转给B一个比特币，那么B将会获得比特币，交易的有效性得到确认；同理，如果放入主链的交易信息是A转给C一个比特币，那么C将会获得比特币。</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110162150837.png" alt="区块链解决双重支出问题" /></p><ul><li><p><strong>问题2</strong>：不过这样又引出一个问题，这个主链是怎么确定下来，或者说找到的呢？是假设大部分节点都是有着相同的最长主链，然后直接在本地的区块链上加上最新的，然后把新产生的区块信息广播出去？然后再根据最长主链正确性的假设前提，其他节点根据该最长主链更新本地的区块链</p></li><li><p><strong>问题3</strong>：在上面的例子里，还有一个问题，怎么去检验一个交易里付款者的余额？或者说怎么找到该付款者之前的所有交易记录？用公私钥的话好像不太行，因为每次都可能变换。还是说这个账户是可以直接找到的，那隐私性是怎么保护？</p></li><li><p>**问题4：**文中的网络部分提到了容错性，即有的网络节点可能会丢失之前的区块信息，那么这些节点该怎么找到当前的最长主链？</p><ul><li>我理解每次传播的区块都是最新的区块，节点会因此意识到自己丢失了区块信息（这个怎么意识到也是个问题，用最新区块里的的prev hash来验证？），那么怎么来获取丢失的区块信息呢？是从最新区块广播节点那拉取区块吗？</li></ul></li><li><p><strong>问题5</strong>：Merkel Tree剪枝压缩的具体实现</p></li><li><p><strong>问题6</strong>：论文通篇介绍了比特币的实现原理，那么比特币有什么问题，缺点呢？</p></li><li><p><strong>问题7</strong>：在存储部分提到，因为Merkel Tree的技术，存储并不是问题，那么有没有可能用优势来弥补劣势，像是空间换时间？</p></li></ul><h1 id="所思所感"><a class="markdownIt-Anchor" href="#所思所感"></a> 所思所感</h1><ul><li>比特币本身没有价值，但是却有着无比昂贵的价格，甚至有大量的电力、算力耗费在这上面，进行所谓的“挖矿”，从中获得真实的金钱财富，这对我来说有些不可思议，难以理解。我自身也说不太清楚，可能这是个哲学问题？一个从计算机里产生的电子货币，对现实世界没有实质性的价值或者说实用性，为什么却能被人们追捧，赋予了天价？把那些花费在找随机数、挖矿的电力和算力用在更需要的地方，会不会能创造有实际价值的事物？</li><li>通过阅读本篇论文，了解比特币大致的工作流程，实现原理，也认识到比特币最大的特点就是去中心化，没有了第三方机构，改变以往“基于信任”的交易模式，或许正是这种去中心化的、隐蔽的并且可靠的交易方式满足了一定人群的需求（可能并不正当），逃离政府监管，以我们的国情来说，这是不可接受的，对大部分人或许也不好理解。但是区块链这种技术，这种去中心化的网络不一定要落地在电子货币里，应该会有更广阔的应用场景，也需要我自己再学习了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【比特币专题02】Developer Guide导读</title>
    <link href="/2021/10/11/2021-10/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9802-Developer%20Guide/"/>
    <url>/2021/10/11/2021-10/2021-10-11%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%93%E9%A2%9802-Developer%20Guide/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文阅读地址：<a href="https://developer.bitcoin.org/devguide/transactions.html">Bitcoin Developer Guide</a></p><p>预计通读耗时：12小时（个人数据，仅供参考）</p><p>中文翻译：</p><p><a href="https://www.8btc.com/books/834/bitcoin-developer-guide/_book/5/5.html">比特币开发者指南-巴比特图书</a></p><p><a href="https://www.bookstack.cn/read/bitcoin_developer_guide/README.md">简介 - 《比特币开发者指南 | Bitcoin Developer Guide》 - 书栈网 · BookStack</a></p></blockquote><h1 id="章节概述"><a class="markdownIt-Anchor" href="#章节概述"></a> 章节概述</h1><p>此次阅读的内容是比特币Developer Guide，详细介绍了比特币中各种设计和技术细节。</p><ul><li>Block Chain：介绍比特币的结构基础区块链，包括工作量证明，块高与分叉，交易数据，共识规则改变引起分叉等内容。</li><li>Transaction：详细介绍了比特币中交易的相关内容，重点说明了交易的组成，交易中的UTXO的类型（使用何种支付方式P2PKH或者P2SH）。</li><li>Contracts：这里的合约跟以太坊的智能合约不太一样，感觉更像是来说明交易双方（针对人而不是交易）该如何进行交易，应该遵守哪些规则。主要介绍了托管和仲裁、微支付通道、Coinjoin（混币）</li><li>Wallet：钱包用来管理和花费UTXO，因为UTXO实际对应的是一个hash地址，因此钱包实际就是在管理公私钥，这部分内容也就更多在介绍公私钥的管理问题。</li><li>Payment Processing：这部分重点介绍如何使用比特币进行支付的相关问题。</li><li>Operating Modes：介绍比特币中全节点和SPV客户端。</li><li>P2P Network：这部分就是详细介绍了比特币运行在P2P网络中相关细节，包括对等节点的发现与链接，全节点的初始化，区块传播等。</li><li>Mining：介绍了单独挖矿和矿池挖矿两种挖矿（添加新的区块）方式。</li></ul><h1 id="重点内容"><a class="markdownIt-Anchor" href="#重点内容"></a> 重点内容</h1><blockquote><p>大部分是阅读各个模块时记录下的重点内容。</p></blockquote><h2 id="block-chain-区块链"><a class="markdownIt-Anchor" href="#block-chain-区块链"></a> Block Chain 区块链</h2><ul><li>Block chain里UTXO的作用，只能使用一次，这也解决了双花问题</li><li>Proof of work里也是充分利用了加密hash算法里随机的天然特性，hash number不可预知<ul><li>每2016块调整难度值，根据生成这2016块block的时间来调整，理想时间是1,209,600秒(two weeks).</li></ul></li><li>Transaction data：block里的第一个交易是一个coinbase交易（由生成的区块奖励和输入输出费用差组成），通常只有在100块之后，才能被花费使用，这么做的目的是因为分叉比较常见，防止因为分叉的原因导致原先的区块失效<ul><li>有个问题是，如何保证必须要在100块之后才能进行花费，是在创建block的时候，判断输入的UTXO所在的区块的深度超过100吗？</li></ul></li><li>共识规则改变：共识规则改变，会有两种不同的情形，分别导致硬分叉和软分叉，不是很能理解其中的含义，查阅相关资料有了进一步认识。（现在比特币的更新，基本就是软分叉）</li></ul><blockquote><p><strong>常见的理解是“硬分叉和老版本软件不兼容、软分叉和老版本兼容”</strong>，这个定义是<strong>不准确</strong>的，但是很多地方已经在用了。。<br /><strong>硬分叉的定义是扩宽共识规则</strong>，允许做之前禁止的事情，以前无效的交易/区块在硬分叉后会变成有效的；<strong>软分叉是收紧共识规则</strong>，禁止之前允许做的事情，以前有效的交易在软分叉后就无效了。<br />**软/硬分叉是共识规则的改变，和链分叉/链重组完全是两码事；这两对概念的关系类似于“红烧/清蒸”与“烧糊/夹生”。**不当部署的软/硬分叉都有可能导致链分叉/链重组。<br />所以，可以想见：<br />硬分叉之后，几乎一定会产生让老节点拒绝接受的区块，所以，硬分叉会破坏前向兼容性；<br />软分叉之后，产生的新区块肯定是老节点也愿意接受的，前向兼容性得以保留。</p></blockquote><ul><li>Detecting forks 发现分叉：通过监控区块链工作量证明而发现硬分叉的代码；监控最近区块的版本号</li></ul><h2 id="transaction交易"><a class="markdownIt-Anchor" href="#transaction交易"></a> Transaction交易</h2><ul><li><strong>P2PKH</strong> 即 pay to public key hash，向公钥哈希地址支付<ul><li>交易的输入使用一个TXID和output index number（对于output来说处在交易的哪个位置）来标识，然后还有一个签名脚本，验证该input对应的output包含的公钥脚本，用来证明这笔输入的钱的确是本人持有</li><li>交易的输出包含一个隐含的index number，以聪为单位的余额量，一个公钥脚本</li><li>Bob要使用Alice的支付给他的UTXO，Alice创建转账的Tx交易时需要用到Bob的公钥，因此Bob的公私钥是提前生成好的，使用ECDSA椭圆签名曲线生成；然后Bob将公钥hash，使用Base58编码地址版本编号、公钥哈希、错误校验码，然后传给Alice，Alice可以进行解码得到公钥hash，并添加到交易中，作为output中的pubkey script，来标识输出到哪个地址；</li><li>而当Bob需要使用这份UTXO，发布交易时，需要构造input，引用Alice创造的交易TX（即TXID和对应的output index number），还需要包含一个签名脚本(signature script），这个签名脚本用来验证这笔输入的确是Bob所有。这个签名脚本里包含了Bob的公钥和签名，而签名的数据包含了Alice创造的交易TXID和index number，输出给其他用户的pubkey script，输出的余额。而输出output，正如上述所说，包含一个隐含的index number，以聪为单位的余额量，一个公钥脚本。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350637.(null)" alt="" /></p><ul><li><p><strong>P2SH</strong>：提出P2SH的目的主要是因为在之前的交易中，都是由发送者负责指定赎出币的条件。这样的话，如果赎出币的过程比较复杂，譬如要使用MULTISIG，那么对付钱的用户，也就是买家，就不够友好。使用P2SH的方式，可以由币的接收方设计好执行的脚本，然后不论脚本多么复杂，发送方只需要将币发送到一个20字节的哈希地址就行。</p><ul><li>有关资料参考：<a href="https://zhuanlan.zhihu.com/p/46072343">P2SH机制</a></li></ul></li><li><p>标准的公钥脚本类型：P2PKH、P2SH、Multisig、Pubkey、Null Data</p></li><li><p>交易中Locktime和Sequence numbers的说明</p><ul><li>Locktime, 也被称为nLockTime, 它定义了个最早时间，只有过了这个最早时间，这个transaction可以被发送到比特币网络。通常被设置为0，表示transaction一创建好就马上发送到比特币网络</li><li>Sequence numbers用来使签名者更新交易，如果sequence numbers设置成0xffffffff时，表明更新完成，就可以立即生效加入到比特币区块中，这个生效是不管Locktime是否过期。</li><li>另一种理解：<ul><li>LockTime ：绝对时间，用的是整个区块链的长度，或者时间戳来表达的。</li></ul></li></ul></li><li><p>Sequence Number : 相对时间，当前交易所引用的UTXO所在的块（也就是输入所在的块），后面追加了多少个块。</p></li><li><p>参考：<a href="https://zhuanlan.zhihu.com/p/43171481">深入浅出微支付通道</a></p></li></ul><h2 id="contract合约"><a class="markdownIt-Anchor" href="#contract合约"></a> contract合约</h2><ul><li>结合之前的P2SH方式中，对multisig有了更进一步的理解。A向B买东西，A使用P2SH，把钱支付到一个脚本地址并使用2-of-3签名（此时比特币只属于这个脚本地址），当B发货了，A收到确认没问题了，那么使用A和B的签名就可以把脚本地址的UTXO转给B的地址。如何A反悔了，不肯提供签名，那么B可以找仲裁机构C，使用B和C的签名也能将脚本地址的UTXO转给B；同理B如果没有发货，A也能找C把钱转回给A。也就是说，相比P2PKH直接转账方式，P2SH相当于多了一步验证等待，验证成功了再转账到用户地址。</li><li>Micropayment Channel 微支付通道</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350785.(null)" alt="" /></p><ul><li><p>其工作原理大体上可以这样描述：A给B打工，B首先使用A和B的签名，使用P2SH的方式，发送一定金额到脚本地址，并将该交易立即传播到比特币网络上；然后B创造第二个交易，并用到刚刚A的签名，其输入是第一个交易的脚本地址，输出是B的地址（相当于全额返回给B），然后给这个交易加上Locktime，比如说一天后才能广播这个交易。然后A给B工作一部分内容后，A要求B先支付这份工作量的薪水，那么B就创建一份新的交易，从原来全额给B变成分出一部分金额给A，这个新的交易拷贝给A，这样A就可以广播这个新的交易从而获得薪水。（实际上A只需要在locktime过期前，广播最后版本的交易即可）</p></li><li><p>为什么采用这样的方式呢，因为A诉求是及时支付薪水，但是因为量小，B不能每次都立即创造一个交易即刻支付，这样的交易费的成本太高了。所以利用这样的方式，既确保了A的薪水是及时得到确认的，又可以使得只需一个交易就一次性支付薪水</p></li><li><p>实际上，更改交易金额的输出，这个权利是在B的，因为B有A的签名但A没有B的签名，A拿的是经过B签名后的交易副本（这个交易被B签名过了，所以是有效的）。所以A能实时确保自己对应工作量的薪水能及时支付，就算中途B跑路了，也只是损失一小部分工作量的薪水，之前的薪水都可以得到支付。而对B来说，如果A没有工作，那B也能在locktime 过期后拿回自己的钱（不过这样就需要等待一个locktime的时间）</p></li><li><p>Coinjoin混币交易，增加隐匿性，保护隐私，当和其他输入输出混杂在一起时，别人就难以追踪输出记录了</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350075.(null)" alt="" /></p><h2 id="wallet钱包"><a class="markdownIt-Anchor" href="#wallet钱包"></a> Wallet钱包</h2><ul><li>钱包程序主要可分为三个子程序，一个程序来发布公钥用于接收比特币，而另一个程序对交易做签名来花费比特币，还有一个网络程序用来跟P2P网络交互。更具体地说，一个完整的钱包程序应包括这些功能：生成私钥，生成对应的公钥，按照需要对公钥进行发布，监听以这些公钥作为输出的交易，创建交易并对其进行签名，广播已签名的交易。</li><li>Wallet file 是对私钥进行管理；描述了私钥和公钥的格式</li><li>参考：<a href="https://blog.csdn.net/omnispace/article/details/79816141">数字货币钱包 - 助记词 及 HD 钱包密钥原理_omnispace的博客-CSDN博客</a></li></ul><h2 id="payment-processing-支付处理"><a class="markdownIt-Anchor" href="#payment-processing-支付处理"></a> Payment Processing 支付处理</h2><ul><li>介绍四种支付比特币的方式和相关的具体细节，包括明文，bitcoin:URI，QR码，新的支付协议X.509</li><li>其中提到一种“Merge Avoidance合并规避”的方法来保护用户隐私，该方法大体的意思就是让减少各个账户连接在一起的次数（或者说减少输入的个数）。因为当你使用UTXO作为输入进行花费时，UTXO原先的owner就可以追溯这次交易的信息，输入的UTXO越多那么能追溯到这笔交易的人就越多，隐私就会受到影响。用官方的例子来说，你有100，200，500，900的UTXO，然后你现在需要支付300BTC，那么你该选用500的UTXO来进行支付（而不是选择100，200作为输入，体现了合并，规避风险）。</li></ul><h2 id="operating-modes运行模式"><a class="markdownIt-Anchor" href="#operating-modes运行模式"></a> Operating Modes运行模式</h2><ul><li>比特币主要有两种运行模式：一个是全节点客户端（包含所有区块和交易信息），一个是SPV客户端（只保存区块头信息）。SPV客户端可以通过请求全节点拿到相应的区块信息，进行验证。然而SPV客户端有两个缺点，一个是可能会被全节点欺骗，解决办法是连接多个全节点，保证不要和诚实节点断开链接了；另一个是容易受到拒绝服务攻击，解决办法是布隆过滤器</li><li>参考：<a href="https://shuwoom.com/?p=857">布隆过滤器(Bloom Filter)、SPV和比特币 - shuwoom的博客</a></li></ul><h2 id="p2p网络"><a class="markdownIt-Anchor" href="#p2p网络"></a> P2P网络</h2><ul><li>因为共识规则不包括网络，所以有可选的网络和协议。这里用Bitcoin Core作为全节点代表，BitcoinJ作为SPV客户端代表。</li></ul><h3 id="peer-discovery"><a class="markdownIt-Anchor" href="#peer-discovery"></a> Peer Discovery</h3><ul><li>首先通过询问DNS seeds来获取对等网络其他有效运行的节点IP，和对等节点建立连接后，可以获取得到更多的网络节点IP。此外，在程序中会有一些固定的静态IP可以尝试连接，或者使用命令行工具尝试与指定IP连接。</li></ul><h3 id="connecting-to-peers"><a class="markdownIt-Anchor" href="#connecting-to-peers"></a> Connecting to Peers</h3><ul><li>节点通过发送version消息连接到一个对等节点。消息version 包含了节点的版本信息、块信息和距离远程节点的时间。一旦这个消息被对等节点收到，它必须回复一个verack。如果它愿意建立对等关系，它将发送自己的version消息。</li><li>一旦建立对等关系，节点可以向远程节点发送getaddr和addr消息来获得其它的对等节点信息。为了维持与对等节点的连接，节点默认情况下每30分钟内会给对等节点至少发送一次信息。如果超过90分钟没有收到回复，节点会认为连接已经断开</li></ul><h3 id="initial-block-download"><a class="markdownIt-Anchor" href="#initial-block-download"></a> Initial Block Download</h3><ul><li>一个全节点在正式工作或者提供服务前，需要进行初始化，把除了硬编码生成的第一个区块外的所有区块下载下来，这个过程就是IBD。</li><li>Block-First 是其中一种下载方式，向一个对等网络节点进行询问，直接下载区块，其缺点也很明显<ul><li>下载速度的限制：只从一个同步节点下载，受限该节点的带宽</li><li>重新下载：同步节点可能会发送不是最长链上的区块，就会导致快结束时才发现需要重新下载</li><li>磁盘空间占用：和“重新下载”相关，下载时可能会将无用的区块保存到磁盘，占用空间</li><li>大量内存使用：因为同步节点发送过来的区块可能是无序的，所以需要先保存到内存中，直到接收到父块才能进行验证</li></ul></li><li>Header-First 的下载方式，解决了Block-First中四个缺陷，它的工作方式是：先向同步节点下载block headers，当部分地验证headers有效性后，IBD节点就可以并行地做两天事——一个是继续向同步节点发送请求下载headers，另一个是向其他对等节点发送请求下载block</li></ul><h2 id="mining-挖矿"><a class="markdownIt-Anchor" href="#mining-挖矿"></a> Mining 挖矿</h2><ul><li>现在有两种挖矿方式：单独挖矿和矿池挖矿<ul><li>单独挖矿：bitcoind来获取P2P网络上的交易，挖矿软件通过RPC方法来获取列表，并构造一个Block模板，然后将对应的block header发送给ASIC进行运算。挖矿软件会将一个nonce值填入币基交易的的字段中，获得新的Merkle root的hash值，然后将新的Block header发送个ASIC。如果ASIC计算生成的block header hash小于预定的阈值，则表明添加的nonce值符合条件，将block header返回给挖矿软件，挖矿软件根据返回的block header更新block，最后将完整的block 返回给bitcoind，bitcoind再向网络传播区块</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350617.(null)" alt="" /></p><ul><li>矿池挖矿：工作流跟单独挖矿类似。不同的是，矿池设定的阈值要比网络上设定的阈值小很多（降低了难度），因此各个矿工通过挖矿软件返回给矿池的block hearder中，有很多是满足矿池的阈值但不满足网络的阈值，这些返回的block header相当于是份额，证明了矿工的工作量；同时总会有几率产生同时满足两个阈值的block header，矿池将满足网络阈值条件的block发送给bitcoind，从而获得奖励。然后矿池根据矿工贡献的份额，平均分发奖励。举个具体例子就是，矿工们总共返回了100个满足矿池条件的block header（相当于有100份额），只有1个满足网络阈值，那么每份额的奖励就是总奖励的1/100，矿工根据自己的份额获得相应奖励。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110111350905.(null)" alt="" /></p><ul><li>还介绍了三种挖矿软件获取Block的RPC<ul><li>getwork RPC：当前Bitcoin Core已经废弃，这个方法直接为矿工构造好block header，因此矿工可能需要调用成百上千次RPC</li><li>getblocktemplate RPC：获取以下内容；然后挖矿软件就能自己改变nonce值，自己生成block header<ul><li>构造币基交易的信息</li><li>bitcoind发送给矿池的交易列表和具体交易信息，这使得挖矿软件可以查看交易，并有选择性地添加或删除交易</li><li>构造block header的其他信息</li><li>矿池提供的难度值或者网络设定的难度值</li></ul></li><li>Stratum：跟getblocktemplate很类似，但是不同的是，挖矿软件获取到的是重新构造Merkle树的必要信息，而不是具体的交易列表和交易内容。因此，挖矿软件不能添加或者删除交易，不过此时挖矿软件和矿池建立双向的TCP连接；在getblocktemplate 里，挖矿软件用的是HTTP longpoll长轮询，来获取最近的更新。</li></ul></li></ul><h1 id="存在疑问"><a class="markdownIt-Anchor" href="#存在疑问"></a> 存在疑问</h1><p>阅读完所有内容后，还是有很多问题和细节没有弄明白。</p><ol><li>原文：Since it is impractical to have separate transactions with identical txids, this does not impose a burden on honest software, but must be checked if the invalid status of a block is to be cached; otherwise, a valid block with the duplicates eliminated could have the same merkle root and block hash, but be rejected by the cached invalid outcome, resulting in security bugs such as <a href="https://en.bitcoin.it/wiki/CVEs#CVE-2012-2459">CVE-2012-2459</a>.</li></ol><blockquote><p>对于上述内容不是很能理解，不同的transactions怎么会有相同的TXID，可能是由于hash冲突导致的？虽然概率很小。然后“对于缓存一个无效区块的状态”，这该如何理解？什么时候用到了缓存，缓存什么内容（区块的状态？），以及如何判断区块是有效还是无效？如果因为有TXID冲突判定区块无效的话，可以去重TXID，达到有效？</p></blockquote><ol><li>标准交易中，Null Data的的pubkey scripts类型用来干什么的？</li><li>P2PK 被 P2PKH所取代了，支付到公钥哈希的地址，可以使得公钥直到UTXO被使用时才会发布，延迟公钥发布的原因是什么呢？是为了避免攻击者利用公钥进行某些攻击吗？</li><li>多种Signature hash types的用途是什么呢？为什么要有选择性的进行签名？</li><li>交易被打包到区块，交易的费用是根据交易的签名字节长度计算出来，那么这笔费是由买家（支付者）来付吗？在对应的一个交易中，是会增加一个output来指向矿工吗？</li><li>对于HD钱包，即分层确定性钱包中的工作原理还是不太理解，特别是extened keys到harderned keys的转变，为什么要这么做？这么做如何解决问题的？</li><li>SPV客户端具体是怎么使用布隆过滤器的？</li><li>矿工发布区块时，具体是怎么给矿工发放奖励的？是在创建区块的时候，直接生成一个币基交易（把钱转账给该矿工），然后矿工打包所有交易后，开始找满足条件的nonce，找到后广播区块，这样如果区块得到其他节点认可上链了，那么矿工就切实得到了收益。（这样的话，每个节点在生成区块）</li></ol><h1 id="所思所感"><a class="markdownIt-Anchor" href="#所思所感"></a> 所思所感</h1><p>阅读完这篇Guide概览，让我认识了解比特币中许多技术和实现细节，但是通读完一遍后，发现自己好像懂了，又好像没懂，或者说从整体上对比特币的整体架构有了一定的认识，具体有哪些部分组成，涉及哪些关键技术，但是对个各个模块进一步的细节还是似懂非懂，并且还是难以串联起来，各个部分有明显的联系（比如交易与钱包与支付处理），但是感觉自己还是很难将这三者的关系表示清楚，或者说，当把整个比特币看做一个整体时，各个部分是怎么样有机独立又相互配合的。</p><p>还有一个简单的思考，就是对于合约部分中多重签名的使用，例如托管和仲裁，A和B之间的交易还是要依赖于仲裁第三方C，这是否与比特币去中心化的思想相矛盾了呢？后来进一步思考和查阅资料，从另一个视角去看，去中心化，不是不要中心，而是由节点来自由选择中心、自由决定中心。简单地说，中心化的意思，是中心决定节点。节点必须依赖中心，节点离开了中心就无法生存（类似于没了支付宝就不能用淘宝？）。而在去中心化系统中，任何人都是一个节点，任何人也都可以成为一个中心。任何中心都不是永久的，而是阶段性的，任何中心对节点都不具有强制性。</p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>比特币</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitcoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【99%环境搭建系列】云计算管理平台Devstack安装</title>
    <link href="/2021/10/08/2021-10/2021-10-08%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97%20-devstack%E5%AE%89%E8%A3%85/"/>
    <url>/2021/10/08/2021-10/2021-10-08%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97%20-devstack%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p class='note note-success'>99%概率完成环境搭建，让天下没有搭建不了的环境！ </p><p>openstack作为开源的云计算管理平台，可以让我们体验云计算技术的各种组件和功能，然而官网繁琐的配置教程令人望而却步。好在devstack提供了一站式安装服务，<s>只需简单执行几个命令即可完成安装</s>（根本不是这样好吗！）。不过经过我的百般测试，只要安装教程里的方式执行命令，成功概率99%！</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082112035.png" alt="" /></p><h1 id="安装环境"><a class="markdownIt-Anchor" href="#安装环境"></a> 安装环境</h1><p>这里说一下我个人的安装环境</p><ul><li>PC操作系统：win10</li><li>VMware Workstation版本：16.x Pro</li><li>Ubuntu版本：18.04</li></ul><h1 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h1><ol start="0"><li><strong>简要说明</strong></li></ol><p class='note note-primary'>ubuntu操作系统在虚拟机的安装这里不再演示，假设你已经完成了ubuntu18.04的安装，然后继续；<br>在~/ 目录下，依次执行命令即可，没有特殊说明，不用执行别的多余命令</p><ol><li><strong>设置静态IP（可选）</strong></li></ol><blockquote><p>说明：这一步是可选的，之所以设置成静态IP，是为了方便后面的配置，以及排除IP变动的原因导致的种种意外；不过不进行配置的话，应该也是ok的，只要保证整个安装以及使用过程IP不会改变</p><p>参考网站：<a href="https://www.cnblogs.com/yaohong/p/11593989.html">ubuntu配置静态ip</a>       <a href="https://blog.csdn.net/zh2508/article/details/85250360">VMware配置静态ip</a></p></blockquote><p>首先给机器设置静态ip，修改<code>/etc/netplan</code>目录下对应的文件，按如下文件进行配置。</p><p class='note note-info'>  三个注意点：<br>  1. 注意配置里的"ens32" 根据自己的机器进行改动，可能是"ens33"，可以通过命令 ip addr 来进行查看 <br>  2. 这里复制的话，注意复制后的结果是否一致，可能需要自己手动输入一下，这样的话要严格注意格式，冒号后面需要一个空格，换行缩进是4个空格<br>  3. 设置的ip和网关要在同一个网段上，记住这里填入的ip，需要用在下面的配置中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br><span class="hljs-attr">network:</span><br><span class="hljs-string">​</span>    <span class="hljs-attr">ethernets:</span><br><span class="hljs-string">​</span>        <span class="hljs-attr">ens32:</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]<br><span class="hljs-string">​</span>            <span class="hljs-attr">optional:</span> <span class="hljs-literal">true</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.2</span><br><span class="hljs-string">​</span>            <span class="hljs-attr">nameservers:</span><br><span class="hljs-string">​</span>                    <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.1</span>,<span class="hljs-number">192.168</span><span class="hljs-number">.17</span><span class="hljs-number">.2</span>] <span class="hljs-comment"># 这里DNS的修改，是因为我配置了上面VMware配置静态ip</span><br></code></pre></td></tr></table></figure><p>然后执行<code>sudo netplan apply</code>，让配置生效，再通过<code>ip addr</code>查看是否生效，已经<code>ping</code>命令查看网络是否连通</p><ol start="2"><li><strong>切换apt源</strong></li></ol><p>切换apt源的目的是为了加快下载安装的速度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install vim #先安装下vim<br>sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak<br>sudo vim /etc/apt/sources.list # 如果vim还没有安装，改用 vi 复制下就行<br></code></pre></td></tr></table></figure><p>这里配置用的是阿里云的镜像，如果之后因为网络的问题可以尝试换下别的源，不过我测试使用的都是阿里云</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 注意ubuntu版本号对应不同的代号，这里用的是18.04，对应bionic</span><br>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>更换pip源</strong></li></ol><p>也是为了加快下载安装依赖的速度</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir .pip<br>vim .pip/pip.conf<br></code></pre></td></tr></table></figure><p>配置如下所示，用的是豆瓣的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[global]<br>index-url = http://pypi.douban.com/simple/<br>trusted-host = pypi.douban.com<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>更新并安装包</strong></li></ol><p>依次执行下列命令，主要是更新安装相关依赖，下载pip管理依赖工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get upgrade<br>sudo apt-get install git<br>sudo apt-get install python-pip<br>sudo pip install --upgrade pip<br>sudo pip install -U os-testr  # sudo pip install wcwidth 可选，如果这一步出了wcwidth相关的error的话<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>设置时区同步</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install ntpdate // 安装时间同步工具<br>sudo ntpdate cn.pool.ntp.org // 与网络服务器同步时间<br>date // 查看时间是否已经同步<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>下载devstack</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/openstack/devstack.git -b stable/queens</span> <br><span class="hljs-meta">#</span><span class="bash"> 推荐使用opendev.org官网的wallby这个分支，github上对应的queens这个分支尝试过有问题解决不了</span><br>git clone https://opendev.org/openstack/devstack.git -b stable/wallaby <br></code></pre></td></tr></table></figure><ol start="7"><li><strong>创建stack用户</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo devstack/tools/create-stack-user.sh<br></code></pre></td></tr></table></figure><ol start="8"><li><strong>移动并设置文件夹权限</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mv devstack /opt/stack<br>sudo chown -R stack:stack /opt/stack<br>sudo chown stack:stack /opt/stack<br></code></pre></td></tr></table></figure><ol start="9"><li><strong>切换到stack用户</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo su - stack<br></code></pre></td></tr></table></figure><ol start="10"><li><strong>创建local.conf配置文件</strong></li></ol><p>执行下列命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd devstack<br>vim local.conf<br></code></pre></td></tr></table></figure><p>配置文件内容如下，<strong>注意修改HOST_IP</strong>，改成自己当前的IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[[local|localrc]]<br><span class="hljs-meta">#</span><span class="bash"> Define images to be automatically downloaded during the DevStack built process.</span><br>DOWNLOAD_DEFAULT_IMAGES=False<br>IMAGE_URLS=&quot;http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> use TryStack git mirror</span><br>GIT_BASE=http://git.trystack.cn<br>NOVNC_REPO=http://git.trystack.cn/kanaka/noVNC.git<br>SPICE_REPO=http://git.trystack.cn/git/spice/sice-html5.git<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> Credentials</span><br>[[local|localrc]]<br>ADMIN_PASSWORD=admin<br>DATABASE_PASSWORD=$ADMIN_PASSWORD<br>RABBIT_PASSWORD=$ADMIN_PASSWORD<br>SERVICE_PASSWORD=$ADMIN_PASSWORD<br><span class="hljs-meta">#</span><span class="bash"> Host IP - get your Server/VM IP address from ip addr <span class="hljs-built_in">command</span></span><br>HOST_IP=192.168.10.112 # ifconfig获取本机ip<br>enable_service placement-api<br>enable_service placement-client<br></code></pre></td></tr></table></figure><ol start="11"><li><strong>提前下载依赖包</strong></li></ol><p>因为是从github上连接下载依赖包，可能由于网络不好的问题，直接安装的话可能中途会因为下载失败导致安装失败，所以这里提前下载；如果下载失败了，就多执行几次，肯定是可以的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd files/<br>wget -c https://github.com/coreos/etcd/releases/download/v3.1.10/etcd-v3.1.10-linux-amd64.tar.gz<br>wget -c https://github.com/coreos/etcd/releases/download/v3.1.7/etcd-v3.1.7-linux-amd64.tar.gz<br>wget -c https://github.com/etcd-io/etcd/releases/download/v3.3.12/etcd-v3.3.12-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><ol start="12"><li><strong>安装simplejson</strong></li></ol><p>经过测试，之后安装的过程中可能会报错simplejson安装失败，所以这里提前进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> sudo apt-get purge python3-simplejson 清楚之前的软件包和配置</span><br>sudo apt-get install python3-simplejson<br><span class="hljs-meta">#</span><span class="bash"> sudo apt-get install python-simplejson <span class="hljs-comment"># 上面的命令不行可以试下这个</span></span><br></code></pre></td></tr></table></figure><ol start="13"><li><strong>修改pip安装配置</strong></li></ol><p class='note note-info'>  在测试中，pip相关安装可能会报错，这里提前修改下</p><p>修改对应的目录文件 <code>devstack/inc/python file 198 line</code></p><p>源代码 <code>$cmd_pip $upgrade</code></p><p>修改成 <code>$cmd_pip $upgrade --ignore-installed</code></p><ol start="14"><li><strong>修改权限</strong></li></ol><p>经过测试，之后安装的过程可能会出现如下权限错误的错误，所以这里再次修改权限</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082049771.png" alt="pip下载报错" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chown -R stack:stack /opt/stack<br>sudo chown stack:stack /opt/stack<br>sudo chown -R stack:stack /opt/stack/devstack<br><span class="hljs-meta">#</span><span class="bash"> sudo chmod -R 777 /opt/stack  <span class="hljs-comment"># 先用前三个命令应该足够了，不行再试试这个</span></span><br></code></pre></td></tr></table></figure><ol start="15"><li><strong>开始安装</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>FORCE=yes ./stack.sh<br></code></pre></td></tr></table></figure><p>可能因为网络的原因，中途会连接不上github，导致安装失败，这样就需要重新尝试，先清理下环境再安装，多尝试几次应该都会成功的，不过确保网络质量也比较重要。</p><p>如果是因为下载github上某个依赖包导致的失败，可以事先安装好对应的依赖，使用pip命令下载即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">./unstack.sh<br>./clean.sh<br>FORCE=yes ./stack.sh<br></code></pre></td></tr></table></figure><ol start="16"><li><strong>见证奇迹的时刻</strong></li></ol><p>当你看到如下信息的时候，恭喜你，完成安装~</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110081954141.(null)" alt="成功截图" /></p><ol start="17"><li><strong>openstack界面展示</strong></li></ol><p>具体如何使用openstack，这里就不再详细演示，openstack功能大家就自行地快乐玩耍吧~</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110081954271.(null)" alt="openstack界面展示" /></p><h1 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h1><p>到此为止，devstack的安装教程就到此结束了，如果安装上面的步骤成功了，恭喜你我的朋友！</p><div align='center'><img src='https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082121023.jpeg' width='30%' height='30%' > </div><p>当然如果出现了别的问题无法解决的话，可以评论留下你的问题，或者与我联系。</p><hr /><p>如果真的山穷水尽了的话，microstack 官网教程值得你的拥有~</p><p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202110082124003.png" alt="" /></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://blog.csdn.net/hunjiancuo5340/article/details/85005995">https://blog.csdn.net/hunjiancuo5340/article/details/85005995</a></p><p><a href="https://blog.csdn.net/u013184378/article/details/84973629">https://blog.csdn.net/u013184378/article/details/84973629</a></p><p><a href="http://www.cnblogs.com/lianshuiwuyi/p/10955041.html">http://www.cnblogs.com/lianshuiwuyi/p/10955041.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>环境搭建系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devstack</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏王台词收录</title>
    <link href="/2021/09/30/2021-09/2021-09-30%20%E6%B8%B8%E6%88%8F%E7%8E%8B%E5%8F%B0%E8%AF%8D%E6%94%B6%E5%BD%95/"/>
    <url>/2021/09/30/2021-09/2021-09-30%20%E6%B8%B8%E6%88%8F%E7%8E%8B%E5%8F%B0%E8%AF%8D%E6%94%B6%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏王"><a class="markdownIt-Anchor" href="#游戏王"></a> 游戏王</h1><h2 id="凯撒亮"><a class="markdownIt-Anchor" href="#凯撒亮"></a> 凯撒亮</h2><p>因为之前也入坑过游戏王决斗链接国际服，也就组过月光、不知火、电子龙三套牌组，电子龙是我退坑前最后组的卡组，因此也有着特殊的感情。不久前听闻电子龙被彻底削废了，直接入土为安，心情也是五味杂陈，还能继续挣扎吗？</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202109301523396.jpg" alt="img" /></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202109301531454.jpg" alt="img" /></div></div></div><p><a href="https://www.bilibili.com/video/BV12b4y1C7wC">【日语每日一句】凯撒亮经典台词教学</a></p><p>Ko re ga, i ki no ku ru ta me no, o re no a ga ki da !</p><img src="https://cdn.jsdelivr.net/gh/2017zhangyuxuan/picture_backend@master//img/202109301537861.png" width="50%" height="50%" align="middle" ><p>你又是如何呢，你又是为了什么而奋战至今？只要为了达到理想的终点，就算是卑微的挣扎又如何，这就是我所选择的道路！！</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
      <category>动漫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏王</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Fluid主题博客搭建</title>
    <link href="/2021/09/28/2021-09/2021-09-28%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/09/28/2021-09/2021-09-28%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>其实这个前言应该叫做”后记“了，之前一直这篇文章一直处于草稿的状态，心想着等博客网站正式上线了再改也不迟，这一拖就是3、4个月，属实是惭愧。但欠下的债终归是要偿还的，不是吗？</p><h1 id="博客搭建"><a class="markdownIt-Anchor" href="#博客搭建"></a> 博客搭建</h1><p>其实网上搭建hexo博客的教程很多，感觉自己再重复造轮子也没什么必要，因此这里给出我在学习搭建博客过程中参考的一些文章博客：</p><ul><li><p><a href="https://evenweiss.github.io/2021-08-02-blog-building/#%E4%B8%80%E3%80%81Github-Pages-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%85%8D%E7%BD%AE">博客搭建教程</a></p></li><li><p><a href="https://www.cnblogs.com/mfrank/p/12829882.html">Hexo博客部署Github Pages</a></p></li><li><p><a href="https://blog.csdn.net/i_do_not_know_you/article/details/105594269">绑定域名的遇到坑</a></p></li><li><p><a href="https://hexo.fluid-dev.com/posts/fluid-write/">搭配 Fluid 如何优雅的写一篇文章</a></p></li></ul><h1 id="踩坑记录"><a class="markdownIt-Anchor" href="#踩坑记录"></a> 踩坑记录</h1><ol><li>绑定阿里云的top域名，解析成功的问题是：访问速度变得巨慢，并且页面效果很差，图片几乎展示不出来；和vercel部署出来的效果一致（是不是存在什么共性？）</li></ol><ul><li>这个问题后面也没有解决，令人惭愧，但我感觉是部署在境外服务器的问题？</li></ul><hr /><ol start="2"><li>当删除阿里云域名解析相关记录后，<a href="http://xn--2017zhangyuxuan-1u97bj59g.github.io">访问2017zhangyuxuan.github.io</a> 依然会跳转到注册的域名上kingofdark.top，然后报错HTTP 502</li></ol><ul><li>过了一天之后好像正常了，应该是DNS解析缓存的问题。</li></ul><hr /><ol start="3"><li>取消Waline评论时显示浏览器内核与操作系统信息</li></ol><ul><li>hexo-theme-fluid/source/css/main.styl 路径下添加以下配置 (不过好像只有本地预览有效，部署到Github pages上依然不生效；在Vercel部署的，同样也已经生效了)</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.vmeta</span> &#123;<br>  <span class="hljs-attribute">display</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>更好的做法是在服务端配置 DISABLE_USERAGENT 环境变量为true；重新部署后得到新的server url，一定要记得把这个server url填写到_config.fluid.yml文件中，更新！！ 这里踩了个大坑！！</li></ul><hr /><ol start="4"><li>因为我是使用typora来写本地博客的，写博客时会需要插入图片，因此配置图床还是挺有必要的，下面推荐两篇教程：</li></ol><ul><li><a href="https://zhuanlan.zhihu.com/p/365829157">Typora+PicGo+Github = Markdown编辑器+图床</a></li><li><a href="https://www.jianshu.com/p/1059cc94d63d">picgo + gitee 配置</a></li></ul><h1 id="进阶改动"><a class="markdownIt-Anchor" href="#进阶改动"></a> 进阶改动</h1><p>当能够正常搭建起本地博客后，可以尝试一些进阶改动，可以参考下面几篇文章：</p><ul><li><p><a href="https://github.com/qixa/hexo-theme-fluid-mod#%E8%AF%A6%E7%BB%86%E4%BF%AE%E6%94%B9%E4%BF%A1%E6%81%AF">Fluid主题进阶修改版</a></p></li><li><p><a href="https://2017zhangyuxuan.github.io/2022/02/13/2022-02/2022-02-13%20%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEHexo%E5%8D%9A%E5%AE%A2/">阿里云服务器配置Hexo博客</a></p></li><li><p><a href="https://www.julydate.com/post/60859300/#%E6%80%BB%E7%BB%93">CDN加速</a></p></li><li><p><a href="https://github.com/cjh0613/hexo-submit-urls-to-search-engine">网站SEO优化</a></p></li></ul><hr /><p>最后附上我当时的心路历程：心态崩了，弄了几天也没绑定上自己的域名，然后CDN加速也需要配置自己的域名，后来想想还是算了，毕竟博客还是内容最重要，像是页面的美观或者是网站加载速度都是其次了，下次一定。（也只能这样安慰自己了，流下了无能的泪水）</p><center><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fww4.sinaimg.cn%2Fbmiddle%2F9150e4e5ly1fkonbtgn8aj20qo0qomyg.jpg&refer=http%3A%2F%2Fwww.sina.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647397220&t=7ee46f97d55b16b2e4057e967d3fc105" alt="" style="zoom:67%;" /></center><p class='note note-primary' >  <font size='4'>     最后总结来说，写博客，最重要的还是持之以恒，还是产出内容，不能本末倒置，捡了芝麻丢了西瓜。  </font></p>]]></content>
    
    
    <categories>
      
      <category>计算机知识</category>
      
      <category>环境搭建系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/25/2021-09/2021-09-25%20hello-world/"/>
    <url>/2021/09/25/2021-09/2021-09-25%20hello-world/</url>
    
    <content type="html"><![CDATA[<p>最初的博客，纪念那份探索新事物的激动与喜悦，也是告诉自己不忘初心。</p><p>Hello world !</p><p>I will be the best animation lover who is able to save the world !</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
