<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Zhang Yuxuan"><meta name="keywords" content=""><meta name="description" content="想要在C++领域深入，那么和Linux系统打交道是必不可少的。本篇博客就是记录常用的Linux命令，整合网上的一些学习文章，提供参考学习。"><meta property="og:type" content="article"><meta property="og:title" content="Linux命令学习"><meta property="og:url" content="https://2017zhangyuxuan.github.io/2022/02/01/2022-02/2022-02-01%20Linux%E5%91%BD%E4%BB%A4/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="想要在C++领域深入，那么和Linux系统打交道是必不可少的。本篇博客就是记录常用的Linux命令，整合网上的一些学习文章，提供参考学习。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/hexo_img/linux.jpeg"><meta property="article:published_time" content="2022-02-01T03:13:01.000Z"><meta property="article:modified_time" content="2023-12-17T09:07:50.567Z"><meta property="article:author" content="Zhang Yuxuan"><meta property="article:tag" content="Linux"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/hexo_img/linux.jpeg"><title>Linux命令学习 - Hexo</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"2017zhangyuxuan.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:40,cursorChar:"",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:"41ea7ec25546b456fd8c769b77c5f7b8",google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"y5CeAktdcKSzcAmVadWC9kvO-gzGzoHsz",app_key:"6DumtsnWAqBVLRmOTnmYxXx6",server_url:"https://y5ceaktd.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1},gtag:null},search_path:"/local-search.xml",include_content_in_search:!0});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>var _hmt;Fluid.ctx.dnt||(_hmt=_hmt||[],function(){var t=document.createElement("script"),e=(t.src="https://hm.baidu.com/hm.js?41ea7ec25546b456fd8c769b77c5f7b8",document.getElementsByTagName("script")[0]);e.parentNode.insertBefore(t,e)}())</script><meta name="generator" content="Hexo 7.0.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>KingOfDark</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/hexo_img/yourname6.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Linux命令学习"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-02-01 11:13" pubdate>2022年2月1日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>13 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Linux命令学习</h1><p id="updated-time" class="note note-info">本文最后更新于：2023年12月17日 下午</p><div class="markdown-body"><h1 id="任务挂起和恢复"><a href="#任务挂起和恢复" class="headerlink" title="任务挂起和恢复"></a>任务挂起和恢复</h1><p>我想大家应该都知道<code>ctrl+c</code>是终止任务&#x2F;进程， <code>ctrl+z</code>是任务挂起（将一个正在前台执行的命令放到后台，并且处于暂停状态），那么任务挂起后该如何恢复呢？经过查阅<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[ctrl+z 以后怎么恢复挂起的进程](https://www.cnblogs.com/zxRPI/p/7872413.html)">[1]</span></a></sup>，可以参考使用如下命令：</p><ol><li>jobs 显示当前暂停的进程</li><li>bg %N 使第N个任务在后台运行(%前有空格)</li><li>fg %N 使第N个任务在前台运行<p class="note note-info">注意：默认 bg 和 fg 不带%N时表示对最后一个进程操作</p></li></ol><hr><p>此外与任务&#x2F;进程控制相关的命令还有 &amp; 和 nohup<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[linux 远程主机后台运行任务 挂起脚本](https://www.jianshu.com/p/745a4cb32c47)">[2]</span></a></sup>。</p><p><code>Commod + &amp;</code> 在一个命令最后加上一个 &amp;，可以将这个命令放到后台执行；</p><p>如果让程序始终在后台执行，即使关闭当前的终端也执行（之前的&amp;做不到），这时候需要<code>nohup</code>。该命令可以在你退出帐户&#x2F;关闭终端之后继续运行相应的进程。<br>关闭终端后，在另一个终端jobs已经无法看到后台跑得程序了，此时利用ps（进程查看命令）</p><h1 id="验证JSON格式正确性"><a href="#验证JSON格式正确性" class="headerlink" title="验证JSON格式正确性"></a>验证JSON格式正确性</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat a.json | python -m json.tool | wc -l <br></code></pre></td></tr></table></figure><p>使用上述命令，可以检查一个文件是否符合json格式，其实现原理如下：</p><ul><li>要验证的文件 a.json；</li><li>如果返回结果一行数字，则表示 a.json 文件格式正确；</li><li>否则返回 a.json 文件中错误的行号及错误信息。</li></ul><p>一旦 JSON 文件格式不对，或者文件内容缺失或者其他问题，就会导致 python -m 命令无法格式化，正是利用这一点，我们可以做一个 JSON 的验证。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Linux开发小技巧](https://mp.weixin.qq.com/s/UwgHGSSnJhiYnDISxGQXag)">[3]</span></a></sup></p><hr><p>为了简化命令，可以利用alias设置命令别名，但是因为需要命令行参数传入文件名，而alias不支持命令行参数。在查阅资料后<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[linux中给 alias 添加自定义的参数](https://www.phpernote.com/linux/1431.html)">[4]</span></a></sup>，找到一种方法，就是通过定义函数的方式来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias isjson=&#x27;isjson()&#123;cat &quot;$1&quot; | python -m json.tool | wc -l&#125;; isjson&#x27;<br></code></pre></td></tr></table></figure><h1 id="GREP、SED、AWK命令"><a href="#GREP、SED、AWK命令" class="headerlink" title="GREP、SED、AWK命令"></a>GREP、SED、AWK命令</h1><h2 id="GREP"><a href="#GREP" class="headerlink" title="GREP"></a>GREP</h2><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Linux开发小技巧](https://mp.weixin.qq.com/s/UwgHGSSnJhiYnDISxGQXag)">[3]</span></a></sup></p><ul><li>grep默认是忽略二进制数据的，可以加上 <code>-a</code> 或 <code>--text</code> 来表示不忽略二进制文件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -a file_name<br>或<br>grep --text file_name <br></code></pre></td></tr></table></figure><ul><li><strong>-E</strong> : 使用正则表达式，匹配了才输出</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -E &quot;word1|word2|word3&quot; file.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">满足任意条件（word1、word2和word3之一）将匹配。</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep word1 file.txt | grep word2 |grep word3<br><span class="hljs-meta prompt_">#</span><span class="language-bash">必须同时满足三个条件（word1、word2和word3）才匹配。</span><br></code></pre></td></tr></table></figure><ul><li><strong>-r</strong> ：递归搜索目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -r word directory<br></code></pre></td></tr></table></figure><ul><li><strong>-v</strong> : 显示不包含匹配文本的所有行。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -v &#x27;abc\|efg&#x27; log.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">排除 log.txt 中的 abc efg 关键字</span><br></code></pre></td></tr></table></figure><h2 id="SED"><a href="#SED" class="headerlink" title="SED"></a>SED</h2><p>sed 可依照脚本的指令来处理、编辑文本文件。sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p><p>对文件进行文本替换操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s/原字符串/新字符串/&#x27; filename<br>sed -i &#x27;s/原字符串/新字符串/g&#x27; filename<br></code></pre></td></tr></table></figure><p><strong>-i</strong> 表示直接修改读取的文件内容，而不是输出到终端。</p><p>最后带 g 进行了一个全局的搜索；不带g的话，只是匹配每行的第一个字段，后面的匹配则会忽略。</p><hr><p>示例：</p><ul><li>sed 文件首尾添加引号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s/^/&quot;/;s/$/&quot;/&#x27;  log.txt<br></code></pre></td></tr></table></figure><ul><li>sed 文件尾添加逗号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s/$/,/&#x27;  txt<br></code></pre></td></tr></table></figure><p class="note note-info">注意上述命令在Mac系统的终端里会报错，需要在"-i" 后加上 ""</p><h2 id="AWK"><a href="#AWK" class="headerlink" title="AWK"></a>AWK</h2><p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。</p><ul><li>-F ：指定输入文件折分隔符</li><li>-v : 赋值一个用户定义变量。</li></ul><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">每行按空格或TAB分割，输出文本中的1、4项</span><br>awk &#x27;&#123;print $1,$4&#125;&#x27; log.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式化输出</span><br>awk &#x27;&#123;printf &quot;%-8s %-10s\n&quot;,$1,$4&#125;&#x27; log.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用<span class="hljs-string">&quot;,&quot;</span>分割</span><br>awk -F , &#x27;&#123;print $1,$2&#125;&#x27;   log.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用自定义变量</span><br>awk -v a=1 &#x27;&#123;print $1,$1+a&#125;&#x27; log.txt	# 数值加<br>awk -v a=1 &#x27;&#123;print $1,$1a&#125;&#x27; log.txt		# 字符加<br></code></pre></td></tr></table></figure><h1 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h1><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><ul><li>压缩文件： <code>zip 压缩文件名 源文件</code></li><li>压缩目录： <code>zip -r 压缩文件名 源目录</code></li><li>解压： <code>unzip 压缩文件名</code></li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir book<br>touch book/1.txt<br>touch book/2.txt<br>zip -r book.zip book<br>unzip book.zip<br></code></pre></td></tr></table></figure><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><table><thead><tr><th align="left">命令</th><th align="left">示例</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">gzip 源文件</td><td align="left">gzip a.txt</td><td align="left">压缩为.gz格式的压缩文件，源文件会消失</td></tr><tr><td align="left">gzip -c 源文件 &gt; 压缩文件</td><td align="left">gzip -c yum.txt &gt; yum.txt.gz</td><td align="left">压缩为.gz格式的压缩文件，源文件不会消失</td></tr><tr><td align="left">gzip -r 目录</td><td align="left">gzip -r xx</td><td align="left">压缩目录下的所有子文件，但是不压缩目录</td></tr><tr><td align="left">gzip -d 压缩文件名</td><td align="left">gzip -d yum.txt.gz</td><td align="left">解压缩文件,不保留压缩包</td></tr><tr><td align="left">gunzip 压缩文件</td><td align="left">gunzip yum.txt.gz</td><td align="left">解压缩文件,不保留压缩包</td></tr></tbody></table><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><ul><li>tar -cvf 打包文件名 源文件<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[linux总结](https://mp.weixin.qq.com/s/QyERReOEIBC5T4580ffVHw)">[5]</span></a></sup><ul><li>-c 打包</li><li>-v 显示过程</li><li>-f 指定打包后的文件名</li><li>-x 解打包</li></ul></li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -cvf book.tar book<br>tar -xvf book.tar<br></code></pre></td></tr></table></figure><p><strong>更多压缩命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar –cvf jpg.tar *.jpg #将目录里所有jpg文件打包成tar.jpg <br><br>tar –czf jpg.tar.gz *.jpg #将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz <br><br>tar –cjf jpg.tar.bz2 *.jpg #将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 <br><br>tar –cZf jpg.tar.Z *.jpg #将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z <br><br>rar a jpg.rar *.jpg #rar格式的压缩，需要先下载rar for linux <br><br>zip jpg.zip *.jpg #zip格式的压缩，需要先下载zip for linux<br></code></pre></td></tr></table></figure><p><strong>更多解压命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar –xvf file.tar #解压 tar包 <br><br>tar -xzvf file.tar.gz #解压tar.gz<br><br>tar -xjvf file.tar.bz2 #解压 tar.bz2 <br><br>tar –xZvf file.tar.Z #解压tar.Z <br><br>unrar e file.rar #解压rar <br><br>unzip file.zip #解压zip<br></code></pre></td></tr></table></figure><h1 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h1><blockquote><p>参考：<a target="_blank" rel="noopener" href="https://www.linuxprobe.com/soft-and-hard-links.html">软链接和硬链接的区别</a><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[软链接和硬链接的区别](https://www.linuxprobe.com/soft-and-hard-links.html)">[6]</span></a></sup></p></blockquote><p>我们知道文件都有文件名与数据，这在 <a target="_blank" rel="noopener" href="https://www.linuxprobe.com/">Linux</a> 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。而有一种方法可以快速的寻找到数据元，那就是软硬链接，链接实际上就是一种文件共享的方式。</p><p>那么软链接和硬链接的区别在哪呢？<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[linux中硬链接与软链接的区别](http://www.178linux.com/53101)">[7]</span></a></sup></p><ol><li><strong>首先，两者作用的对象不同：</strong></li></ol><ul><li>硬链接，只能应用于文件，而不能应用于目录，而且不能跨文件系统（即分区）；</li><li>软（符号）链接，可以应用于文件，而且可以应用于目录和可跨文件系统（分区）。</li></ul><ol start="2"><li><strong>其次，两者的作用原理不同：</strong></li></ol><ul><li>硬链接中，假如说A文件是B文件的硬连接文件，那么A和B的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的，硬链接中一个inode号可以对应多个文件。如果删除其中任何一个文件，另外一个文件还能连接数据块，还是有效的文件，只是对应的inode节点号减少，其它并无影响。只有inode节点号减少到0，数据块才会被系统回收。</li><li>而在软链接中，假如说A文件是B文件的软连接文件，则A和B的inode节点号不同，每创建一个新的软链接，就会有一个新的节点号。而A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是“主从”关系，如果B被删除了，A仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</li></ul><ol start="3"><li><strong>语法不同：</strong></li></ol><ul><li>硬链接的语法：<code>ln filename [linkname ]</code></li><li>软链接的语法：<code>ln -s filename [linkname]</code></li></ul><hr><p>最后总结一下：</p><ul><li>硬链接：与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块；</li><li>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问数据时，将用数据块中指向的文件路径进行替换。</li></ul><h1 id="其它shell技巧"><a href="#其它shell技巧" class="headerlink" title="其它shell技巧"></a>其它shell技巧</h1><h2 id="输入相似文件名"><a href="#输入相似文件名" class="headerlink" title="输入相似文件名"></a>输入相似文件名</h2><p>用花括号括起来的字符串之间再用逗号连接，可以实现自动扩展，非常有用。花括号中的每个字符都可以和之后（或之前）的字符串进行组合拼接，注意花括号和其中的逗号不可以用空格分隔，否则会被认为是普通的字符串对待。示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> &#123;one,two,three&#125;file</span><br>onefile twofile threefile<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> &#123;one,two,three&#125;&#123;1,2,3&#125;</span><br>one1 one2 one3 two1 two2 two3 three1 three2 three3<br></code></pre></td></tr></table></figure><p>这个技巧有什么实际用处呢？最简单实用的就是给 cp,mv,rm 等命令扩展参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> /search/code/file&#123;,.bak&#125;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给 file 复制一个叫做 file.bak 的副本</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rm</span> file&#123;1,3,5&#125;.txt</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除 file1.txt file3.txt file5.txt</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mv</span> *.&#123;c,cpp&#125; src/</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将所有 .c 和 .cpp 为后缀的文件移入 src 文件夹</span><br></code></pre></td></tr></table></figure><h2 id="命令快捷键"><a href="#命令快捷键" class="headerlink" title="命令快捷键"></a>命令快捷键</h2><table><thead><tr><th align="left">命令</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">ctrl+c</td><td align="left">强制终止当前命令</td></tr><tr><td align="left">ctrl+l</td><td align="left">清屏</td></tr><tr><td align="left">ctrl+a</td><td align="left">光标移动到命令行首</td></tr><tr><td align="left">ctrl+e</td><td align="left">光标移动到命令行尾</td></tr><tr><td align="left">ctrl+u</td><td align="left">从光标所在的位置删除到行首</td></tr><tr><td align="left">ctrl+z</td><td align="left">把命令放入后台</td></tr><tr><td align="left">ctrl+r</td><td align="left">在历史命令中搜索</td></tr><tr><td align="left">!n</td><td align="left">替换成第n条历史命令</td></tr><tr><td align="left">!!</td><td align="left">替换成上一条命令</td></tr><tr><td align="left">!字符</td><td align="left">替换成最后一条以该字符串开头的命令</td></tr></tbody></table><h2 id="命令连接符"><a href="#命令连接符" class="headerlink" title="命令连接符"></a>命令连接符</h2><ol><li><p><strong>; 分号</strong>：没有任何逻辑关系的连接符。当多个命令用分号连接时，各命令之间的执行成功与否彼此没有任何影响，都会一条一条执行下去。</p></li><li><p><strong>|| 逻辑或</strong>：当用此连接符连接多个命令时，前面的命令执行成功，则后面的命令不会执行。前面的命令执行失败，后面的命令才会执行。</p></li><li><p><strong>&amp;&amp; 逻辑与</strong>：当用此连接符连接多个命令时，前面的命令执行成功，才会执行后面的命令，前面的命令执行失败，后面的命令不会执行，与 || 正好相反。</p></li><li><p><strong>| 管道符</strong>：当用此连接符连接多个命令时，前面命令执行的正确输出，会交给后面的命令继续处理。若前面的命令执行失败，则会报错，若后面的命令无法处理前面命令的输出，也会报错</p></li></ol><h2 id="复制文本内容"><a href="#复制文本内容" class="headerlink" title="复制文本内容"></a>复制文本内容</h2><p>有时候不好在终端界面里，用鼠标操作选中并复制文件里的文本内容，可以用下面的命令来复制文件里的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">方法1，利用重定向</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pbcopy &lt; file.txt</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">方法2，利用管道</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> file.txt | pbcopy</span><br></code></pre></td></tr></table></figure><h1 id="Bonus-系统启动过程"><a href="#Bonus-系统启动过程" class="headerlink" title="Bonus: 系统启动过程"></a>Bonus: 系统启动过程</h1><blockquote><p>参考阮一峰大佬的这篇博客：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的</a><sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="[计算机是如何启动的](http://www.ruanyifeng.com/blog/2013/02/booting.html)">[8]</span></a></sup></p></blockquote><h2 id="1-BIOS"><a href="#1-BIOS" class="headerlink" title="1.BIOS"></a>1.BIOS</h2><ul><li>计算机通电后，第一件事就是读取刷入ROM芯片的开机程序，这个程序叫做(Basic Input&#x2F;Output System)</li></ul><h2 id="2-硬件自检"><a href="#2-硬件自检" class="headerlink" title="2.硬件自检"></a>2.硬件自检</h2><ul><li>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test)</li><li>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</li></ul><h2 id="3-启动顺序"><a href="#3-启动顺序" class="headerlink" title="3. 启动顺序"></a>3. 启动顺序</h2><ul><li>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</li><li>这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备</li><li>BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）</li><li>BIOS按照”启动顺序”，把控制权转交给排在第一位的储存设备。</li><li>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</li><li>这最前面的512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR）</li></ul><h2 id="4-主引导记录的结构"><a href="#4-主引导记录的结构" class="headerlink" title="4. 主引导记录的结构"></a>4. 主引导记录的结构</h2><ul><li><p>“主引导记录”只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。</p><ul><li><p>（1） 第1-446字节：是用来记录系统的启动信息的,调用操作系统的机器码</p></li><li><p>（2） 第447-510字节(64个字节)：分区表（Partition table），分区表的作用，是将硬盘分成若干个区</p></li><li><p>（3） 第511-512字节：主引导记录签名（0x55和0xAA）</p></li></ul></li></ul><h2 id="5-分区表"><a href="#5-分区表" class="headerlink" title="5. 分区表"></a>5. 分区表</h2><ul><li>磁盘分区是使用分区编辑器在磁盘上划分几个逻辑部分</li><li>磁盘一旦划分成多个分区，不同类的目录与文件可以存储进不同的分区内</li><li>“主引导记录”因此必须知道将控制权转交给哪个区</li><li>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”<ul><li>（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</li><li>（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。</li><li>（3） 第5个字节：主分区类型，比如FAT32、NTFS等。</li><li>（4） 第6-8个字节：主分区最后一个扇区的物理位置。</li><li>（5） 第9-12字节：该主分区第一个扇区的逻辑地址。</li><li>（6） 第13-16字节：主分区的扇区总数。</li></ul></li></ul><h2 id="6-硬盘启动"><a href="#6-硬盘启动" class="headerlink" title="6. 硬盘启动"></a>6. 硬盘启动</h2><ul><li>计算机的控制权就要转交给硬盘的某个分区了</li><li>四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做”卷引导记录”（Volume boot record，缩写为VBR）</li><li>“卷引导记录”的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</li></ul><h2 id="7-操作系统"><a href="#7-操作系统" class="headerlink" title="7. 操作系统"></a>7. 操作系统</h2><ul><li>控制权转交给操作系统后，操作系统的内核首先被载入内存。</li><li>以Linux系统为例，先载入<code>/boot</code>目录下面的<code>kernel</code>。内核加载成功后，第一个运行的程序是<code>/sbin/init</code>。它根据配置文件（Debian系统是&#x2F;etc&#x2F;initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代</li><li>然后，<code>init</code>线程加载系统的各个模块，比如窗口程序和网络程序，直至执行<code>/bin/login</code>程序，跳出登录界面，等待用户输入用户名和密码。</li></ul><hr><section class="footnotes"><h1>备注/参考</h1><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zxRPI/p/7872413.html">ctrl+z 以后怎么恢复挂起的进程</a> <a href="#fnref:1" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/745a4cb32c47">linux 远程主机后台运行任务 挂起脚本</a> <a href="#fnref:2" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UwgHGSSnJhiYnDISxGQXag">Linux开发小技巧</a> <a href="#fnref:3" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://www.phpernote.com/linux/1431.html">linux中给 alias 添加自定义的参数</a> <a href="#fnref:4" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/QyERReOEIBC5T4580ffVHw">linux总结</a> <a href="#fnref:5" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://www.linuxprobe.com/soft-and-hard-links.html">软链接和硬链接的区别</a> <a href="#fnref:6" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a target="_blank" rel="noopener" href="http://www.178linux.com/53101">linux中硬链接与软链接的区别</a> <a href="#fnref:7" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的</a> <a href="#fnref:8" rev="footnote" class="footnote-backref">↩</a></span></span></li></ol></div></section></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/" class="category-chain-item">计算机知识</a> <span>></span> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/Linux/" class="category-chain-item">Linux</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Linux/" class="print-no-link">#Linux</a></div></div><div class="license-box my-3"><div class="license-title"><div>Linux命令学习</div><div>https://2017zhangyuxuan.github.io/2022/02/01/2022-02/2022-02-01 Linux命令/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Zhang Yuxuan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年2月1日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/02/02/2022-02/2022-02-02%20Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" title="Linux命令行下性能分析"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Linux命令行下性能分析</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/01/31/2022-01/2022-01-31%20%E9%99%A4%E5%A4%95%E5%A4%9C%E6%B5%85%E8%B0%88/" title="除夕夜浅谈"><span class="hidden-mobile">除夕夜浅谈</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><script src="//cdn.jsdelivr.net/npm/@waline/client"></script><div id="waline"></div><script>Fluid.utils.loadComments("#waline",function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.15.8/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.15.8/waline.min.js",function(){var i=Object.assign({serverURL:"https://waline-comment-ten-blush.vercel.app/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.2.0/bmoji"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10,highlight:!0},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script></div></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">浙ICP备2022004380号-1 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11011502005551" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"> <span>京公网安备11011502005551号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>