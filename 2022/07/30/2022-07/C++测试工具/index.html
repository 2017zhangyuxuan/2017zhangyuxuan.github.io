<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="TDD（Test-Driven Development)测试驱动开发是工程实践开发的一大技术点，因此本期将介绍C++中常用的测试工具，包括经典的GoogleTest，以及一些轻量级的开源测试工具。"><meta name="author" content="Zhang Yuxuan"><meta name="keywords" content=""><meta name="description" content="TDD（Test-Driven Development)测试驱动开发是工程实践开发的一大技术点，因此本期将介绍C++中常用的测试工具，包括经典的GoogleTest，以及一些轻量级的开源测试工具。"><meta property="og:type" content="article"><meta property="og:title" content="C++测试工具"><meta property="og:url" content="https://2017zhangyuxuan.github.io/2022/07/30/2022-07/C++%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="TDD（Test-Driven Development)测试驱动开发是工程实践开发的一大技术点，因此本期将介绍C++中常用的测试工具，包括经典的GoogleTest，以及一些轻量级的开源测试工具。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-07-30T07:43:36.000Z"><meta property="article:modified_time" content="2022-07-31T09:01:31.774Z"><meta property="article:author" content="Zhang Yuxuan"><meta property="article:tag" content="C++"><meta property="article:tag" content="googletest"><meta name="twitter:card" content="summary_large_image"><title>C++测试工具 - Hexo</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/10.7.3/styles/github-gist.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"2017zhangyuxuan.github.io",root:"/",version:"1.8.12",typing:{enable:!0,typeSpeed:40,cursorChar:"",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:"41ea7ec25546b456fd8c769b77c5f7b8",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"y5CeAktdcKSzcAmVadWC9kvO-gzGzoHsz",app_key:"6DumtsnWAqBVLRmOTnmYxXx6",server_url:"https://y5ceaktd.lc-cn-n1-shared.com",path:"window.location.pathname"}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>KingOfDark</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://kingofdark-blog.oss-cn-beijing.aliyuncs.com/picture_backend/picture_backend/hexo_img/yourname6.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="C++测试工具"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-07-30 15:43" pubdate>2022年7月30日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 6.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 21 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">C++测试工具</h1><p class="note note-info">本文最后更新于：2022年7月31日 下午</p><div class="markdown-body"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>说来惭愧，断更了一个多月了，一方面的确是最近开始实习，时间变得紧张起来，另一方面也的确是自己偷懒了，松懈了不少。另外，比较难受的是，本来这篇博文已经在另一台电脑上写好了大概，准备上周就发的，但是因为被一些事情耽搁了，结果这周再去找的时候，结果发现原文找不到了，真的是老倒霉蛋了，所以只能硬着头皮重新写一篇 QAQ。</p><h1 id="gtest"><a class="markdownIt-Anchor" href="#gtest"></a> gtest</h1><p>那么首先来介绍GoogleTest（简称gtest），这是由google推出的C++测试框架，其功能之强大自然不必多说，接下来就简单介绍gtest的相关概念及其使用，更多的使用说明可以参考官方文档：<a target="_blank" rel="noopener" href="https://google.github.io/googletest/primer.html">https://google.github.io/googletest/primer.html</a></p><p>首先介绍一些术语概念，分别是 <em>Test</em>, <em>Test Case</em> and <em>Test Suite</em> ，这几个单词在gtest框架中的含义 与在<a target="_blank" rel="noopener" href="http://www.istqb.org/">ISTQB</a>（国际软件测试资质认证委员会）定义的含义有所不同，这里就介绍在gtest里的含义。因为历史原因，在gtest中， <em>Test</em> 认为是一个单元测试程序（指定输入，检测输出），而 <em>Test Cast</em> 被认为是一组相关的测试，现在，google开始用 <em>Test Suite</em> 来替换 <em>Test Case</em>。</p><p>此外，还有一些基本概念，例如在gtest中，使用断言（Assertion）判断一个条件成立与否，一个 Assertion 的结果可以是success, non-fatal failure, or fatal failure， 如果是fatal failure 则测试程序直接终止，而如果是non-fatal failure，则程序程序继续执行，只有当测试程序没有出现任何 failure 时，测试才算通过。一个 Test Suite可以包含多个 test，这些 test 可以共享一些对象和流程，可以放在 TestFixture class中。而一个测试程序可以包含多个 Test Suite。</p><p>刚刚提到了Assertion 断言，相关的API就是ASSERT_ * 和 EXPECT_ * ，如果ASSERT失败了则程序执行，而EXPECT失败了，则程序会继续执行下面的测试。可以使用TEST() 宏定义来创建一个简单的单元测试，同时gtest使用TestSuiteName来汇总test，所以具有相关性的test使用相同的TestSuiteName。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;...&#125;<br><br><span class="hljs-built_in">TEST</span>(TestSuiteName, TestName1) &#123;<br>  <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-built_in">func</span>(<span class="hljs-number">0</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-built_in">TEST</span>(TestSuiteName, TestName2) &#123;<br>  <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-built_in">func</span>(<span class="hljs-number">0</span>), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，<strong>TestSuiteName 和 TestName 最好不要使用下划线</strong>，因为在gtest源码中，会使用下划线将它们拼接成一个类名。这再简单介绍下gtest的实现吧，当我们使用TEST编写好一个test，该宏会将其展开为一个类，并声明一个TestBody函数，而TestBody的实现就是TEST里用户编写的逻辑。</p></blockquote><p>而当TestSuite中有公共流程时，就可以提取出来，避免重复编写，这就是TestFixture。TestFixture需要使用TEST_F来定义test，其中<code>SetUp</code>函数在会在每次TEST_F执行前初始化一次，<code>TearDown</code> 函数则是每次在执行完之后执行，释放资源。一个简单例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gtest/gtest.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FuncTest</span> :</span> <span class="hljs-keyword">public</span> ::testing::Test &#123;<br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>     q1_.<span class="hljs-built_in">Enqueue</span>(<span class="hljs-number">1</span>);<br>     q2_.<span class="hljs-built_in">Enqueue</span>(<span class="hljs-number">2</span>);<br>     q2_.<span class="hljs-built_in">Enqueue</span>(<span class="hljs-number">3</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>  &#125;<br><br>  Queue&lt;<span class="hljs-keyword">int</span>&gt; q0_;<br>  Queue&lt;<span class="hljs-keyword">int</span>&gt; q1_;<br>  Queue&lt;<span class="hljs-keyword">int</span>&gt; q2_;<br>&#125;;<br><br><span class="hljs-built_in">TEST_F</span>(FuncTest, IsEmptyInitially) &#123;<br>  <span class="hljs-built_in">EXPECT_EQ</span>(q0_.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-built_in">TEST_F</span>(FuncTest, DequeueWorks) &#123;<br>  <span class="hljs-keyword">int</span>* n = q0_.<span class="hljs-built_in">Dequeue</span>();<br>  <span class="hljs-built_in">EXPECT_EQ</span>(n, <span class="hljs-literal">nullptr</span>);<br><br>  n = q1_.<span class="hljs-built_in">Dequeue</span>();<br>  <span class="hljs-built_in">ASSERT_NE</span>(n, <span class="hljs-literal">nullptr</span>);    <span class="hljs-comment">// 继续运行已无必要，失败时直接中断</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(*n, <span class="hljs-number">1</span>);         <span class="hljs-comment">// 继续运行暴露更多问题</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(q1_.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">delete</span> n;<br><br>  ....<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  ::testing::<span class="hljs-built_in">InitGoogleTest</span>(&amp;argc, argv);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">RUN_ALL_TESTS</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>整体流程：</p><ol><li><p>缓存gtest flags的状态；</p></li><li><p>为第一个test创建TestFixture对象；</p></li><li><p>gtest创建FuncTest对象（o1）；</p></li><li><p>o1.SetUp()；</p></li><li><p>基于o1，运行第一个test（IsEmptyInitially）；</p></li><li><p>o1.TearDown；</p></li><li><p>析构o1；</p></li><li><p>在gtest flags中存储状态；</p></li><li><p>重复上述操作，运行下一个test（DequeueWorks），一直到结束；</p></li></ol><p class="note note-info">还值得一提的是，如果需要访问private & protected 成员和函数，可以添加编译选项 -fon-access-control，如果使用cmake的话，可以添加 ADD_COMPILE_OPTIONS(-fno-access-control)</p><h1 id="gmock"><a class="markdownIt-Anchor" href="#gmock"></a> gmock</h1><p>gmock也是gtest测试框架中的重要组成部分，当我们测试一个模块的时候，可能涉及到和其他模块交互，此时可以将模块之间的接口mock，模拟交互过程，其作用类似白盒测试中的打桩的概念。（打桩是软件测试里单元测试的一种方法，单元测试涉及手工编写测试集、指定输入数据以及为缺少的函数提供桩函数。给桩函数提供返回值叫做打桩。）</p><p>关于gmock的使用也可以查阅官方文档：<a target="_blank" rel="noopener" href="https://google.github.io/googletest/gmock_for_dummies.html">https://google.github.io/googletest/gmock_for_dummies.html</a></p><p>其基本使用方式为，当需要mock某一个类的成员方法（注意：需要声明为<strong>虚函数</strong>），定义一个派生类，然后继承需要mock的类，并声明<code>MOCK_METHOD</code> ，然后设置<code>EXPECT_CALL</code>指定其函数的返回行为。如下面的例子所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// origin file</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Origin</span> &#123;</span><br>    virutal ~<span class="hljs-built_in">Origin</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Do</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Do2</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// --------------------------------------------------------------</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gmock/gmock.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mock</span>:</span> <span class="hljs-keyword">public</span> Origin &#123;                       <span class="hljs-comment">// 派生</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">MOCK_METHOD</span>(<span class="hljs-keyword">int</span>, Do, (<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y), (<span class="hljs-keyword">override</span>));<br>        <span class="hljs-built_in">MOCK_METHOD</span>(<span class="hljs-keyword">int</span>, Do2, (), (<span class="hljs-keyword">const</span>, <span class="hljs-keyword">override</span>));<br>&#125;;<br><br><span class="hljs-keyword">using</span> ::testing::Return;                          <span class="hljs-comment">// 引入依赖函数</span><br><span class="hljs-keyword">using</span> ::testing::_;                               <span class="hljs-comment">// 引入依赖函数</span><br><br><span class="hljs-built_in">TEST</span>(BarTest, DoesThis) &#123;<br>  MockFoo foo;                                    <span class="hljs-comment">// 构建mock对象</span><br><br>  <span class="hljs-built_in">ON_CALL</span>(foo, <span class="hljs-built_in">Do2</span>())                         <span class="hljs-comment">// 设置默认行为,不要求被调用</span><br>      .<span class="hljs-built_in">WillByDefault</span>(<span class="hljs-built_in">Return</span>(<span class="hljs-number">1</span>));<br><br>  <span class="hljs-built_in">EXPECT_CALL</span>(foo, <span class="hljs-built_in">Do2</span>(<span class="hljs-number">5</span>, _))                   <span class="hljs-comment">// 开始设置命中matcher(x=50)期望</span><br>      .<span class="hljs-built_in">Times</span>(<span class="hljs-number">3</span>)                                 <span class="hljs-comment">// 期望被调用的次数</span><br>      .<span class="hljs-built_in">WillOnce</span>(<span class="hljs-built_in">Return</span>(<span class="hljs-number">100</span>))                    <span class="hljs-comment">// 期望的action</span><br>      .<span class="hljs-built_in">WillRepeatedly</span>(<span class="hljs-built_in">Return</span>(<span class="hljs-number">90</span>));<br>  <br>  <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-built_in">MyProductionFunction</span>(&amp;foo), <span class="hljs-string">&quot;good&quot;</span>);<span class="hljs-comment">//调用使用mock对象的函数</span><br>                                                <span class="hljs-comment">//可以检测函数结果</span><br>&#125;                           <span class="hljs-comment">// mock对象析构，gmock检测是否满足全部exception</span><br><br>........<br></code></pre></td></tr></table></figure><blockquote><p>如果没有显示指定<code>Times</code></p><ul><li><code>WillOnce</code> / <code>WillRepeatedly</code> 都没有在 EXPECT_CALL 中被调用，time = 1</li><li>n 个 <code>WillOnce</code>，没有 <code>WillRepeatedly</code> (n &gt;= 1)， time = n</li><li>n 个 <code>WillOnce</code>， 1个<code>WillRepeatedly</code> (n &gt;= 0)，time = AtLeast(n)</li></ul></blockquote><h2 id="mock_method"><a class="markdownIt-Anchor" href="#mock_method"></a> MOCK_METHOD</h2><p>其基本结构为如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMock</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">MOCK_METHOD</span>(ReturnType, MethodName, (Args..), (Specs..));<br>&#125;<br></code></pre></td></tr></table></figure><p>ReturnTypeo为被mock函数的返回类型，MethodName为被mock的函数名，（Args…)为被mock函数的参数，可选参数（Specs…)为mock函数修饰参数，如override,const等。</p><h2 id="expect_call"><a class="markdownIt-Anchor" href="#expect_call"></a> EXPECT_CALL</h2><p>给mock对象的命中matchers的method设定expection，需要在调用mock对象前设置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">EXPECT_CALL</span>(mock_object, <span class="hljs-built_in">method</span>(matchers...))<br>    .<span class="hljs-built_in">With</span>(multi_argument_matcher)  <span class="hljs-comment">// Can be used at most once</span><br>    .<span class="hljs-built_in">Times</span>(cardinality)            <span class="hljs-comment">// Can be used at most once</span><br>    .<span class="hljs-built_in">InSequence</span>(sequences...)      <span class="hljs-comment">// Can be used any number of times</span><br>    .<span class="hljs-built_in">After</span>(expectations...)        <span class="hljs-comment">// Can be used any number of times</span><br>    .<span class="hljs-built_in">WillOnce</span>(action)              <span class="hljs-comment">// Can be used any number of times</span><br>    .<span class="hljs-built_in">WillRepeatedly</span>(action)        <span class="hljs-comment">// Can be used at most once</span><br>    .<span class="hljs-built_in">RetiresOnSaturation</span>();        <span class="hljs-comment">// Can be used at most once</span><br></code></pre></td></tr></table></figure><ul><li><p>matchers：单值matcher，_表示接受任意参数，内置的matcher宏详见<a target="_blank" rel="noopener" href="https://google.github.io/googletest/reference/matchers.html">链接</a></p></li><li><p>multi_argument_matcher： <a target="_blank" rel="noopener" href="https://google.github.io/googletest/reference/matchers.html#MultiArgMatchers">多参数matcher</a>，约束method的参数的形式（Lt, 第一个参数小于第二）</p></li><li><p>Time：AnyNumber、AtLeast、Between … 限定执行次数</p></li><li><p>InSequence：指定mock函数的调用顺序。</p></li><li><p>After：指定mock函数在特定函数后调用</p></li><li><p>WillOnce: mock函数被调用时的单次<a target="_blank" rel="noopener" href="https://google.github.io/googletest/reference/actions.html">行为</a></p></li><li><p>WillRepeatedly: 所有后续的调用都命中的行为</p></li></ul><blockquote><p>EXPECT_CALL(mock, Func())</p><p>.WillOnce(Return(1)) // 第一次返回1</p><p>.WillRepeatedly(Return(2)) // 后续都返回2</p></blockquote><ul><li>RetriesOnSaturation: 命中足够次数后忽略</li></ul><blockquote><p>EXPECT_CALL(mock, do()).Times(AnyNumber());</p><p>EXPECT_CALL(mock, do(9)).Time(2).RetriesOnSaturation();</p></blockquote><h2 id="处理未包裹的逗号"><a class="markdownIt-Anchor" href="#处理未包裹的逗号"></a> 处理未包裹的逗号</h2><p>gmock的时候，如果函数原型中包含&quot;,&quot;信息，则会编译失败：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockM</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">MOCK_METHOD</span>(std::pair&lt;<span class="hljs-keyword">bool</span>, <span class="hljs-keyword">int</span>&gt;, GetPair, ());<br>        <span class="hljs-built_in">MOCK_METHOD</span>(<span class="hljs-keyword">bool</span>, CheckMap, (std::map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>&gt;, <span class="hljs-keyword">bool</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>可选如下的解决方法：</p><ol><li>( ) 包裹</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">class MockM &#123;<br>    public:<br>        MOCK_METHOD((std::pair&lt;bool, int&gt;), GetPair, ());<br>        MOCK_METHOD(bool, CheckMap, ((std::map&lt;int, double&gt;), bool));<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>定义alias</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">class MockM &#123;<br>    public:<br>        using BoolAndInt = std::pair&lt;bool, int&gt;;<br>        MOCK_METHOD(BoolAndInt, GetPair, ());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有序调用"><a class="markdownIt-Anchor" href="#有序调用"></a> 有序调用</h2><p>代码中指定某些函数，按顺序执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">using ::testing::InSequence;<br><br>TEST(FooTest, test) &#123;<br>    &#123;<br>        InSequence seq;<br>        EXPECT_CALL(turtle, PenDown());<br>        EXPECT_CALL(turtle, Forward(100));<br>        EXPECT_CALL(turtle, PenUp());<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="轻量级开源测试工具"><a class="markdownIt-Anchor" href="#轻量级开源测试工具"></a> 轻量级开源测试工具</h1><p>因为GoogleTest依赖比较重，因此 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-6HMlVLSRdd6ycr5fSqhKw">现代C++ Unit Test库</a> 这篇文章介绍几个轻量易用的单元测试库，doctest（对应于gtest），fakeit（对应于gmock，同时还能集成到gtest中），nanobench（benchmark库），这几个开源库只需要引入头文件即可使用，非常方便。文章里也都有简单的使用介绍，或者看看github上的文档即可，这里就不再赘述了（<s>实际上是不想再写第二遍了</s>）。不过简单使用之后，个人感觉和gtest和gmock差别不是很大，如果项目不大或者此前也没怎么用过C++测试工具的话，这两个工具可以尝试一下的，当然直接去学习gtest和gmock也不亏，就是需要点成本罢了。</p><p>不过这个nanobench库还是值得学习了解的，因为此前我对性能测试相关的工具了解不多，下面列了下其官方文档上给的例子，这里做个简单的翻译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ANKERL_NANOBENCH_IMPLEMENT</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;nanobench.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> d = <span class="hljs-number">1.0</span>;<br>    ankerl::nanobench::<span class="hljs-built_in">Bench</span>().<span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;some double ops&quot;</span>, [&amp;] &#123;<br>        d += <span class="hljs-number">1.0</span> / d;<br>        <span class="hljs-keyword">if</span> (d &gt; <span class="hljs-number">5.0</span>) &#123;<br>            d -= <span class="hljs-number">5.0</span>;<br>        &#125;<br>        ankerl::nanobench::<span class="hljs-built_in">doNotOptimizeAway</span>(d);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:right">ns/op</th><th style="text-align:right">op/s</th><th style="text-align:right">err%</th><th style="text-align:right">ins/op</th><th style="text-align:right">cyc/op</th><th style="text-align:right">IPC</th><th style="text-align:right">bra/op</th><th style="text-align:right">miss%</th><th style="text-align:right">total</th><th style="text-align:left">benchmark</th></tr></thead><tbody><tr><td style="text-align:right">7.52</td><td style="text-align:right">132,948,239.79</td><td style="text-align:right">1.1%</td><td style="text-align:right">6.65</td><td style="text-align:right">24.07</td><td style="text-align:right">0.276</td><td style="text-align:right">1.00</td><td style="text-align:right">8.9%</td><td style="text-align:right">0.00</td><td style="text-align:left"><code>some double ops</code></td></tr></tbody></table><p>其结果如上表所示，大概含义是上面执行的代码花费了7.52纳秒，因此大约每秒能执行133 millon 次，测量浮动率为1.1%，每次执行需要6.65条指令，24.07个CPU周期，因此IPC （指令/时钟）为0.276。该代码中只有1个分支，分支预测失败概率为8.9%，最后的total为执行时间，这里显示0.00 表示只花费一些毫秒。</p><blockquote><p>需要注意的是，CPU的一些数据，如指令数，CPU周期，分支数与分支预测失败率只能在Linux获取，因为是通过perf events采集得到的。</p></blockquote><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>最后小结一下吧，在学校的时候，其实自己都没怎么关注过测试，随手写的一些项目代码，都是只要能正确实现功能就行，没有说要写什么测试代码来保证代码质量，但是到了实际生产工作中，单元测试就被重视起来了，</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/">计算机知识</a> <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/C/">C++</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/C/">C++</a> <a class="hover-with-bg" href="/tags/googletest/">googletest</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2023/10/17/2023-10/%E7%A7%8B%E6%8B%9B%E6%B5%85%E8%B0%88/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">秋招浅谈</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/06/11/2022-06/2022-06-11%20%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"><span class="hidden-mobile">【操作系统】内存管理</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="waline"></div><script>Fluid.utils.loadComments("#waline",function(){Fluid.utils.createScript("https://lib.baomitu.com/waline/2.5.1/Waline.min.js",function(){var a=Object.assign({serverURL:"https://blog-api-cwpbgt9h8-2017zhangyuxuan.vercel.app",path:"window.location.pathname",placeholder:"期待地搓搓手~",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],dark:'html[data-user-color-scheme="dark"]',avatar:"mp",avatarCDN:"https://seccdn.libravatar.org/avatar/",avatarForce:!1,wordLimit:0,pageSize:10,highlight:!0},{el:"#waline",path:window.location.pathname});new Waline(a),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{Fluid.plugins.initFancyBox("#waline .vcontent img:not(.vemoji)")})})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><br></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">浙ICP备2022004380号-1 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11011502005551" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"> <span>京公网安备11011502005551号</span></a></span></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/local-search.js"></script><script src="/js/img-lazyload.js"></script><script src="https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js"></script><script src="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js"></script><script defer src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script defer src="/js/leancloud.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){(0,Fluid.plugins.typing)(t.getElementById("subtitle").title)}((window,document))</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?41ea7ec25546b456fd8c769b77c5f7b8";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script src="/js/boot.js"></script></body></html>